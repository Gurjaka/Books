<?xml version="1.0" encoding="UTF-8"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
<description>
    <title-info>
        <book-title>Linux System Programming</book-title>
        <author><first-name>Robert</first-name><last-name>Love</last-name></author>
        <genre>COMPUTERS / Operating Systems / Linux</genre>
        <annotation><p>This book is about writing software that makes the most effective use of the system you're running on -- code that interfaces directly with the kernel and core system libraries, including the shell, text editor, compiler, debugger, core utilities, and system daemons. Written primarily for engineers looking to program (better) at the low level, this book can give any programmer an understanding of core internals that makes for better code, no matter where it appears in the stack.</p><empty-line/></annotation>
        <coverpage><image l:href="#img_0"/></coverpage>
        <lang>en</lang>
        <keywords>COMPUTERS / Operating Systems / Linux</keywords>
        </title-info>
    <document-info>
        <author><first-name>Robert</first-name><last-name>Love</last-name></author>
        <program-used>calibre 5.40.0</program-used>
        <date>18.4.2022</date>
        <id>d9354536-10c6-4def-9ab8-1e5bfbab4144</id>
        <version>1.0</version>
    </document-info>
    <publish-info>
        <year>2009</year><publisher>O'Reilly Media</publisher><isbn>9780596159238</isbn>
    </publish-info>
</description>
<body>
<section>
<empty-line/>
<p><strong>Linux System Programming</strong></p>
<p><strong>Robert Love</strong></p>
<empty-line/><empty-line/><empty-line/><empty-line/><empty-line/><empty-line/><empty-line/><empty-line/><empty-line/>
<p>Published by O’Reilly Media</p>
<empty-line/>
<p><image l:href="#img_1"/></p>
<p>Beijing ⋅ Cambridge ⋅ Farnham ⋅ Köln ⋅ Sebastopol ⋅ Tokyo</p>
</section>
<section>
<empty-line/>
<p><strong>Foreword</strong></p>
<p>There is an old line that Linux kernel developers like to throw out
    when they are feeling grumpy: "User space is just a test load for the
    kernel."</p>
<p>By muttering this line, the kernel developers aim to wash their
    hands of all responsibility for any failure to run user-space code as well
    as possible. As far as they're concerned, user-space developers should
    just go away and fix their own code, as any problems are definitely not
    the kernel's fault.</p>
<p>To prove that it usually is not the kernel that is at fault, one
    leading Linux kernel developer has been giving a "Why User Space Sucks"
    talk to packed conference rooms for more than three years now, pointing
    out real examples of horrible user-space code that everyone relies on
    every day. Other kernel developers have created tools that show how badly
    user-space programs are abusing the hardware and draining the batteries of
    unsuspecting laptops.</p>
<p>But while user-space code might be just a "test load" for kernel
    developers to scoff at, it turns out that all of these kernel developers
    also depend on that user-space code every day. If it weren't present, all
    the kernel would be good for would be to print out alternating ABABAB
    patterns on the screen.</p>
<p>Right now, Linux is the most flexible and powerful operating system
    that has ever been created, running everything from the tiniest cell
    phones and embedded devices to more than 70 percent of the world's top 500
    supercomputers. No other operating system has ever been able to scale so
    well and meet the challenges of all of these different hardware types and
    environments.</p>
<p>And along with the kernel, code running in user space on Linux can
    also operate on all of those platforms, providing the world with real
    applications and utilities people rely on.</p>
<p>In this book, Robert Love has taken on the unenviable task of
    teaching the reader about almost every system call on a Linux system. In
    so doing, he has produced a tome that will allow you to fully understand
    how the Linux kernel works from a user-space perspective, and also how to
    harness the power of this system.</p>
<p>The information in this book will show you how to create code that
    will run on all of the different Linux distributions and hardware types.
    It will allow you to understand how Linux works and how to take advantage
    of its flexibility.</p>
<p>In the end, this book teaches you how to write code that doesn't
    suck, which is the best thing of all.</p>
<p>—Greg Kroah-Hartman</p>
</section>
<section>
<empty-line/>
<p><strong>Preface</strong></p>
<p>This book is about system programming—specifically, system
    programming on Linux. <emphasis>System programming</emphasis> is the
    practice of writing <emphasis>system software</emphasis>, which is code
    that lives at a low level, talking directly to the kernel and core system
    libraries. Put another way, the topic of the book is Linux system calls
    and other low-level functions, such as those defined by the C
    library.</p>
<p>While many books cover system programming for Unix systems, few
    tackle the subject with a focus solely on Linux, and fewer still (if any)
    address the very latest Linux releases and advanced Linux-only interfaces.
    Moreover, this book benefits from a special touch: I have written a lot of
    code for Linux, both for the kernel and for system software built thereon.
    In fact, I have implemented some of the system calls and other features
    covered in this book. Consequently, this book carries a lot of insider
    knowledge, covering not just how the system interfaces
    <emphasis>should</emphasis> work, but how they
    <emphasis>actually</emphasis> work, and how you (the programmer) can use
    them most efficiently. This book, therefore, combines in a single work a
    tutorial on Linux system programming, a reference manual covering the
    Linux system calls, and an insider's guide to writing smarter, faster
    code. The text is fun and accessible, and regardless of whether you code
    at the system level on a daily basis, this book will teach you tricks that
    will enable you to write better code.</p>
<empty-line/>
<p><strong>Audience and Assumptions</strong></p>
<p>The following pages assume that the reader is familiar with C
      programming and the Linux programming environment—not necessarily
      well-versed in the subjects, but at least acquainted with them. If you
      have not yet read any books on the C programming language, such as the
      classic Brian W. Kernighan and Dennis M. Ritchie work <emphasis>The C
      Programming Language</emphasis> (Prentice Hall; the book is familiarly
      known as K&amp;R), I highly recommend you check one out. If you are not
      comfortable with a Unix text editor—Emacs and <emphasis>vim</emphasis>
      being the most common and highly regarded—start playing with one. You'll
      also want to be familiar with the basics of using
      <emphasis>gcc</emphasis>, <emphasis>gdb</emphasis>,
      <emphasis>make</emphasis>, and so on. Plenty of other books on tools and
      practices for Linux programming are out there; the bibliography at the
      end of this book lists several useful references.</p>
<p>I've made few assumptions about the reader's knowledge of Unix or
      Linux system programming. This book will start from the ground up,
      beginning with the basics, and winding its way up to the most advanced
      interfaces and optimization tricks. Readers of all levels, I hope, will
      find this work worthwhile and learn something new. In the course of
      writing the book, I certainly did.</p>
<p>Nor do I make assumptions about the persuasion or motivation of
      the reader. Engineers wishing to program (better) at a low level are
      obviously targeted, but higher-level programmers looking for a stronger
      standing on the foundations on which they rest will also find a lot to
      interest them. Simply curious hackers are also welcome, for this book
      should satiate their hunger, too. Whatever readers want and need, this
      book should cast a net wide enough—as least as far as Linux system
      programming is concerned—to satisfy them.</p>
<p>Regardless of your motives, above all else, <emphasis>have
      fun</emphasis>.</p>
<empty-line/>
<p><strong>Contents of This Book</strong></p>
<p>This book is broken into 10 chapters, an appendix, and a
      bibliography.</p>
<p>Chapter 1</p>
<p>This chapter serves as an introduction, providing an
            overview of Linux, system programming, the kernel, the C library,
            and the C compiler. Even advanced users should visit this
            chapter—trust me.Chapter 2</p>
<p>This chapter introduces files, the most important
            abstraction in the Unix environment, and file I/O, the basis of
            the Linux programming mode. This chapter covers reading from and
            writing to files, along with other basic file I/O operations. The
            chapter culminates with a discussion on how the Linux kernel
            implements and manages files.Chapter 3</p>
<p>This chapter discusses an issue with the basic file I/O
            interfaces—buffer size management—and introduces buffered I/O in
            general, and standard I/O in particular, as solutions.Chapter 4</p>
<p>This chapter completes the I/O troika with a treatment on
            advanced I/O interfaces, memory mappings, and optimization
            techniques. The chapter is capped with a discussion on avoiding
            seeks, and the role of the Linux kernel's I/O scheduler.Chapter 5</p>
<p>This chapter introduces Unix's second most important
            abstraction, the <emphasis>process</emphasis>, and the family of
            system calls for basic process management, including the venerable
            <emphasis>fork</emphasis>.Chapter 6</p>
<p>This chapter continues the treatment with a discussion of
            advanced process management, including real-time processes.Chapter 7</p>
<p>This chapter discusses creating, moving, copying, deleting,
            and otherwise managing files and directories.Chapter 8</p>
<p>This chapter covers memory management. It begins by
            introducing Unix concepts of memory, such as the process address
            space and the page, and continues with a discussion of the
            interfaces for obtaining memory from and returning memory to the
            kernel. The chapter concludes with a treatment on advanced
            memory-related interfaces.Chapter 9</p>
<p>This chapter covers signals. It begins with a discussion of
            signals and their role on a Unix system. It then covers signal
            interfaces, starting with the basic, and concluding with the
            advanced.Chapter 10</p>
<p>This chapter discusses time, sleeping, and clock management.
            It covers the basic interfaces up through POSIX clocks and
            high-resolution timers.Appendix A</p>
<p>The Appendix reviews many of the optimizations provided by
            <emphasis>gcc</emphasis> and GNU C, such as attributes for marking
            a function constant, pure, and inline.</p>
<p>The book concludes with a bibliography of recommended reading,
      listing both useful supplements to this work, and books that address
      prerequisite topics not covered herein.</p>
<empty-line/>
<p><strong>Versions Covered in This Book</strong></p>
<p>The Linux system interface is definable as the application binary
      interface and application programming interface provided by the triplet
      of the Linux kernel (the heart of the operating system), the GNU C
      library (<emphasis>glibc</emphasis>), and the GNU C Compiler
      (<emphasis>gcc</emphasis>—now formally called the GNU Compiler
      Collection, but we are concerned only with C). This book covers the
      system interface defined by Linux kernel version 2.6.22,
      <emphasis>glibc</emphasis> version 2.5, and <emphasis>gcc</emphasis>
      version 4.2. Interfaces in this book should be backward compatible with
      older versions (excluding new interfaces), and forward compatible to
      newer versions.</p>
<p>If any evolving operating system is a moving target, Linux is a
      rabid cheetah. Progress is measured in days, not years, and frequent
      releases of the kernel and other components constantly morph the playing
      field. No book can hope to capture such a dynamic beast in a timeless
      fashion.</p>
<p>Nonetheless, the programming environment defined by system
      programming is <emphasis>set in stone</emphasis>. Kernel developers go
      to great pains not to break system calls, the <emphasis>glibc</emphasis>
      developers highly value forward <emphasis>and</emphasis> backward
      compatibility, and the Linux toolchain generates compatible code across
      versions (particularly for the C language). Consequently, while Linux
      may be constantly on the go, Linux system programming remains stable,
      and a book based on a snapshot of the system, especially at this point
      in Linux's development, has immense staying power. What I am trying to
      say is simple: don't worry about system interfaces changing, and
      <emphasis>buy this book</emphasis>!</p>
<empty-line/>
<p><strong>Conventions Used in This Book</strong></p>
<p>The following typographical conventions are used in this
      book:</p>
<p><emphasis>Italic</emphasis></p>
<p>Used for emphasis, new terms, URLs, foreign phrases, Unix
            commands and utilities, filenames, directory names, and
            pathnames.Constant width</p>
<p>Indicates header files, variables, attributes, functions,
            types, parameters, objects, macros, and other programming
            constructs.<emphasis>Constant width italic</emphasis></p>
<p>Indicates text (for example, a pathname component) to be
            replaced with a user-supplied value.</p>
<p><strong>Tip</strong></p>
<p>This icon signifies a tip, suggestion, or general note.</p>
<p>Most of the code in this book is in the form of brief, but usable,
      code snippets. They look like this:while (1) {
        int ret;

        ret = fork (  );
        if (ret == −1)
                perror ("fork");
}</p>
<p>Great pains have been taken to provide code snippets that are
      concise but usable. No special header files, full of crazy macros and
      illegible shortcuts, are required. Instead of building a few gigantic
      programs, this book is filled with many simple examples. As the examples
      are descriptive and fully usable, yet small and clear, I hope they will
      provide a useful tutorial on the first read, and remain a good reference
      on subsequent passes.</p>
<p>Nearly all of the examples in this book are self-contained. This
      means you can easily copy them into your text editor, and put them to
      actual use. Unless otherwise mentioned, all of the code snippets should
      build without any special compiler flags. (In a few cases, you need to
      link with a special library.) I recommend the following command to
      compile a source file:$ gcc -Wall -Wextra -O2 -g -o snippet snippet.c</p>
<p>This compiles the source file <emphasis>snippet.c</emphasis> into
      the executable binary <emphasis>snippet</emphasis>, enabling many
      warning checks, significant but sane optimizations, and debugging. The
      code in this book should compile using this command without errors or
      warnings—although of course, you might have to build a skeleton program
      around the snippet first.</p>
<p>When a section introduces a new function, it is in the usual Unix
      manpage format with a special emphasized font, which looks like
      this:<strong>#include &lt;fcntl.h&gt;

int posix_fadvise (int fd, off_t pos, off_t len, int advice);</strong></p>
<p>The required headers, and any needed definitions, are at the top,
      followed by a full prototype of the call.</p>
<empty-line/>
<p><strong>Safari® Books Online</strong></p>
<p>When you see a Safari® Books Online icon on the cover of your
      favorite technology book, that means the book is available online
      through the O'Reilly Network Safari Bookshelf.</p>
<p>Safari offers a solution that's better than e-books. It's a
      virtual library that lets you easily search thousands of top tech books,
      cut and paste code samples, download chapters, and find quick answers
      when you need the most accurate, current information. Try it for free at
      <a l:href="http://safari.oreilly.com">http://safari.oreilly.com</a>.</p>
<empty-line/>
<p><strong>Using Code Examples</strong></p>
<p>This book is here to help you get your job done. In general, you
      may use the code in this book in your programs and documentation. You do
      not need to contact us for permission unless you are reproducing a
      significant portion of the code. For example, writing a program that
      uses several chunks of code from this book does not require permission.
      Selling or distributing a CD-ROM of examples from O'Reilly books does
      require permission. Answering a question by citing this book and quoting
      example code does not require permission. Incorporating a significant
      amount of example code from this book into your product's documentation
      does require permission.</p>
<p>We appreciate attribution. An attribution usually includes the
      title, author, publisher, and ISBN. For example: "<emphasis>Linux System
      Programming</emphasis> by Robert Love. Copyright 2007 O'Reilly Media,
      Inc., 978-0-596-00958-8."</p>
<p>If you believe that your use of code examples falls outside of
      fair use or the permission given above, feel free to contact us at
      permissions@oreilly.com.</p>
<empty-line/>
<p><strong>How to Contact Us</strong></p>
<p>Please address comments and questions concerning this book to the
      publisher:O'Reilly Media, Inc.1005 Gravenstein Highway NorthSebastopol, CA 95472800-998-9938 (in the United States or Canada)707-829-0515 (international or local)707-829-0104 (fax)</p>
<p>We have a web page for this book, where we list errata, examples,
      and any additional information. You can access this page at this
      address:<a l:href="http://www.oreilly.com/catalog/9780596009588/">http://www.oreilly.com/catalog/9780596009588/</a></p>
<p>To comment or ask technical questions about this book, you can
      send an email to the following address:bookquestions@oreilly.com</p>
<p>For more information about our books, conferences, Resource
      Centers, and the O'Reilly Network, see our web site at this
      address:<a l:href="http://www.oreilly.com">http://www.oreilly.com</a></p>
<empty-line/>
<p><strong>Acknowledgments</strong></p>
<p>Many hearts and minds contributed to the completion of this
      manuscript. While no list would be complete, it is my sincere pleasure
      to acknowledge the assistance and friendship of individuals who provided
      encouragement, knowledge, and support along the way.</p>
<p>Andy Oram is a phenomenal editor and human being. This effort
      would have been impossible without his hard work. A rare breed, Andy
      couples deep technical knowledge with a poetic command of the English
      language.</p>
<p>Brian Jepson served brilliantly as editor for a period, and his
      sterling efforts continue to reverberate throughout this work as
      well.</p>
<p>This book was blessed with phenomenal technical reviewers, true
      masters of their craft, without whom this work would pale in comparison
      to the final product you now read. The technical reviewers were Robert
      Day, Jim Lieb, Chris Rivera, Joey Shaw, and Alain Williams. Despite
      their toils, any errors remain my own.</p>
<p>Rachel Head performed flawlessly as copyeditor. In her aftermath,
      red ink decorated my written word—readers will certainly appreciate her
      corrections.</p>
<p>For numerous reasons, thanks and respect to Paul Amici, Mikey
      Babbitt, Keith Barbag, Jacob Berkman, Dave Camp, Chris DiBona, Larry
      Ewing, Nat Friedman, Albert Gator, Dustin Hall, Joyce Hawkins, Miguel de
      Icaza, Jimmy Krehl, Greg Kroah-Hartman, Doris Love, Jonathan Love, Linda
      Love, Tim O'Reilly, Aaron Matthews, John McCain, Randy O'Dowd, Salvatore
      Ribaudo and family, Chris Rivera, Joey Shaw, Sarah Stewart, Peter
      Teichman, Linus Torvalds, Jon Trowbridge, Jeremy VanDoren and family,
      Luis Villa, Steve Weisberg and family, and Helen Whisnant.</p>
<p>Final thanks to my parents, Bob and Elaine.</p>
<p>—Robert Love</p>
<p>Boston</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 1. Introduction and Essential Concepts</strong></p>
<p>This book is about <emphasis>system programming</emphasis>, which is
    the art of writing <emphasis>system software</emphasis>. System software
    lives at a low level, interfacing directly with the kernel and core system
    libraries. System software includes your shell and your text editor, your
    compiler and your debugger, your core utilities and system daemons. These
    components are entirely system software, based on the kernel and the C
    library. Much other software (such as high-level GUI applications) lives
    mostly in the higher levels, delving into the low level only on occasion,
    if at all. Some programmers spend all day every day writing system
    software; others spend only part of their time on this task. There is no
    programmer, however, who does not benefit from some understanding of
    system programming. Whether it is the programmer's <emphasis>raison
    d'être</emphasis>, or merely a foundation for higher-level concepts,
    system programming is at the heart of all software that we
    write.</p>
<p>In particular, this book is about system programming on
    <emphasis>Linux</emphasis>. Linux is a modern Unix-like system, written
    from scratch by Linus Torvalds, and a loose-knit community of hackers
    around the globe. Although Linux shares the goals and ideology of Unix,
    Linux is not Unix. Instead, Linux follows its own course, diverging where
    desired, and converging only where practical. Generally, the core of Linux
    system programming is the same as on any other Unix system. Beyond the
    basics, however, Linux does well to differentiate itself—in comparison
    with traditional Unix systems, Linux is rife with additional system calls,
    different behavior, and new features.</p>
<empty-line/>
<p><strong>System Programming</strong></p>
<p>Traditionally speaking, all Unix programming is system-level
      programming. Historically, Unix systems did not include many
      higher-level abstractions. Even programming in a development environment
      such as the X Window System exposed in full view the core Unix system
      API. Consequently, it can be said that this book is a book on Linux
      programming in general. But note that this book does not cover the Linux
      programming <emphasis>environment</emphasis>—there is no tutorial on
      <emphasis>make</emphasis> in these pages. What is covered is the system
      programming API exposed on a modern Linux machine.</p>
<p>System programming is most commonly contrasted with application
      programming. System-level and application-level programming differ in
      some aspects, but not in others. System programming is distinct in that
      system programmers must have a strong awareness of the hardware and
      operating system on which they are working. Of course, there are also
      differences between the libraries used and calls made. Depending on the
      "level" of the stack at which an application is written, the two may not
      actually be very interchangeable, but, generally speaking, moving from
      application programming to system programming (or vice versa) is not
      hard. Even when the application lives very high up the stack, far from
      the lowest levels of the system, knowledge of system programming is
      important. And the same good practices are employed in all forms of
      programming.</p>
<p>The last several years have witnessed a trend in application
      programming away from system-level programming and toward very
      high-level development, either through web software (such as JavaScript
      or PHP), or through managed code (such as C# or Java). This development,
      however, does not foretell the death of system programming. Indeed,
      someone still has to write the JavaScript interpreter and the C#
      runtime, which is itself system programming. Furthermore, the developers
      writing PHP or Java can still benefit from knowledge of system
      programming, as an understanding of the core internals allows for better
      code no matter where in the stack the code is written.</p>
<p>Despite this trend in application programming, the majority of
      Unix and Linux code is still written at the system level. Much of it is
      C, and subsists primarily on interfaces provided by the C library and
      the kernel. This is traditional system programming—Apache,
      <emphasis>bash</emphasis>, <emphasis>cp</emphasis>, Emacs,
      <emphasis>init</emphasis>, <emphasis>gcc</emphasis>,
      <emphasis>gdb</emphasis>, <emphasis>glibc</emphasis>,
      <emphasis>ls</emphasis>, <emphasis>mv</emphasis>,
      <emphasis>vim</emphasis>, and X. These applications are not going away
      anytime soon.</p>
<p>The umbrella of system programming often includes kernel
      development, or at least device driver writing. But this book, like most
      texts on system programming, is unconcerned with kernel development.
      Instead, it focuses on user-space system-level programming; that is,
      everything above the kernel (although knowledge of kernel internals is a
      useful adjunct to this text). Likewise, network programming—sockets and
      such—is not covered in this book. Device driver writing and network
      programming are large, expansive topics, best tackled in books dedicated
      to the subject.</p>
<p>What is the system-level interface, and how do I write
      system-level applications in Linux? What exactly do the kernel and the C
      library provide? How do I write optimal code, and what tricks does Linux
      provide? What neat system calls are provided in Linux compared to other
      Unix variants? How does it all work? Those questions are at the center
      of this book.</p>
<p>There are three cornerstones to system programming in Linux:
      system calls, the C library, and the C compiler. Each deserves an
      introduction.</p>
<empty-line/>
<p><strong>System Calls</strong></p>
<p>System programming starts with <emphasis>system
        calls</emphasis>. System calls (often shorted to
        <emphasis>syscalls</emphasis>) are function invocations made from user
        space—your text editor, favorite game, and so on—into the kernel (the
        core internals of the system) in order to request some service or
        resource from the operating system. System calls range from the
        familiar, such as read( ) and
        write( ), to the exotic, such as
        get_thread_area( ) and set_tid_address( ).</p>
<p>Linux implements far fewer system calls than most other
        operating system kernels. For example, a count of the i386
        architecture's system calls comes in at around 300, compared with the
        allegedly thousands of system calls on Microsoft Windows. In the Linux
        kernel, each machine architecture (such as Alpha, i386, or PowerPC)
        implements its own list of available system calls. Consequently, the
        system calls available on one architecture may differ from those
        available on another. Nonetheless, a very large subset of system
        calls—more than 90 percent—is implemented by all architectures. It is
        this shared subset, these common interfaces, that I cover in this
        book.</p>
<empty-line/>
<p><strong>Invoking system calls</strong></p>
<p>It is not possible to directly link user-space applications
          with kernel space. For reasons of security and reliability,
          user-space applications must not be allowed to directly execute
          kernel code or manipulate kernel data. Instead, the kernel must
          provide a mechanism by which a user-space application can "signal"
          the kernel that it wishes to invoke a system call. The application
          can then <emphasis>trap</emphasis> into the kernel through this
          well-defined mechanism, and execute only code that the kernel allows
          it to execute. The exact mechanism varies from architecture to
          architecture. On i386, for example, a user-space application
          executes a software interrupt instruction, int, with a value of 0x80. This instruction causes a switch
          into kernel space, the protected realm of the kernel, where the
          kernel executes a software interrupt handler—and what is the handler
          for interrupt 0x80? None other
          than the system call handler!</p>
<p>The application tells the kernel which system call to execute
          and with what parameters via <emphasis>machine registers</emphasis>.
          System calls are denoted by number, starting at 0. On the i386
          architecture, to request system call 5 (which happens to be open( )), the user-space application
          stuffs 5 in register eax before issuing the int instruction.</p>
<p>Parameter passing is handled in a similar manner. On i386, for
          example, a register is used for each possible parameter—registers
          ebx, ecx, edx, esi, and edi contain, in order, the first five
          parameters. In the rare event of a system call with more than five
          parameters, a single register is used to point to a buffer in user
          space where all of the parameters are kept. Of course, most system
          calls have only a couple of parameters.</p>
<p>Other architectures handle system call invocation differently,
          although the spirit is the same. As a system programmer, you usually
          do not need any knowledge of how the kernel handles system call
          invocation. That knowledge is encoded into the standard calling
          conventions for the architecture, and handled automatically by the
          compiler and the C library.</p>
<empty-line/>
<p><strong>The C Library</strong></p>
<p>The C library (<emphasis>libc</emphasis>) is at the heart of
        Unix applications. Even when you're programming in another language,
        the C library is most likely in play, wrapped by the higher-level
        libraries, providing core services, and facilitating system call
        invocation. On modern Linux systems, the C library is provided by
        <emphasis>GNU libc</emphasis>, abbreviated <emphasis>glibc</emphasis>,
        and pronounced <emphasis>gee-lib-see</emphasis> or, less commonly,
        <emphasis>glib-see</emphasis>.</p>
<p>The GNU C library provides more than its name suggests. In
        addition to implementing the standard C library,
        <emphasis>glibc</emphasis> provides wrappers for system calls,
        threading support, and basic application facilities.</p>
<empty-line/>
<p><strong>The C Compiler</strong></p>
<p>In Linux, the standard C compiler is provided by the
        <emphasis>GNU Compiler Collection</emphasis>
        (<emphasis>gcc</emphasis>). Originally, <emphasis>gcc</emphasis> was
        GNU's version of <emphasis>cc</emphasis>, the C Compiler. Thus,
        <emphasis>gcc</emphasis> stood for <emphasis>GNU C
        Compiler</emphasis>. Over time, support was added for more and more
        languages. Consequently, nowadays <emphasis>gcc</emphasis> is used as
        the generic name for the family of GNU compilers. However,
        <emphasis>gcc</emphasis> is also the binary used to invoke the C
        compiler. In this book, when I talk of <emphasis>gcc</emphasis>, I
        typically mean the program <emphasis>gcc</emphasis>, unless context
        suggests otherwise.</p>
<p>The compiler used in a Unix system—Linux included—is highly
        relevant to system programming, as the compiler helps implement the C
        standard (see "C Language Standards") and the
        system ABI (see "APIs and ABIs"), both later in
        this chapter.</p>
<empty-line/>
<p><strong>APIs and ABIs</strong></p>
<p>Programmers are naturally interested in ensuring their programs
      run on all of the systems that they have promised to support, now and in
      the future. They want to feel secure that programs they write on their
      Linux distributions will run on other Linux distributions, as well as on
      other supported Linux architectures and newer (or earlier) Linux
      versions.</p>
<p>At the system level, there are two separate sets of definitions
      and descriptions that impact portability. One is the
      <emphasis>application programming interface</emphasis> (API), and the
      other is the <emphasis>application binary interface</emphasis> (ABI).
      Both define and describe the interfaces between different pieces of
      computer software.</p>
<empty-line/>
<p><strong>APIs</strong></p>
<p>An API defines the interfaces by which one piece of software
        communicates with another at the source level. It provides abstraction
        by providing a standard set of interfaces—usually functions—that one
        piece of software (typically, although not necessarily, a higher-level
        piece) can invoke from another piece of software (usually a
        lower-level piece). For example, an API might abstract the concept of
        drawing text on the screen through a family of functions that provide
        everything needed to draw the text. The API merely defines the
        interface; the piece of software that actually provides the API is
        known as the <emphasis>implementation</emphasis> of the API.</p>
<p>It is common to call an API a "contract." This is not correct,
        at least in the legal sense of the term, as an API is not a two-way
        agreement. The API user (generally, the higher-level software) has
        zero input into the API and its implementation. It may use the API
        as-is, or not use it at all: take it or leave it! The API acts only to
        ensure that if both pieces of software follow the API, they are
        <emphasis>source compatible</emphasis>; that is, that the user of the
        API will successfully compile against the implementation of the
        API.</p>
<p>A real-world example is the API defined by the C standard and
        implemented by the standard C library. This API defines a family of
        basic and essential functions, such as string-manipulation
        routines.</p>
<p>Throughout this book, we will rely on the existence of various
        APIs, such as the standard I/O library discussed in Chapter 3. The most important APIs in Linux
        system programming are discussed in the section "Standards" later in this chapter.</p>
<empty-line/>
<p><strong>ABIs</strong></p>
<p>Whereas an API defines a source interface, an ABI defines the
        low-level binary interface between two or more pieces of software on a
        particular architecture. It defines how an application interacts with
        itself, how an application interacts with the kernel, and how an
        application interacts with libraries. An ABI ensures <emphasis>binary
        compatibility</emphasis>, guaranteeing that a piece of object code
        will function on any system with the same ABI, without requiring
        recompilation.</p>
<p>ABIs are concerned with issues such as calling conventions, byte
        ordering, register use, system call invocation, linking, library
        behavior, and the binary object format. The calling convention, for
        example, defines how functions are invoked, how arguments are passed
        to functions, which registers are preserved and which are mangled, and
        how the caller retrieves the return value.</p>
<p>Although several attempts have been made at defining a single
        ABI for a given architecture across multiple operating systems
        (particularly for i386 on Unix systems), the efforts have not met with
        much success. Instead, operating systems—Linux included—tend to define
        their own ABIs however they see fit. The ABI is intimately tied to the
        architecture; the vast majority of an ABI speaks of machine-specific
        concepts, such as particular registers or assembly instructions. Thus,
        each machine architecture has its own ABI on Linux. In fact, we tend
        to call a particular ABI by its machine name, such as
        <emphasis>alpha</emphasis>, or <emphasis>x86-64</emphasis>.</p>
<p>System programmers ought to be aware of the ABI,but usually do
        not need to memorize it. The ABI is enforced by the
        <emphasis>toolchain</emphasis>—the compiler, the linker, and so on—and
        does not typically otherwise surface. Knowledge of the ABI, however,
        can lead to more optimal programming, and is required if writing
        assembly code or hacking on the toolchain itself (which is, after all,
        system programming).</p>
<p>The ABI for a given architecture on Linux is available on the
        Internet and implemented by that architecture's toolchain and
        kernel.</p>
<empty-line/>
<p><strong>Standards</strong></p>
<p>Unix system programming is an old art. The basics of Unix
      programming have existed untouched for decades. Unix systems, however,
      are dynamic beasts. Behavior changes and features are added. To help
      bring order to chaos, standards groups codify system interfaces into
      official standards. Numerous such standards exist, but technically
      speaking, Linux does not officially comply with any of them. Instead,
      Linux <emphasis>aims</emphasis> toward compliance with two of the most
      important and prevalent standards: POSIX and the Single UNIX
      Specification (SUS).</p>
<p>POSIX and SUS document, among other things, the C API for a
      Unix-like operating system interface. Effectively, they define system
      programming, or at least a common subset thereof, for compliant Unix
      systems.</p>
<empty-line/>
<p><strong>POSIX and SUS History</strong></p>
<p>In the mid-1980s, the Institute of Electrical and Electronics
        Engineers (IEEE) spearheaded an effort to standardize system-level
        interfaces on Unix systems. Richard Stallman, founder of the Free
        Software movement, suggested the standard be named
        <emphasis>POSIX</emphasis> (pronounced
        <emphasis>pahz-icks</emphasis>), which now stands for
        <emphasis>Portable Operating System Interface</emphasis>.</p>
<p>The first result of this effort, issued in 1988, was IEEE Std
        1003.1-1988 (POSIX 1988, for short). In 1990, the IEEE revised the
        POSIX standard with IEEE Std 1003.1-1990 (POSIX 1990). Optional
        real-time and threading support were documented in, respectively, IEEE
        Std 1003.1b-1993 (POSIX 1993 or POSIX.1b), and IEEE Std 1003.1c-1995
        (POSIX 1995 or POSIX.1c). In 2001, the optional standards were rolled
        together with the base POSIX 1990, creating a single standard: IEEE
        Std 1003.1-2001 (POSIX 2001). The latest revision, released in April
        2004, is IEEE Std 1003.1-2004. All of the core POSIX standards are
        abbreviated POSIX.1, with the 2004 revision being the latest.</p>
<p>In the late 1980s and early 1990s, Unix system vendors were
        engaged in the "Unix Wars," with each struggling to define its Unix
        variant as <emphasis>the</emphasis> Unix operating system. Several
        major Unix vendors rallied around <emphasis>The Open Group</emphasis>,
        an industry consortium formed from the merging of the <emphasis>Open
        Software Foundation</emphasis> (OSF) and <emphasis>X/Open</emphasis>.
        The Open Group provides certification, white papers, and compliance
        testing. In the early 1990s, with the Unix Wars raging, The Open Group
        released the Single UNIX Specification. SUS rapidly grew in
        popularity, in large part due to its cost (free) versus the high cost
        of the POSIX standard. Today, SUS incorporates the latest POSIX
        standard.</p>
<p>The first SUS was published in 1994. Systems compliant with
        SUSv1 are given the mark UNIX 95. The second SUS was published in
        1997, and compliant systems are marked UNIX 98. The third and latest
        SUS, SUSv3, was published in 2002. Compliant systems are given the
        mark UNIX 03. SUSv3 revises and combines IEEE Std 1003.1-2001 and
        several other standards. Throughout this book, I will mention when
        system calls and other interfaces are standardized by POSIX. I mention
        POSIX and not SUS because the latter subsumes the former.</p>
<empty-line/>
<p><strong>C Language Standards</strong></p>
<p>Dennis Ritchie and Brian Kernighan's famed book, <emphasis>The C
        Programming Language</emphasis> (Prentice Hall), acted as the informal
        C specification for many years following its 1978 publication. This
        version of C came to be known as <emphasis>K&amp;R C</emphasis>. C was
        already rapidly replacing BASIC and other languages as the
        <emphasis>lingua franca</emphasis> of microcomputer programming.
        Therefore, to standardize the by then quite popular language, in 1983,
        the American National Standards Institute (ANSI) formed a committee to
        develop an official version of C, incorporating features and
        improvements from various vendors and the new C++ language. The
        process was long and laborious, but <emphasis>ANSI C</emphasis> was
        completed in 1989. In 1990, the International Organization for
        Standardization (ISO) ratified <emphasis>ISO C90</emphasis>, based on
        ANSI C with a small handful of modifications.</p>
<p>In 1995, the ISO released an updated (although rarely
        implemented) version of the C language, <emphasis>ISO C95</emphasis>.
        This was followed in 1999 with a large update to the language,
        <emphasis>ISO C99</emphasis>, that introduced many new features,
        including inline functions, new data types, variable-length arrays,
        C++-style comments, and new library functions.</p>
<empty-line/>
<p><strong>Linux and the Standards</strong></p>
<p>As stated earlier, Linux aims toward POSIX and SUS compliance.
        It provides the interfaces documented in SUSv3 and POSIX.1, including
        the optional real-time (POSIX.1b) and optional threading (POSIX.1c)
        support. More importantly, Linux tries to provide behavior in line
        with POSIX and SUS requirements. In general, failing to agree with the
        standards is considered a bug. Linux is believed to comply with
        POSIX.1 and SUSv3, but as no official POSIX or SUS certification has
        been performed (particularly on each and every revision of Linux), I
        cannot say that Linux is officially POSIX- or SUS-compliant.</p>
<p>With respect to language standards, Linux fares well. The
        <emphasis>gcc</emphasis> C compiler supports ISO C99. In addition,
        <emphasis>gcc</emphasis> provides many of its own extensions to the C
        language. These extensions are collectively called <emphasis>GNU
        C</emphasis>, and are documented in the Appendix.</p>
<p>Linux has not had a great history of forward
        compatibility,<sup>[1]</sup> although these days it fares much better. Interfaces
        documented by standards, such as the standard C library, will
        obviously always remain source compatible. Binary compatibility is
        maintained across a given major version of <emphasis>glibc</emphasis>,
        at the very least. And as C is standardized, <emphasis>gcc</emphasis>
        will always compile legal C correctly, although
        <emphasis>gcc</emphasis>-specific extensions may be deprecated and
        eventually removed with new <emphasis>gcc</emphasis> releases. Most
        importantly, the Linux kernel guarantees the stability of system
        calls. Once a system call is implemented in a stable version of the
        Linux kernel, it is set in stone.</p>
<p>Among the various Linux distributions, the <emphasis>Linux
        Standard Base</emphasis> (LSB) standardizes much of the Linux system.
        The LSB is a joint project of several Linux vendors under the auspices
        of the <emphasis>Linux Foundation</emphasis> (formerly the
        <emphasis>Free Standards Group</emphasis>). The LSB extends POSIX and
        SUS, and adds several standards of its own; it attempts to provide a
        binary standard, allowing object code to run unmodified on compliant
        systems. Most Linux vendors comply with the LSB to some
        degree.</p>
<empty-line/>
<p><strong>This Book and the Standards</strong></p>
<p>This book deliberately avoids paying lip service to any of the
        standards. Far too frequently, Unix system programming books must stop
        to elaborate on how an interface behaves in one standard versus
        another, whether a given system call is implemented on this system
        versus that, and similar page-filling bloat. This book, however, is
        specifically about system programming on a modern Linux system, as
        provided by the latest versions of the Linux kernel (2.6),
        <emphasis>gcc</emphasis> C compiler (4.2), and C library
        (2.5).</p>
<p>As system interfaces are generally set in stone—the Linux kernel
        developers go to great pains to never break the system call
        interfaces, for example—and provide some level of both source and
        binary compatibility, this approach allows us to dive into the details
        of Linux's system interface unfettered by concerns of compatibility
        with numerous other Unix systems and standards. This focus on Linux
        also enables this book to offer in-depth treatment of cutting-edge
        Linux-specific interfaces that will remain relevant and valid far into
        the future. The book draws upon an intimate knowledge of Linux, and
        particularly of the implementation and behavior of components such as
        <emphasis>gcc</emphasis> and the kernel, to provide an insider's view,
        full of the best practices and optimization tips of an experienced
        veteran.</p>
<empty-line/>
<p><strong>Concepts of Linux Programming</strong></p>
<p>This section presents a concise overview of the services provided
      by a Linux system. All Unix systems, Linux included, provide a mutual
      set of abstractions and interfaces. Indeed, this commonality
      <emphasis>defines</emphasis> Unix. Abstractions such as the file and the
      process, interfaces to manage pipes and sockets, and so on, are at the
      core of what is Unix.</p>
<p>This overview assumes that you are familiar with the Linux
      environment: I presume that you can get around in a shell, use basic
      commands, and compile a simple C program. This is
      <emphasis>not</emphasis> an overview of Linux, or its programming
      environment, but rather of the "stuff" that forms the basis of Linux
      system programming.</p>
<empty-line/>
<p><strong>Files and the Filesystem</strong></p>
<p>The file is the most basic and fundamental abstraction in Linux.
        Linux follows the <emphasis>everything-is-a-file</emphasis> philosophy
        (although not as strictly as some other systems, such as
        Plan9<sup>[2]</sup>). Consequently, much interaction transpires via reading
        of and writing to files, even when the object in question is not what
        you would consider your everyday file.</p>
<p>In order to be accessed, a file must first be opened. Files can
        be opened for reading, writing, or both. An open file is referenced
        via a unique descriptor, a mapping from the metadata associated with
        the open file back to the specific file itself. Inside the Linux
        kernel, this descriptor is handled by an integer (of the C type
        int) called the <emphasis>file
        descriptor</emphasis>, abbreviated <emphasis>fd</emphasis>. File
        descriptors are shared with user space, and are used directly by user
        programs to access files. A large part of Linux system programming
        consists of opening, manipulating, closing, and otherwise using file
        descriptors.</p>
<empty-line/>
<p><strong>Regular files</strong></p>
<p>What most of us call "files" are what Linux labels
          <emphasis>regular files</emphasis>. A regular file contains bytes of
          data, organized into a linear array called a byte stream. In Linux,
          no further organization or formatting is specified for a file. The
          bytes may have any values, and they may be organized within the file
          in any way. At the system level, Linux does not enforce a structure
          upon files beyond the byte stream. Some operating systems, such as
          VMS, provide highly structured files, supporting concepts such as
          <emphasis>records</emphasis>. Linux does not.</p>
<p>Any of the bytes within a file may be read from or written to.
          These operations start at a specific byte, which is one's conceptual
          "location" within the file. This location is called the
          <emphasis>file position</emphasis> or <emphasis>file
          offset</emphasis>. The file position is an essential piece of the
          metadata that the kernel associates with each open file. When a file
          is first opened, the file position is zero. Usually, as bytes in the
          file are read from or written to, byte-by-byte, the file position
          increases in kind. The file position may also be set manually to a
          given value, even a value beyond the end of the file. Writing a byte
          to a file position beyond the end of the file will cause the
          intervening bytes to be padded with zeros. While it is possible to
          write bytes in this manner to a position beyond the end of the file,
          it is not possible to write bytes to a position before the beginning
          of a file. Such a practice sounds nonsensical, and, indeed, would
          have little use. The file position starts at zero; it cannot be
          negative. Writing a byte to the middle of a file overwrites the byte
          previously located at that offset. Thus, it is not possible to
          expand a file by writing into the middle of it. Most file writing
          occurs at the end of the file. The file position's maximum value is
          bounded only by the size of the C type used to store it, which is
          64-bits in contemporary Linux.</p>
<p>The size of a file is measured in bytes, and is called its
          <emphasis>length</emphasis>. The length, in other words, is simply
          the number of bytes in the linear array that make up the file. A
          file's length can be changed via an operation called
          <emphasis>truncation</emphasis>. A file can be truncated to a new
          size smaller than its original size, which results in bytes being
          removed from the end of the file. Confusingly, given the operation's
          name, a file can also be "truncated" to a new size larger than its
          original size. In that case, the new bytes (which are added to the
          end of the file) are filled with zeros. A file may be empty (have a
          length of zero), and thus contain no valid bytes. The maximum file
          length, as with the maximum file position, is bounded only by limits
          on the sizes of the C types that the Linux kernel uses to manage
          files. Specific filesystems, however, may impose their own
          restrictions, bringing the maximum length down to a smaller
          value.</p>
<p>A single file can be opened more than once, by a different or
          even the same process. Each open instance of a file is given a
          unique file descriptor; processes can share their file descriptors,
          allowing a single descriptor to be used by more than one process.
          The kernel does not impose any restrictions on concurrent file
          access. Multiple processes are free to read from and write to the
          same file at the same time. The results of such concurrent accesses
          rely on the ordering of the individual operations, and are generally
          unpredictable. User-space programs typically must coordinate amongst
          themselves to ensure that concurrent file accesses are sufficiently
          synchronized.</p>
<p>Although files are usually accessed via
          <emphasis>filenames</emphasis>, they actually are not directly
          associated with such names. Instead, a file is referenced by an
          <emphasis>inode</emphasis> (originally <emphasis>information
          node</emphasis>), which is assigned a unique numerical value. This
          value is called the <emphasis>inode number</emphasis>, often
          abbreviated as <emphasis>i-number</emphasis> or
          <emphasis>ino</emphasis>. An inode stores metadata associated with a
          file, such as its modification timestamp, owner, type, length, and
          the location of the file's data—but no filename! The inode is both a
          physical object, located on disk in Unix-style filesystems, and a
          conceptual entity, represented by a data structure in the Linux
          kernel.</p>
<empty-line/>
<p><strong>Directories and links</strong></p>
<p>Accessing a file via its inode number is cumbersome (and also
          a potential security hole), so files are always opened from user
          space by a name, not an inode number.
          <emphasis>Directories</emphasis> are used to provide the names with
          which to access files. A directory acts as a mapping of
          human-readable names to inode numbers. A name and inode pair is
          called a <emphasis>link</emphasis>. The physical on-disk form of
          this mapping—a simple table, a hash, or whatever—is implemented and
          managed by the kernel code that supports a given filesystem.
          Conceptually, a directory is viewed like any normal file, with the
          difference that it contains only a mapping of names to inodes. The
          kernel directly uses this mapping to perform name-to-inode
          resolutions.</p>
<p>When a user-space application requests that a given filename
          be opened, the kernel opens the directory containing the filename
          and searches for the given name. From the filename, the kernel
          obtains the inode number. From the inode number, the inode is found.
          The inode contains metadata associated with the file, including the
          on-disk location of the file's data.</p>
<p>Initially, there is only one directory on the disk, the
          <emphasis>root directory</emphasis>. This directory is usually
          denoted by the path <emphasis>/</emphasis>. But, as we all know,
          there are typically many directories on a system. How does the
          kernel know <emphasis>which</emphasis> directory to look in to find
          a given filename?</p>
<p>As mentioned previously, directories are much like regular
          files. Indeed, they even have associated inodes. Consequently, the
          links inside of directories can point to the inodes of other
          directories. This means directories can nest inside of other
          directories, forming a hierarchy of directories. This, in turn,
          allows for the use of the <emphasis>pathnames</emphasis> with which
          all Unix users are familiar—for example,
          <emphasis>/home/blackbeard/landscaping.txt</emphasis>.</p>
<p>When the kernel is asked to open a pathname like this, it
          walks each <emphasis>directory entry</emphasis> (called a
          <emphasis>dentry</emphasis> inside of the kernel) in the pathname to
          find the inode of the next entry. In the preceding example, the
          kernel starts at <emphasis>/</emphasis>, gets the inode for
          <emphasis>home</emphasis>, goes there, gets the inode for
          <emphasis>blackbeard</emphasis>, runs there, and finally gets the
          inode for <emphasis>landscaping.txt</emphasis>. This operation is
          called <emphasis>directory</emphasis> or <emphasis>pathname
          resolution</emphasis>. The Linux kernel also employs a cache, called
          the <emphasis>dentry cache</emphasis>, to store the results of
          directory resolutions, providing for speedier lookups in the future
          given temporal locality.<sup>[3]</sup></p>
<p>A pathname that starts at the root directory is said to be
          <emphasis>fully qualified</emphasis>, and is called an
          <emphasis>absolute pathname</emphasis>. Some pathnames are not fully
          qualified; instead, they are provided relative to some other
          directory (for example, <emphasis>todo/plunder</emphasis>). These
          paths are called <emphasis>relative pathnames</emphasis>. When
          provided with a relative pathname, the kernel begins the pathname
          resolution in the <emphasis>current working directory</emphasis>.
          From the current working directory, the kernel looks up the
          directory <emphasis>todo</emphasis>. From there, the kernel gets the
          inode for <emphasis>plunder</emphasis>.</p>
<p>Although directories are treated like normal files, the kernel
          does not allow them to be opened and manipulated like regular files.
          Instead, they must be manipulated using a special set of system
          calls. These system calls allow for the adding and removing of
          links, which are the only two sensible operations anyhow. If user
          space were allowed to manipulate directories without the kernel's
          mediation, it would be too easy for a single simple error to wreck
          the filesystem.</p>
<empty-line/>
<p><strong>Hard links</strong></p>
<p>Conceptually, nothing covered thus far would prevent multiple
          names resolving to the same inode. Indeed, this is allowed. When
          multiple links map different names to the same inode, we call them
          <emphasis>hard links</emphasis>.</p>
<p>Hard links allow for complex filesystem structures with
          multiple pathnames pointing to the same data. The hard links can be
          in the same directory, or in two or more different directories. In
          either case, the kernel simply resolves the pathname to the correct
          inode. For example, a specific inode that points to a specific chunk
          of data can be hard linked from
          <emphasis>/home/bluebeard/map.txt</emphasis> and
          <emphasis>/home/blackbeard/treasure.txt</emphasis>.</p>
<p>Deleting a file involves <emphasis>unlinking</emphasis> it
          from the directory structure, which is done simply by removing its
          name and inode pair from a directory. Because Linux supports hard
          links, however, the filesystem cannot destroy the inode and its
          associated data on every unlink operation. What if another hard link
          existed elsewhere in the filesystem? To ensure that a file is not
          destroyed until <emphasis>all</emphasis> links to it are removed,
          each inode contains a <emphasis>link count</emphasis> that keeps
          track of the number of links within the filesystem that point to it.
          When a pathname is unlinked, the link count is decremented by one;
          only when it reaches zero are the inode and its associated data
          actually removed from the filesystem.</p>
<empty-line/>
<p><strong>Symbolic links</strong></p>
<p>Hard links cannot span filesystems because an inode number is
          meaningless outside of the inode's own filesystem. To allow links
          that can span filesystems, and that are a bit simpler and less
          transparent, Unix systems also implement <emphasis>symbolic
          links</emphasis> (often shortened to
          <emphasis>symlinks</emphasis>).</p>
<p>Symbolic links look like regular files. A symlink has its own
          inode and data chunk, which contains the complete pathname of the
          linked-to file. This means symbolic links can point anywhere,
          including to files and directories that reside on different
          filesystems, and even to files and directories that do not exist. A
          symbolic link that points to a nonexistent file is called a
          <emphasis>broken link</emphasis>.</p>
<p>Symbolic links incur more overhead than hard links because
          resolving a symbolic link effectively involves resolving two files:
          the symbolic link, and then the linked-to file. Hard links do not
          incur this additional overhead—there is no difference between
          accessing a file linked into the filesystem more than once, and one
          linked only once. The overhead of symbolic links is minimal, but it
          is still considered a negative.</p>
<p>Symbolic links are also less transparent than hard links.
          Using hard links is entirely transparent; in fact, it takes effort
          to find out that a file is linked more than once! Manipulating
          symbolic links, on the other hand, requires special system calls.
          This lack of transparency is often considered a positive, with
          symbolic links acting more as <emphasis>shortcuts</emphasis> than as
          filesystem-internal links.</p>
<empty-line/>
<p><strong>Special files</strong></p>
<p><emphasis>Special files</emphasis> are kernel objects that are
          represented as files. Over the years, Unix systems have supported a
          handful of different special files. Linux supports four: block
          device files, character device files, named pipes, and Unix domain
          sockets. Special files are a way to let certain abstractions fit
          into the filesystem, partaking in the everything-is-a-file paradigm.
          Linux provides a system call to create a special file.</p>
<p>Device access in Unix systems is performed via device files,
          which act and look like normal files residing on the filesystem.
          Device files may be opened, read from, and written to, allowing user
          space to access and manipulate devices (both physical and virtual)
          on the system. Unix devices are generally broken into two groups:
          <emphasis>character devices</emphasis> and <emphasis>block
          devices</emphasis>. Each type of device has its own special device
          file.</p>
<p>A character device is accessed as a linear queue of bytes. The
          device driver places bytes onto the queue, one by one, and user
          space reads the bytes in the order that they were placed on the
          queue. A keyboard is an example of a character device. If the user
          types "peg," for example, an application would want to read from the
          keyboard device the <emphasis>p</emphasis>, the
          <emphasis>e</emphasis>, and, finally, the <emphasis>g</emphasis>.
          When there are no more characters left to read, the device returns
          end-of-file (EOF). Missing a character, or reading them in any other
          order, would make little sense. Character devices are accessed via
          <emphasis>character device files</emphasis>.</p>
<p>A block device, in contrast, is accessed as an array of bytes.
          The device driver maps the bytes over a seekable device, and user
          space is free to access any valid bytes in the array, in any
          order—it might read byte 12, then byte 7, and then byte 12 again.
          Block devices are generally storage devices. Hard disks, floppy
          drives, CD-ROM drives, and flash memory are all examples of block
          devices. They are accessed via <emphasis>block device
          files</emphasis>.</p>
<p><emphasis>Named pipes</emphasis> (often called
          <emphasis>FIFOs</emphasis>, short for "first in, first out") are an
          <emphasis>interprocess communication</emphasis> (IPC) mechanism that
          provides a communication channel over a file descriptor, accessed
          via a special file. Regular pipes are the method used to "pipe" the
          output of one program into the input of another; they are created in
          memory via a system call, and do not exist on any filesystem. Named
          pipes act like regular pipes, but are accessed via a file, called a
          <emphasis>FIFO special file</emphasis>. Unrelated processes can
          access this file and communicate.</p>
<p><emphasis>Sockets</emphasis> are the final type of special
          file. Sockets are an advanced form of IPC that allow for
          communication between two different processes, not only on the same
          machine, but on two different machines. In fact, sockets form the
          basis of network and Internet programming. They come in multiple
          varieties, including the Unix domain socket, which is the form of
          socket used for communication within the local machine. Whereas
          sockets communicating over the Internet might use a hostname and
          port pair for identifying the target of communication, Unix domain
          sockets use a special file residing on a filesystem, often simply
          called a socket file.</p>
<empty-line/>
<p><strong>Filesystems and namespaces</strong></p>
<p>Linux, like all Unix systems, provides a global and unified
          <emphasis>namespace</emphasis> of files and directories. Some
          operating systems separate different disks and drives into separate
          namespaces—for example, a file on a floppy disk might be accessible
          via the pathname <emphasis>A:\plank.jpg</emphasis>, while the hard
          drive is located at <emphasis>C:\</emphasis>. In Unix, that same
          file on a floppy might be accessible via the pathname
          <emphasis>/media/floppy/plank.jpg</emphasis>, or even via
          <emphasis>/home/captain/stuff/plank.jpg</emphasis>, right alongside
          files from other media. That is, on Unix, the namespace is
          unified.</p>
<p>A <emphasis>filesystem</emphasis> is a collection of files and
          directories in a formal and valid hierarchy. Filesystems may be
          individually added to and removed from the global namespace of files
          and directories. These operations are called
          <emphasis>mounting</emphasis> and <emphasis>unmounting</emphasis>.
          Each filesystem is mounted to a specific location in the namespace,
          known as a <emphasis>mount point</emphasis>. The root directory of
          the filesystem is then accessible at this mount point. For example,
          a CD might be mounted at <emphasis>/media/cdrom</emphasis>, making
          the root of the filesystem on the CD accessible at that mount point.
          The first filesystem mounted is located in the root of the
          namespace, <emphasis>/</emphasis>, and is called the <emphasis>root
          filesystem</emphasis>. Linux systems always have a root filesystem.
          Mounting other filesystems at other mount points is
          optional.</p>
<p>Filesystems usually exist physically (i.e., are stored on
          disk), although Linux also supports <emphasis>virtual
          filesystems</emphasis> that exist only in memory, and
          <emphasis>network filesystems</emphasis> that exist on machines
          across the network. Physical filesystems reside on block storage
          devices, such as CDs, floppy disks, compact flash cards, or hard
          drives. Some such devices are <emphasis>partionable</emphasis>,
          which means that they can be divided up into multiple filesystems,
          all of which can be manipulated individually. Linux supports a wide
          range of filesystems—certainly anything that the average user might
          hope to come across—including media-specific filesystems (for
          example, ISO9660), network filesystems (<emphasis>NFS</emphasis>),
          native filesystems (<emphasis>ext3</emphasis>), filesystems from
          other Unix systems (<emphasis>XFS</emphasis>), and even filesystems
          from non-Unix systems (<emphasis>FAT</emphasis>).</p>
<p>The smallest addressable unit on a block device is the
          <emphasis>sector</emphasis>. The sector is a physical quality of the
          device. Sectors come in various powers of two, with 512 bytes being
          quite common. A block device cannot transfer or access a unit of
          data smaller than a sector; all I/O occurs in terms of one or more
          sectors.</p>
<p>Likewise, the smallest logically addressable unit on a
          filesystem is the <emphasis>block</emphasis>. The block is an
          abstraction of the filesystem, not of the physical media on which
          the filesystem resides. A block is usually a power-of-two multiple
          of the sector size. Blocks are generally larger than the sector, but
          they must be smaller than the <emphasis>page
          size</emphasis><sup>[4]</sup> (the smallest unit addressable by the <emphasis>memory
          management unit</emphasis>, a hardware component). Common block
          sizes are 512 bytes, 1 kilobyte, and 4 kilobytes.</p>
<p>Historically, Unix systems have only a single shared
          namespace, viewable by all users and all processes on the system.
          Linux takes an innovative approach, and supports
          <emphasis>per-process namespaces</emphasis>, allowing each process
          to optionally have a unique view of the system's file and directory
          hierarchy.<sup>[5]</sup> By default, each process inherits the namespace of its
          parent, but a process may elect to create its own namespace with its
          own set of mount points, and a unique root directory.</p>
<empty-line/>
<p><strong>Processes</strong></p>
<p>If files are the most fundamental abstraction in a Unix system,
        processes are the second most fundamental. Processes are object code
        in execution: active, alive, running programs. But they're more than
        just object code—processes consist of data, resources, state, and a
        virtualized computer.</p>
<p>Processes begin life as executable object code, which is
        machine-runnable code in an executable format that the kernel
        understands (the format most common in Linux is ELF). The executable
        format contains metadata, and multiple <emphasis>sections</emphasis>
        of code and data. Sections are linear chunks of the object code that
        load into linear chunks of memory. All bytes in a section are treated
        the same, given the same permissions, and generally used for similar
        purposes.</p>
<p>The most important and common sections are the <emphasis>text
        section</emphasis>, the <emphasis>data section</emphasis>, and the
        <emphasis>bss section</emphasis>. The text section contains executable
        code and read-only data, such as constant variables, and is typically
        marked read-only and executable. The data section contains initialized
        data, such as C variables with defined values, and is typically marked
        readable and writable. The bss section contains uninitialized global
        data. Because the C standard dictates default values for C variables
        that are essentially all zeros, there is no need to store the zeros in
        the object code on disk. Instead, the object code can simply list the
        uninitialized variables in the bss section, and the kernel can map the
        <emphasis>zero page</emphasis> (a page of all zeros) over the section
        when it is loaded into memory. The bss section was conceived solely as
        an optimization for this purpose. The name is a historic relic; it
        stands for <emphasis>block started by symbol</emphasis>, or
        <emphasis>block storage segment</emphasis>. Other common sections in
        ELF executables are the <emphasis>absolute section</emphasis> (which
        contains nonrelocatable symbols) and the <emphasis>undefined
        section</emphasis> (a catchall).</p>
<p>A process is also associated with various system resources,
        which are arbitrated and managed by the kernel. Processes typically
        request and manipulate resources only through system calls. Resources
        include timers, pending signals, open files, network connections,
        hardware, and IPC mechanisms. A process' resources, along with data
        and statistics related to the process, are stored inside the kernel in
        the process' <emphasis>process descriptor</emphasis>.</p>
<p>A process is a virtualization abstraction. The Linux kernel,
        supporting both preemptive multitasking and virtual memory, provides a
        process both a virtualized processor, and a virtualized view of
        memory. From the process' perspective, the view of the system is as
        though it alone were in control. That is, even though a given process
        may be scheduled alongside many other processes, it runs as though it
        has sole control of the system. The kernel seamlessly and
        transparently preempts and reschedules processes, sharing the system's
        processors among all running processes. Processes never know the
        difference. Similarly, each process is afforded a single linear
        address space, as if it alone were in control of all of the memory in
        the system. Through virtual memory and paging, the kernel allows many
        processes to coexist on the system, each operating in a different
        address space. The kernel manages this virtualization through hardware
        support provided by modern processors, allowing the operating system
        to concurrently manage the state of multiple independent
        processes.</p>
<empty-line/>
<p><strong>Threads</strong></p>
<p>Each process consists of one or more <emphasis>threads of
          execution</emphasis> (usually just called
          <emphasis>threads</emphasis>). A thread is the unit of activity
          within a process, the abstraction responsible for executing code,
          and maintaining the process' running state.</p>
<p>Most processes consist of only a single thread; they are
          called <emphasis>single-threaded</emphasis>. Processes that contain
          multiple threads are said to be <emphasis>multithreaded</emphasis>.
          Traditionally, Unix programs have been single-threaded, owing to
          Unix's historic simplicity, fast process creation times, and robust
          IPC mechanisms, all of which mitigate the desire for threads.</p>
<p>A thread consists of a <emphasis>stack</emphasis> (which
          stores its local variables, just as the process stack does on
          nonthreaded systems), processor state, and a current location in the
          object code (usually stored in the processor's <emphasis>instruction
          pointer</emphasis>). The majority of the remaining parts of a
          process are shared among all threads.</p>
<p>Internally, the Linux kernel implements a unique view of
          threads: they are simply normal processes that happen to share some
          resources (most notably, an address space). In user space, Linux
          implements threads in accordance with POSIX 1003.1c (known as
          <emphasis>pthreads</emphasis>). The name of the current Linux thread
          implementation, which is part of <emphasis>glibc</emphasis>, is the
          <emphasis>Native POSIX Threading Library</emphasis> (NPTL).</p>
<empty-line/>
<p><strong>Process hierarchy</strong></p>
<p>Each process is identified by a unique positive integer called
          the <emphasis>process ID</emphasis> (pid). The pid of the first
          process is 1, and each subsequent process receives a new, unique
          pid.</p>
<p>In Linux, processes form a strict hierarchy, known as the
          <emphasis>process tree</emphasis>. The process tree is rooted at the
          first process, known as the <emphasis>init process</emphasis>, which
          is typically the <emphasis>init</emphasis>(8) program. New processes
          are created via the fork( )
          system call. This system call creates a duplicate of the calling
          process. The original process is called the
          <emphasis>parent</emphasis>; the new process is called the
          <emphasis>child</emphasis>. Every process except the first has a
          parent. If a parent process terminates before its child, the kernel
          will <emphasis>reparent</emphasis> the child to the init
          process.</p>
<p>When a process terminates, it is not immediately removed from
          the system. Instead, the kernel keeps parts of the process resident
          in memory, to allow the process' parent to inquire about its status
          upon terminating. This is known as <emphasis>waiting on</emphasis>
          the terminated process. Once the parent process has waited on its
          terminated child, the child is fully destroyed. A process that has
          terminated, but not yet been waited upon, is called a
          <emphasis>zombie</emphasis>. The init process routinely waits on all
          of its children, ensuring that reparented processes do not remain
          zombies forever.</p>
<empty-line/>
<p><strong>Users and Groups</strong></p>
<p>Authorization in Linux is provided by <emphasis>users</emphasis>
        and <emphasis>groups</emphasis>. Each user is associated with a unique
        positive integer called the <emphasis>user ID</emphasis> (uid). Each
        process is in turn associated with exactly one uid, which identifies
        the user running the process, and is called the process'
        <emphasis>real uid</emphasis>. Inside the Linux kernel, the uid is the
        only concept of a user. Users themselves, however, refer to themselves
        and other users through <emphasis>usernames</emphasis>, not numerical
        values. Usernames and their corresponding uids are stored in
        <emphasis>/etc/passwd</emphasis>, and library routines map
        user-supplied usernames to the corresponding uids.</p>
<p>During login, the user provides a username and password to the
        <emphasis>login</emphasis>(1) program. If given a valid username and
        the correct password, the <emphasis>login</emphasis>(1) program spawns
        the user's <emphasis>login shell</emphasis>, which is also specified
        in <emphasis>/etc/passwd</emphasis>, and makes the shell's uid equal
        to that of the user. Child processes inherit the uids of their
        parents.</p>
<p>The uid 0 is associated with a special user known as
        <emphasis>root</emphasis>. The root user has special privileges, and
        can do almost anything on the system. For example, only the root user
        can change a process' uid. Consequently, the
        <emphasis>login</emphasis>(1) program runs as root.</p>
<p>In addition to the real uid, each process also has an
        <emphasis>effective uid</emphasis>, a <emphasis>saved uid</emphasis>,
        and a <emphasis>filesystem uid</emphasis>. While the real uid is
        always that of the user who started the process, the effective uid may
        change under various rules to allow a process to execute with the
        rights of different users. The saved uid stores the original effective
        uid; its value is used in deciding what effective uid values the user
        may switch to. The filesystem uid, which is usually equal to the
        effective uid, is used for verifying filesystem access.</p>
<p>Each user may belong to one or more groups, including a
        <emphasis>primary</emphasis> or <emphasis>login group</emphasis>,
        listed in <emphasis>/etc/passwd</emphasis>, and possibly a number of
        <emphasis>supplemental groups</emphasis>, listed in
        <emphasis>/etc/group</emphasis>. Each process is therefore also
        associated with a corresponding <emphasis>group ID</emphasis> (gid),
        and has a <emphasis>real gid</emphasis>, an <emphasis>effective
        gid</emphasis>, a <emphasis>saved gid</emphasis>, and a
        <emphasis>filesystem gid</emphasis>. Processes are generally
        associated with a user's login group, not any of the supplemental
        groups.</p>
<p>Certain security checks allow processes to perform certain
        operations only if they meet specific criteria. Historically, Unix has
        made this decision very black-and-white: processes with uid 0 had
        access, while no others did. Recently, Linux has replaced this
        security system with a more general <emphasis>capabilities</emphasis>
        system. Instead of a simple binary check, capabilities allow the
        kernel to base access on much more fine-grained settings.</p>
<empty-line/>
<p><strong>Permissions</strong></p>
<p>The standard file permission and security mechanism in Linux is
        the same as that in historic Unix.</p>
<p>Each file is associated with an owning user, an owning group,
        and a set of permission bits. The bits describe the ability of the
        owning user, the owning group, and everybody else to read, write, and
        execute the file; there are three bits for each of the three classes,
        making nine bits in total. The owners and the permissions are stored
        in the file's inode.</p>
<p>For regular files, the permissions are rather obvious: they
        specify the ability to open a file for reading, open a file for
        writing, or execute a file. Read and write permissions are the same
        for special files as for regular files, although what exactly is read
        or written is up to the special file in question. Execute permissions
        are ignored on special files. For directories, read permission allows
        the contents of the directory to be listed, write permission allows
        new links to be added inside the directory, and execute permission
        allows the directory to be entered and used in a pathname. Table 1-1 lists each of the nine
        permission bits, their octal values (a popular way of representing the
        nine bits), their text values (as <emphasis>ls</emphasis> might show
        them), and their corresponding meanings.</p>
<p><emphasis>Table 1-1. Permission bits and their values</emphasis></p>
<p><strong>Bit</strong></p>
<p><strong>Octal
                value</strong></p>
<p><strong>Text
                value</strong></p>
<p><strong>Corresponding
                permission</strong></p>
<p>8</p>
<p>400</p>
<p>r--------</p>
<p>Owner may
                read</p>
<p>7</p>
<p>200</p>
<p>-w-------</p>
<p>Owner may
                write</p>
<p>6</p>
<p>100</p>
<p>--x------</p>
<p>Owner may
                execute</p>
<p>5</p>
<p>040</p>
<p>---r-----</p>
<p>Group may
                read</p>
<p>4</p>
<p>020</p>
<p>----w----</p>
<p>Group may
                write</p>
<p>3</p>
<p>010</p>
<p>-----x---</p>
<p>Group may
                execute</p>
<p>2</p>
<p>004</p>
<p>------r--</p>
<p>Everyone else may
                read</p>
<p>1</p>
<p>002</p>
<p>-------w-</p>
<p>Everyone else may
                write</p>
<p>0</p>
<p>001</p>
<p>--------x</p>
<p>Everyone else may
                execute</p>
<p>In addition to historic Unix permissions, Linux also supports
        access control lists (ACLs). ACLs allow for much more detailed and
        exacting permission and security controls, at the cost of increased
        complexity and on-disk storage.</p>
<empty-line/>
<p><strong>Signals</strong></p>
<p><emphasis>Signals</emphasis> are a mechanism for one-way
        asynchronous notifications. A signal may be sent from the kernel to a
        process, from a process to another process, or from a process to
        itself. Signals typically alert a process to some event, such as a
        segmentation fault, or the user pressing Ctrl-C.</p>
<p>The Linux kernel implements about 30 signals (the exact number
        is architecture-dependent). Each signal is represented by a numeric
        constant and a textual name. For example, SIGHUP, used to signal that a terminal
        hangup has occurred, has a value of 1 on the i386 architecture.</p>
<p>With the exception of SIGKILL
        (which always terminates the process), and SIGSTOP (which always stops the process),
        processes may control what happens when they receive a signal. They
        can accept the default action, which may be to terminate the process,
        terminate and coredump the process, stop the process, or do nothing,
        depending on the signal. Alternatively, processes can elect to
        explicitly ignore or handle signals. Ignored signals are silently
        dropped. Handled signals cause the execution of a user-supplied
        <emphasis>signal handler</emphasis> function. The program jumps to
        this function as soon as the signal is received, and (when the signal
        handler returns) the control of the program resumes at the previously
        interrupted instruction.</p>
<empty-line/>
<p><strong>Interprocess Communication</strong></p>
<p>Allowing processes to exchange information and notify each other
        of events is one of an operating system's most important jobs. The
        Linux kernel implements most of the historic Unix IPC
        mechanisms—including those defined and standardized by both System V
        and POSIX—as well as implementing a mechanism or two of its
        own.</p>
<p>IPC mechanisms supported by Linux include pipes, named pipes,
        semaphores, message queues, shared memory, and futexes.</p>
<empty-line/>
<p><strong>Headers</strong></p>
<p>Linux system programming revolves around a handful of headers.
        Both the kernel itself and <emphasis>glibc</emphasis> provide the
        headers used in system-level programming. These headers include the
        standard C fare (for example, &lt;string.h&gt;), and the usual Unix
        offerings (say, &lt;unistd.h&gt;).</p>
<empty-line/>
<p><strong>Error Handling</strong></p>
<p>It goes without saying that checking for and handling errors are
        of paramount importance. In system programming, an error is signified
        via a function's return value, and described via a special variable,
        errno. <emphasis>glibc</emphasis>
        transparently provides errno
        support for both library and system calls. The vast majority of
        interfaces covered in this book will use this mechanism to communicate
        errors.</p>
<p>Functions notify the caller of errors via a special return
        value, which is usually −1 (the
        exact value used depends on the function). The error value alerts the
        caller to the occurrence of an error, but provides no insight into why
        the error occurred. The errno
        variable is used to find the cause of the error.</p>
<p>This variable is defined in &lt;errno.h&gt; as follows:extern int errno;</p>
<p>Its value is valid only immediately after an errno-setting function indicates an error
        (usually by returning −1), as it is
        legal for the variable to be modified during the successful execution
        of a function.</p>
<p>The errno variable may be
        read or written directly; it is a modifiable lvalue. The value of
        errno maps to the textual
        description of a specific error. A preprocessor #define also maps to the numeric errno value. For example, the preprocessor
        define EACCESS equals 1, and represents "permission denied." See
        Table 1-2 for a listing of the
        standard defines and the matching error descriptions.</p>
<p><emphasis>Table 1-2. Errors and their descriptions</emphasis></p>
<p><strong>Preprocessor
                define</strong></p>
<p><strong>Description</strong></p>
<p>E2BIG</p>
<p>Argument list too
                long</p>
<p>EACCESS</p>
<p>Permission
                denied</p>
<p>EAGAIN</p>
<p>Try
                again</p>
<p>EBADF</p>
<p>Bad file
                number</p>
<p>EBUSY</p>
<p>Device or resource
                busy</p>
<p>ECHILD</p>
<p>No child
                processes</p>
<p>EDOM</p>
<p>Math argument outside
                of domain of function</p>
<p>EEXIST</p>
<p>File already
                exists</p>
<p>EFAULT</p>
<p>Bad
                address</p>
<p>EFBIG</p>
<p>File too
                large</p>
<p>EINTR</p>
<p>System call was
                interrupted</p>
<p>EINVAL</p>
<p>Invalid
                argument</p>
<p>EIO</p>
<p>I/O
                error</p>
<p>EISDIR</p>
<p>Is a
                directory</p>
<p>EMFILE</p>
<p>Too many open
                files</p>
<p>EMLINK</p>
<p>Too many
                links</p>
<p>ENFILE</p>
<p>File table
                overflow</p>
<p>ENODEV</p>
<p>No such
                device</p>
<p>ENOENT</p>
<p>No such file or
                directory</p>
<p>ENOEXEC</p>
<p>Exec format
                error</p>
<p>ENOMEM</p>
<p>Out of
                memory</p>
<p>ENOSPC</p>
<p>No space left on
                device</p>
<p>ENOTDIR</p>
<p>Not a
                directory</p>
<p>ENOTTY</p>
<p>Inappropriate I/O
                control operation</p>
<p>ENXIO</p>
<p>No such device or
                address</p>
<p>EPERM</p>
<p>Operation not
                permitted</p>
<p>EPIPE</p>
<p>Broken
                pipe</p>
<p>ERANGE</p>
<p>Result too
                large</p>
<p>EROFS</p>
<p>Read-only
                filesystem</p>
<p>ESPIPE</p>
<p>Invalid
                seek</p>
<p>ESRCH</p>
<p>No such
                process</p>
<p>ETXTBSY</p>
<p>Text file
                busy</p>
<p>EXDEV</p>
<p>Improper
                link</p>
<p>The C library provides a handful of functions for translating an
        errno value to the corresponding
        textual representation. This is needed only for error reporting, and
        the like; checking and handling errors can be done using the
        preprocessor defines and errno
        directly.</p>
<p>The first such function is perror(
        ):<strong>#include &lt;stdio.h&gt;

void perror (const char *str);</strong></p>
<p>This function prints to <emphasis>stderr</emphasis> (standard
        error) the string representation of the current error described by
        errno, prefixed by the string
        pointed at by str, followed by a
        colon. To be useful, the name of the function that failed should be
        included in the string. For example:if (close (fd) == −1)
        perror ("close");</p>
<p>The C library also provides strerror(
        ) and strerror_r( ),
        prototyped as:<strong>#include &lt;string.h&gt;

char * strerror (int errnum);</strong></p>
<p>and:<strong>#include &lt;string.h&gt;

int strerror_r (int errnum, char *buf, size_t len);</strong></p>
<p>The former function returns a pointer to a string describing the
        error given by errnum. The string
        may not be modified by the application, but can be modified by
        subsequent perror( ) and strerror( ) calls. In this manner, it is not
        thread-safe.</p>
<p>The strerror_r( ) function is
        thread-safe. It fills the buffer of length len pointed at by buf. A call to strerror_r( ) returns 0 on success, and −1 on failure. Humorously, it sets errno on error.</p>
<p>For a few functions, the entire range of the return type is a
        legal return value. In those cases, errno must be zeroed before invocation, and
        checked afterward (these functions promise to only return a nonzero
        errno on actual error). For
        example:errno = 0;
arg = strtoul (buf, NULL, 0);
if (errno)
        perror ("strtoul");</p>
<p>A common mistake in checking errno is to forget that any library or
        system call can modify it. For example, this code is buggy:if (fsync (fd) == −1) {
        fprintf (stderr, "fsync failed!\n");
        if (errno == EIO)
                fprintf (stderr, "I/O error on %d!\n", fd);
}</p>
<p>If you need to preserve the value of errno across function invocations, save
        it:if (fsync (fd) == −1) {
        int err = errno;
        fprintf (stderr, "fsync failed: %s\n", strerror (errno));
        if (err == EIO) {
                /* if the error is I/O-related, jump ship */
                fprintf (stderr, "I/O error on %d!\n", fd);
                exit (EXIT_FAILURE);
        }
}</p>
<p>In single-threaded programs, errno is a global variable, as shown earlier
        in this section. In multithreaded programs, however, errno is stored per-thread, and is thus
        thread-safe.</p>
<empty-line/>
<p><strong>Getting Started with System Programming</strong></p>
<p>This chapter looked at the fundamentals of Linux system
      programming and provided a programmer's overview of the Linux system.
      The next chapter discusses basic file I/O. This includes, of course,
      reading from and writing to files; however, because Linux implements
      many interfaces as files, file I/O is crucial to a lot more than just,
      well, files.</p>
<p>With the preliminaries behind us, growing smaller on the horizon,
      it's time to dive into actual system programming. Let's go!</p>
<empty-line/><empty-line/>
<p><sup>[1] </sup><sup>*</sup> Experienced Linux users might
            remember the switch from <emphasis>a.out</emphasis> to ELF, the
            switch from <emphasis>libc5</emphasis> to
            <emphasis>glibc</emphasis>, <emphasis>gcc</emphasis> changes, and
            so on. Thankfully, those days are behind us.</p>
<p><sup>[2] </sup><sup>*</sup> Plan9, an operating system born
            of Bell Labs, is often called the successor to Unix. It features
            several innovative ideas, and is an adherent of the
            everything-is-a-file philosophy.</p>
<p><sup>[3] </sup><sup>*</sup> <emphasis>Temporal
              locality</emphasis> is the high likelihood of an access to a
              particular resource being followed by another access to the same
              resource. Many resources on a computer exhibit temporal
              locality.</p>
<p><sup>[4] </sup><sup>*</sup> This is an artificial kernel
              limitation, in the name of simplicity, that may go away in the
              future.</p>
<p><sup>[5] </sup><sup>†</sup> This approach was first
              pioneered by Bell Labs' Plan9.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 2. File I/O</strong></p>
<p>This chapter covers the basics of reading to and writing from files.
    Such operations form the core of a Unix system. The next chapter covers
    standard I/O from the standard C library, and Chapter 4 continues the coverage with a
    treatment of the more advanced and specialized file I/O interfaces. Chapter 7 rounds out the discussion by
    addressing the topic of file and directory manipulation.</p>
<p>Before a file can be read from or written to, it must be opened. The
    kernel maintains a per-process list of open files, called the
    <emphasis>file table</emphasis>. This table is indexed via nonnegative
    integers known as <emphasis>file descriptors</emphasis> (often abbreviated
    <emphasis>fds</emphasis>). Each entry in the list contains information
    about an open file, including a pointer to an in-memory copy of the file's
    backing inode and associated metadata, such as the file position and
    access modes. Both user space and kernel space use file descriptors as
    unique per-process cookies. Opening a file returns a file descriptor,
    while subsequent operations (reading, writing, and so on) take the file
    descriptor as their primary argument.</p>
<p>By default, a child process receives a copy of its parent's file
    table. The list of open files and their access modes, current file
    positions, and so on, are the same, but a change in one process—say, the
    child closing a file—does not affect the other process' file table.
    However, as you'll see in Chapter 5, it is
    possible for the child and parent to share the parent's file table (as
    threads do).</p>
<p>File descriptors are represented by the C int type. Not using a special type—an fd_t, say—is often considered odd, but is,
    historically, the Unix way. Each Linux process has a maximum number of
    files that it may open. File descriptors start at 0, and go up to one less
    than this maximum value. By default, the maximum is 1,024, but it can be
    configured as high as 1,048,576. Because negative values are not legal
    file descriptors, −1 is often used to
    indicate an error from a function that would otherwise return a valid file
    descriptor.</p>
<p>Unless the process explicitly closes them, every process by
    convention has at least three file descriptors open: 0, 1, and 2. File
    descriptor 0 is <emphasis>standard in</emphasis>
    (<emphasis>stdin</emphasis>), file descriptor 1 is <emphasis>standard
    out</emphasis> (<emphasis>stdout</emphasis>), and file descriptor 2 is
    <emphasis>standard error</emphasis> (<emphasis>stderr</emphasis>). Instead
    of referencing these integers directly, the C library provides the
    preprocessor defines STDIN_FILENO,
    STDOUT_FILENO, and STDERR_FILENO.</p>
<p>Note that file descriptors can reference more than just regular
    files. They are used for accessing device files and pipes, directories and
    futexes, FIFOs, and sockets—following the everything-is-a-file philosophy,
    just about anything you can read or write is accessible via a file
    descriptor.</p>
<empty-line/>
<p><strong>Opening Files</strong></p>
<p>The most basic method of accessing a file is via the read( ) and write(
      ) system calls. Before a file can be accessed, however, it
      must be opened via an open( ) or
      creat( ) system call. Once done using
      the file, it should be closed using the system call close( ).</p>
<empty-line/>
<p><strong>The open( ) System Call</strong></p>
<p>A file is opened, and a file descriptor is obtained with the
        open( ) system call:<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open (const char *name, int flags);
int open (const char *name, int flags, mode_t mode);</strong></p>
<p>The open( ) system call maps
        the file given by the pathname name
        to a file descriptor, which it returns on success. The file position
        is set to zero, and the file is opened for access according to the
        flags given by flags.</p>
<empty-line/>
<p><strong>Flags for open( )</strong></p>
<p>The flags argument must be
          one of O_RDONLY, O_WRONLY, or O_RDWR. Respectively, these arguments
          request that the file be opened only for reading, only for writing,
          or for both reading and writing.</p>
<p>For example, the following code opens
          <emphasis>/home/kidd/madagascar</emphasis> for reading:int fd;

fd = open ("/home/kidd/madagascar", O_RDONLY);
if (fd == −1)
        /* error */</p>
<p>A file opened only for writing <emphasis>cannot</emphasis>
          also be read, and vice versa. The process issuing the open( ) system call must have sufficient
          permissions to obtain the access requested.</p>
<p>The flags argument can be
          bitwise-ORed with one or more of the following values, modifying the
          behavior of the open request:</p>
<p>O_APPEND</p>
<p>The file will be opened in <emphasis>append
                mode</emphasis>. That is, before each write, the file position
                will be updated to point to the end of the file. This occurs
                even if another process has written to the file after the
                issuing process' last write, thereby changing the file
                position. (See "Append Mode" later in this
                chapter).O_ASYNC</p>
<p>A signal (SIGIO by
                default) will be generated when the specified file becomes
                readable or writable. This flag is available only for
                terminals and sockets, not for regular files.O_CREAT</p>
<p>If the file denoted by name does not exist, the kernel will
                create it. If the file already exists, this flag has no effect
                unless O_EXCL is also
                given.O_DIRECT</p>
<p>The file will be opened for direct I/O (see "Direct I/O" later in this
                chapter).O_DIRECTORY</p>
<p>If name is not a
                directory, the call to open(
                ) will fail. This flag is used internally by the
                opendir( ) library
                call.O_EXCL</p>
<p>When given with O_CREAT, this flag will cause the
                call to open( ) to fail if
                the file given by name
                already exists. This is used to prevent race conditions on
                file creation.O_LARGEFILE</p>
<p>The given file will be opened using 64-bit offsets,
                allowing files larger than two gigabytes to be opened. This is
                implied on 64-bit architectures.O_NOCTTY</p>
<p>If the given name
                refers to a terminal device (say,
                <emphasis>/dev/tty</emphasis>), it will not become the
                process' controlling terminal, even if the process does not
                currently have a controlling terminal. This flag is not
                frequently used.O_NOFOLLOW</p>
<p>If name is a symbolic
                link, the call to open( )
                will fail. Normally, the link is resolved, and the target file
                is opened. If other components in the given path are links,
                the call will still succeed. For example, if name is
                <emphasis>/etc/ship/plank.txt</emphasis>, the call will fail
                if <emphasis>plank.txt</emphasis> is a symbolic link. It will
                succeed, however, if <emphasis>etc</emphasis> or
                <emphasis>ship</emphasis> is a symbolic link, so long as
                <emphasis>plank.txt</emphasis> is not.O_NONBLOCK</p>
<p>If possible, the file will be opened in nonblocking
                mode. Neither the open( )
                call, nor any other operation will cause the process to block
                (sleep) on the I/O. This behavior may be defined only for
                FIFOs.O_SYNC</p>
<p>The file will be opened for synchronous I/O. No write
                operation will complete until the data has been physically
                written to disk; normal read operations are already
                synchronous, so this flag has no effect on reads. POSIX
                additionally defines O_DSYNC and O_RSYNC; on Linux, these flags are
                synonymous with O_SYNC.
                (See "The O_SYNC Flag," later in this
                chapter.)O_TRUNC</p>
<p>If the file exists, it is a regular file, and the given
                flags allow for writing, the file will be truncated to zero
                length. Use of O_TRUNC on a
                FIFO or terminal device is ignored. Use on other file types is
                undefined. Specifying O_TRUNC with O_RDONLY is also undefined, as you
                need write access to the file in order to truncate it.</p>
<p>For example, the following code opens for writing the file
          <emphasis>/home/teach/pearl</emphasis>. If the file already exists,
          it will be truncated to a length of zero. Because the O_CREAT flag is not specified, if the file
          does not exist, the call will fail:int fd;

fd = open ("/home/teach/pearl", O_WRONLY | O_TRUNC);
if (fd == −1)
        /* error */</p>
<empty-line/>
<p><strong>Owners of New Files</strong></p>
<p>Determining which user owns a new file is straightforward: the
        uid of the file's owner is the effective uid of the process creating
        the file.</p>
<p>Determining the owning group is more complicated. The default
        behavior is to set the file's group to the effective gid of the
        process creating the file. This is the System V behavior (the
        behavioral model for much of Linux), and the standard Linux
        <emphasis>modus operandi</emphasis>.</p>
<p>To be difficult, however, BSD defined its own behavior: the
        file's group is set to the gid of the parent directory. This behavior
        is available on Linux via a mount-time option<sup>[6]</sup>—it is also the behavior that will occur on Linux by
        default if the file's parent directory has the set group ID (setgid)
        bit set. Although most Linux systems will use the System V behavior
        (where new files receive the gid of the creating process), the
        possibility of the BSD behavior (where new files receive the gid of
        the parent directory) implies that code that truly cares needs to
        manually set the group via the chown(
        ) system call (see Chapter 7).</p>
<p>Thankfully, caring about the owning group of a file is
        uncommon.</p>
<empty-line/>
<p><strong>Permissions of New Files</strong></p>
<p>Both of the previously given forms of the open( ) system call are valid. The mode argument is ignored unless a file is
        created; it is required if O_CREAT
        is given. If you forget to provide the mode argument when using O_CREAT, the results are undefined, and
        often quite ugly—so don't forget!</p>
<p>When a file is created, the mode argument provides the permissions of
        the newly created file. The mode is not checked on this particular
        open of the file, so you can perform contradictory operations, such as
        opening the file for writing, but assigning the file read-only
        permissions.</p>
<p>The mode argument is the
        familiar Unix permission bitset, such as octal 0644 (owner can read
        and write, everyone else can only read). Technically speaking, POSIX
        allowed the exact values to be implementation-specific, allowing
        different Unix systems to lay out the permission bits however they
        desired. To compensate for the nonportability of bit positions in the
        mode, POSIX introduced the following set of constants that may be
        binary-ORed together, and supplied for the mode argument:</p>
<p>S_IRWXU</p>
<p>Owner has read, write, and execute permission.S_IRUSR</p>
<p>Owner has read permission.S_IWUSR</p>
<p>Owner has write permission.S_IXUSR</p>
<p>Owner has execute permission.S_IRWXG</p>
<p>Group has read, write, and execute permission.S_IRGRP</p>
<p>Group has read permission.S_IWGRP</p>
<p>Group has write permission.S_IXGRP</p>
<p>Group has execute permission.S_IRWXO</p>
<p>Everyone else has read, write, and execute
              permission.S_IROTH</p>
<p>Everyone else has read permission.S_IWOTH</p>
<p>Everyone else has write permission.S_IXOTH</p>
<p>Everyone else has execute permission.</p>
<p>The actual permission bits that hit the disk are determined by
        binary-ANDing the mode argument
        with the complement of the user's <emphasis>file creation
        mask</emphasis> (<emphasis>umask</emphasis>). Informally, the bits in
        the umask are turned <emphasis>off</emphasis> in the mode argument given to open( ). Thus, the usual umask of 022 would
        cause a mode argument of 0666 to
        become 0644 (0666 &amp; ∼022). As a system programmer, you normally do
        not take into consideration the umask when setting permissions—the
        umask exists to allow the user to limit the permissions that his
        programs set on new files.</p>
<p>As an example, the following code opens the file given by
        file for writing. If the file does
        not exist, assuming a umask of 022, it is created with the permissions
        0644 (even though the mode argument
        specifies 0664). If it does exist, it is truncated to zero
        length:int fd;

fd = open (file, O_WRONLY | O_CREAT | O_TRUNC,
           S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH);
if (fd == −1)
        /* error */</p>
<empty-line/>
<p><strong>The creat( ) Function</strong></p>
<p>The combination of O_WRONLY | O_CREAT |
        O_TRUNC is so common that a system call exists to provide
        just that behavior:<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int creat (const char *name, mode_t mode);</strong></p>
<p><strong>Tip</strong></p>
<p>Yes, this function's name is missing an
          <emphasis>e</emphasis>. Ken Thompson, the creator of Unix, once
          joked that the missing letter was his largest regret in the design
          of Unix.</p>
<p>The following typical creat(
        ) call:int fd;

fd = creat (file, 0644);
if (fd == −1)
        /* error */</p>
<p>is identical to:int fd;

fd = open (file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
if (fd == −1)
        /* error */</p>
<p>On most Linux architectures,<sup>[7]</sup> creat( ) is a system
        call, even though it can be implemented in user space as
        simply:int creat (const char *name, int mode)
{
        return open (name, O_WRONLY | O_CREAT | O_TRUNC, mode);
}</p>
<p>This duplication is a historic relic from when open( ) had only two arguments. Today, the
        creat( ) system call remains around
        for compatibility. New architectures can implement creat( ) as shown in
        <emphasis>glibc</emphasis>.</p>
<empty-line/>
<p><strong>Return Values and Error Codes</strong></p>
<p>Both open( ) and creat( ) return a file descriptor on
        success. On error, both return −1,
        and set errno to an appropriate
        error value (Chapter 1
        discussed errno and listed the
        potential error values). Handling an error on file open is not
        complicated, as generally there will have been few or no steps
        performed prior to the open that need to be undone. A typical response
        would be prompting the user for a different filename or simply
        terminating the program.</p>
<empty-line/>
<p><strong>Reading via read( )</strong></p>
<p>Now that you know how to open a file, let's look at how to read
      it. In the following section, we will examine writing.</p>
<p>The most basic—and common—mechanism used for reading is the
      read( ) system call, defined in
      POSIX.1:<strong>#include &lt;unistd.h&gt;

ssize_t read (int fd, void *buf, size_t len);</strong></p>
<p>Each call reads up to len bytes
      into buf from the current file offset
      of the file referenced by fd. On
      success, the number of bytes written into buf is returned. On error, the call returns
      −1, and errno is set. The file position is advanced by
      the number of bytes read from fd. If
      the object represented by fd is not
      capable of seeking (for example, a character device file), the read
      always occurs from the "current" position.</p>
<p>Basic usage is simple. This example reads from the file descriptor
      fd into word. The number of bytes read is equal to the
      size of the unsigned long type, which
      is four bytes on 32-bit Linux systems, and eight bytes on 64-bit
      systems. On return, nr contains the
      number of bytes read, or −1 on
      error:unsigned long word;
ssize_t nr;

/* read a couple bytes into 'word' from 'fd' */
nr = read (fd, &amp;word, sizeof (unsigned long));
if (nr == −1)
        /* error */</p>
<p>There are two problems with this naïve implementation: the call
      might return without reading all len
      bytes, and it could produce certain errors that this code does not check
      for and handle. Code such as this, unfortunately, is very common. Let's
      see how to improve it.</p>
<empty-line/>
<p><strong>Return Values</strong></p>
<p>It is legal for read( ) to
        return a positive nonzero value less than len. This can happen for a number of
        reasons: less than len bytes may
        have been available, the system call may have been interrupted by a
        signal, the pipe may have broken (if fd is a pipe), and so on.</p>
<p>The possibility of a return value of 0 is another consideration when using
        read( ). The read( ) system call returns 0 to indicate
        <emphasis>end-of-file</emphasis> (EOF); in this case, of course, no
        bytes were read. EOF is not considered an error (and hence is not
        accompanied by a −1 return value);
        it simply indicates that the file position has advanced past the last
        valid offset in the file, and thus there is nothing else to read. If,
        however, a call is made for len
        bytes, but no bytes are available for reading, the call will
        <emphasis>block</emphasis> (sleep) until the bytes become available
        (assuming the file descriptor was not opened in nonblocking mode; see
        "Nonblocking Reads"). Note that this is different
        from returning EOF. That is, there is a difference between "no data
        available" and "end of data." In the EOF case, the end of the file was
        reached. In the case of blocking, the read is waiting for more
        data—say, in the case of reading from a socket or a device
        file.</p>
<p>Some errors are recoverable. For example, if a call to read( ) is interrupted by a signal before
        any bytes are read, it returns −1
        (a 0 could be confused with EOF),
        and errno is set to EINTR. In that case, you can resubmit the
        read.</p>
<p>Indeed, a call to read( ) can
        result in many possibilities:</p>
<p>The call returns a value equal to len. All len read bytes are stored in buf. The results are as intended.</p>
<p>The call returns a value less than len, but greater than zero. The read
            bytes are stored in buf. This
            can occur because a signal interrupted the read midway, an error
            occurred in the middle of the read, more than zero, but less than
            len bytes' worth of data was
            available, or EOF was reached before len bytes were read. Reissuing the read
            (with correspondingly updated buf and len values) will read the remaining
            bytes into the rest of the buffer, or indicate the cause of the
            problem.</p>
<p>The call returns 0. This
            indicates EOF. There is nothing to read.</p>
<p>The call blocks because no data is currently available. This
            won't happen in nonblocking mode.</p>
<p>The call returns −1, and
            errno is set to EINTR. This indicates that a signal was
            received before any bytes were read. The call can be
            reissued.</p>
<p>The call returns −1, and
            errno is set to EAGAIN. This indicates that the read
            would block because no data is currently available, and that the
            request should be reissued later. This happens only in nonblocking
            mode.</p>
<p>The call returns −1, and
            errno is set to a value other
            than EINTR or EAGAIN. This indicates a more serious
            error.</p>
<empty-line/>
<p><strong>Reading All the Bytes</strong></p>
<p>These possibilities imply that the previous trivial, simplistic
        use of read( ) is not suitable if
        you want to handle all errors, and actually read all len bytes (at least up to an EOF). To do
        that, you need a loop, and a handful of conditional
        statements:ssize_t ret;

while (len != 0 &amp;&amp; (ret = read (fd, buf, len)) != 0) {
        if (ret == −1) {
                if (errno == EINTR)
                        continue;
                perror ("read");
                break;
        }

        len -= ret;
        buf += ret;
}</p>
<p>This snippet handles all five conditions. The loop reads
        len bytes from the current file
        position of fd into buf. It continues reading until it reads all
        len bytes, or until EOF is reached.
        If more than zero, but less than len bytes are read, len is reduced by the amount read, buf is increased by the amount read, and the
        call is reissued. If the call returns −1, and errno equals EINTR, the call is reissued without updating
        the parameters. If the call returns −1, and errno is set to anything else, perror( ) is called to print a description
        to standard error and the loop terminates.</p>
<p>Partial reads are not only legal, but also common. Innumerable
        bugs derive from programmers not properly checking for and handling
        short read requests. Do not add to the list!</p>
<empty-line/>
<p><strong>Nonblocking Reads</strong></p>
<p>Sometimes, programmers do not want a call to read( ) to block when there is no data
        available. Instead, they prefer that the call return immediately,
        indicating that no data is available. This is called
        <emphasis>nonblocking I/O</emphasis>; it allows applications to
        perform I/O, potentially on multiple files, without ever blocking, and
        thus missing data available in another file.</p>
<p>Consequently, an additional errno value is worth checking: EAGAIN. As discussed previously, if the
        given file descriptor was opened in nonblocking mode (if O_NONBLOCK was given to open( ); see "Flags for open( )") and there is no
        data to read, the read( ) call will
        return −1, and set errno to EAGAIN instead of blocking. When performing
        nonblocking reads, you must check for EAGAIN, or risk confusing a serious error
        with the mere lack of data. For example, you might use code like the
        following:char buf[BUFSIZ];
ssize_t nr;

start:
nr = read (fd, buf, BUFSIZ);
if (nr == −1) {
        if (errno == EINTR)
                goto start; /* oh shush */
        if (errno == EAGAIN)
                /* resubmit later */
        else
                /* error */
}</p>
<p><strong>Tip</strong></p>
<p>Handling EAGAIN in this
          example with a goto start would
          actually make little sense—you might as well not use nonblocking
          I/O. Using it ends up saving no time, and instead introduces more
          overhead by looping over and over.</p>
<empty-line/>
<p><strong>Other Error Values</strong></p>
<p>The other error codes refer to programming errors or (for
        EIO) low-level problems. Possible
        errno values after a failure on
        read( ) include:</p>
<p>EBADF</p>
<p>The given file descriptor is invalid, or not open for
              reading.EFAULT</p>
<p>The pointer provided by buf is not inside the calling process'
              address space.EINVAL</p>
<p>The file descriptor is mapped to an object that does not
              allow reading.EIO</p>
<p>A low-level I/O error occurred.</p>
<empty-line/>
<p><strong>Size Limits on read( )</strong></p>
<p>The size_t and ssize_t types are mandated by POSIX. The
        size_t type is used for storing
        values used to measure size in bytes. The ssize_t type is a signed version of size_t (the negative values are used to
        connote errors). On 32-bit systems, the backing C types are usually
        unsigned int and int, respectively. Because the two types are
        often used together, the potentially smaller range of ssize_t places a limit on the range of
        size_t.</p>
<p>The maximum value of a size_t
        is SIZE_MAX; the maximum value of
        an ssize_t is SSIZE_MAX. If len is larger than SSIZE_MAX, the results of the call to
        read( ) are undefined. On most
        Linux systems, SSIZE_MAX is
        LONG_MAX, which is
        <emphasis>0x7fffffff</emphasis> on a 32-bit machine. That is
        relatively large for a single read, but nonetheless something to keep
        in mind. If you use the previous read loop as a generic super read,
        you might want to do something like this:if (len &gt; SSIZE_MAX)
        len = SSIZE_MAX;</p>
<p>A call to read( ) with a
        len of zero results in the call
        returning immediately with a return value of 0.</p>
<empty-line/>
<p><strong>Writing with write( )</strong></p>
<p>The most basic and common system call used for writing is write( ). write(
      ) is the counterpart of read(
      ) and is also defined in POSIX.1:<strong>#include &lt;unistd.h&gt;

ssize_t write (int fd, const void *buf, size_t count);</strong></p>
<p>A call to write( ) writes up to
      count bytes starting at buf to the current file position of the file
      referenced by the file descriptor fd.
      Files backed by objects that do not support seeking (for example,
      character devices) always write starting at the "head."</p>
<p>On success, the number of bytes written is returned, and the file
      position is updated in kind. On error, −1 is returned, and errno is set appropriately. A call to write( ) can return 0, but this return value does not have any
      special meaning; it simply implies that zero bytes were written.</p>
<p>As with read( ), the most basic
      usage is simple:const char *buf = "My ship is solid!";
ssize_t nr;

/* write the string in 'buf' to 'fd' */
nr = write (fd, buf, strlen (buf));
if (nr == −1)
        /* error */</p>
<p>But again, as with read( ),
      this usage is not quite right. Callers also need to check for the
      possible occurrence of a partial write:unsigned long word = 1720;
size_t count;
ssize_t nr;

count = sizeof (word);
nr = write (fd, &amp;word, count);
if (nr == −1)
        /* error, check errno */
else if (nr != count)
        /* possible error, but 'errno' not set */</p>
<empty-line/>
<p><strong>Partial Writes</strong></p>
<p>A write( ) system call is
        less likely to return a partial write than a read( ) system call is to return a partial
        read. Also, there is no EOF condition for a write( ) system call. For regular files,
        write( ) is guaranteed to perform
        the entire requested write, unless an error occurs.</p>
<p>Consequently, for regular files, you do not need to perform
        writes in a loop. However, for other file types—say, sockets—a loop
        may be required to guarantee that you <emphasis>really</emphasis>
        write out all of the requested bytes. Another benefit of using a loop
        is that a second call to write( )
        may return an error revealing what caused the first call to perform
        only a partial write (although, again, this situation is not very
        common). Here's an example:ssize_t ret, nr;

while (len != 0 &amp;&amp; (ret = write (fd, buf, len)) != 0) {
        if (ret == −1) {
                if (errno == EINTR)
                        continue;
                perror ("write");
                break;
        }

        len -= ret;
        buf += ret;
}</p>
<empty-line/>
<p><strong>Append Mode</strong></p>
<p>When fd is opened in append
        mode (via O_APPEND), writes do not
        occur at the file descriptor's current file position. Instead, they
        occur at the current end of the file.</p>
<p>For example, assume that two processes are writing to the same
        file. Without append mode, if the first process writes to the end of
        the file, and then the second process does the same, the first
        process' file position will no longer point to the end of the file; it
        will point to the end of the file, minus the data that the second
        process just wrote. This means that multiple processes can never
        append to the same file without explicit synchronization because they
        will encounter race conditions.</p>
<p>Append mode avoids this problem. It ensures that the file
        position is always set to the end of the file, so all writes always
        append, even when there are multiple writers. You can think of it as
        an atomic update to the file position preceding each write request.
        The file position is then updated to point at the end of the newly
        written data. This will not matter to the next call to write( ), as it updates the file position
        automatically, but it might matter if you next call read( ) for some odd reason.</p>
<p>Append mode makes a lot of sense for certain tasks, such as
        updating log files, but little sense for much else.</p>
<empty-line/>
<p><strong>Nonblocking Writes</strong></p>
<p>When fd is opened in
        nonblocking mode (via O_NONBLOCK),
        and the write as issued would normally block, the write( ) system call returns −1, and errno is set to EAGAIN. The request should be reissued
        later. Generally, this does not occur with regular files.</p>
<empty-line/>
<p><strong>Other Error Codes</strong></p>
<p>Other notable errno values
        include:</p>
<p>EBADF</p>
<p>The given file descriptor is not valid, or is not open for
              writing.EFAULT</p>
<p>The pointer provided by buf points outside of the process'
              address space.EFBIG</p>
<p>The write would have made the file larger than per-process
              maximum file limits, or internal implementation limits.EINVAL</p>
<p>The given file descriptor is mapped to an object that is
              not suitable for writing.EIO</p>
<p>A low-level I/O error occurred.ENOSPC</p>
<p>The filesystem backing the given file descriptor does not
              have sufficient space.EPIPE</p>
<p>The given file descriptor is associated with a pipe or
              socket whose reading end is closed. The process will also
              receive a SIGPIPE signal. The
              default action for the SIGPIPE signal is to terminate the
              receiving process. Therefore, processes receive this errno value only if they explicitly
              ask to ignore, block, or handle this signal.</p>
<empty-line/>
<p><strong>Size Limits on write( )</strong></p>
<p>If count is larger than
        SSIZE_MAX, the results of the call
        to write( ) are
        undefined.</p>
<p>A call to write( ) with a
        count of zero results in the call
        returning immediately with a return value of 0.</p>
<empty-line/>
<p><strong>Behavior of write( )</strong></p>
<p>When a call to write( )
        returns, the kernel has copied the data from the supplied buffer into
        a kernel buffer, but there is no guarantee that the data has been
        written out to its intended destination. Indeed, write calls return
        much too fast for that to be the case. The disparity in performance
        between processors and hard disks would make such behavior painfully
        obvious.</p>
<p>Instead, when a user-space application issues a write( ) system call, the Linux kernel
        performs a few checks, and then simply copies the data into a buffer.
        Later, in the background, the kernel gathers up all of the "dirty"
        buffers, sorts them optimally, and writes them out to disk (a process
        known as <emphasis>writeback</emphasis>). This allows write calls to
        occur lightning fast, returning almost immediately. It also allows the
        kernel to defer writes to more idle periods, and batch many writes
        together.</p>
<p>The delayed writes do not change POSIX semantics. For example,
        if a read is issued for a piece of just-written data that lives in a
        buffer and is not yet on disk, the request will be satisfied from the
        buffer, and not cause a read from the "stale" data on disk. This
        behavior actually improves performance, as the read is satisfied from
        an in-memory cache without having to go to disk. The read and write
        requests interleave as intended, and the results are as expected—that
        is, if the system does not crash before the data makes it to disk!
        Even though an application may believe that a write has occurred
        successfully, in this event, the data will never make it to
        disk.</p>
<p>Another issue with delayed writes is the inability to enforce
        <emphasis>write ordering</emphasis>. Although an application may take
        care to order its write requests in such a way that they hit the disk
        in a specific order, the kernel will reorder the write requests as it
        sees fit, primarily for performance. This is normally a problem only
        if the system crashes, as eventually all of the buffers are written
        back and all is well. Even then, the vast majority of applications are
        not actually concerned with write ordering.</p>
<p>A final problem with delayed writes has to do with the reporting
        of certain I/O errors. Any I/O error that occurs during writeback—say,
        a physical drive failure—cannot be reported back to the process that
        issued the write request. Indeed, buffers are not associated with
        processes at all. Multiple processes may have dirtied the data
        contained in a single buffer, and processes may exit after writing
        data to a buffer but before that data is written back to disk.
        Besides, how would you communicate to a process that a write failed
        <emphasis>ex post facto</emphasis>?</p>
<p>The kernel does attempt to minimize the risks of deferred
        writes. To ensure that data is written out in a timely manner, the
        kernel institutes a <emphasis>maximum buffer age</emphasis>, and
        writes out all dirty buffers before they mature past the given value.
        Users can configure this value via
        <emphasis>/proc/sys/vm/dirty_expire_centiseconds</emphasis>. The value
        is specified in centiseconds (one hundredths of a second).</p>
<p>It is also possible to force the writeback of a given file's
        buffer, or even to make all writes synchronous. These topics are
        discussed in the next section, "Synchronized I/O."</p>
<p>Later in this chapter, "Kernel Internals"
        will cover the Linux kernel's buffer writeback subsystem in
        depth.</p>
<empty-line/>
<p><strong>Synchronized I/O</strong></p>
<p>Although synchronizing I/O is an important topic, the issues
      associated with delayed writes should not be feared. Buffering writes
      provides a <emphasis>huge</emphasis> performance improvement, and
      consequently, any operating system even halfway deserving the mark
      "modern" implements delayed writes via buffers. Nonetheless, there are
      times when applications want to control when data hits the disk. For
      those uses, the Linux kernel provides a handful of options that allow
      performance to be traded for synchronized operations.</p>
<empty-line/>
<p><strong>fsync( ) and fdatasync( )</strong></p>
<p>The simplest method of ensuring that data has reached the disk
        is via the fsync( ) system call,
        defined by POSIX.1b:<strong>#include &lt;unistd.h&gt;

int fsync (int fd);</strong></p>
<p>A call to fsync( ) ensures
        that all dirty data associated with the file mapped by the file
        descriptor fd is written back to
        disk. The file descriptor fd must
        be open for writing. The call writes back both data and metadata, such
        as creation timestamps, and other attributes contained in the inode.
        It will not return until the hard drive says that the data and
        metadata are on the disk.</p>
<p>In the case of write caches on hard disks, it is not possible
        for fsync( ) to know whether the
        data is physically on the disk. The hard drive can report that the
        data was written, but the data may in fact reside in the drive's write
        cache. Fortunately, data in a hard disk's cache should be committed to
        the disk in short order.</p>
<p>Linux also provides the system call fdatasync( ):<strong>#include &lt;unistd.h&gt;

int fdatasync (int fd);</strong></p>
<p>This system call does the same thing as fsync( ), except that it only flushes data.
        The call does not guarantee that metadata is synchronized to disk, and
        is therefore potentially faster. Often this is sufficient.</p>
<p>Both functions are used the same way, which is very
        simple:int ret;

ret = fsync (fd);
if (ret == −1)
        /* error */</p>
<p>Neither function guarantees that any updated directory entries
        containing the file are synchronized to disk. This implies that if a
        file's link has recently been updated, the file's data may
        successfully reach the disk, but not the associated directory entry,
        rendering the file unreachable. To ensure that any updates to the
        directory entry are also committed to disk, fsync( ) must be called on a file descriptor
        opened against the directory itself.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, both calls return 0. On failure, both calls return −1, and set errno to one of the following three
          values:</p>
<p>EBADF</p>
<p>The given file descriptor is not a valid file descriptor
                open for writing.EINVAL</p>
<p>The given file descriptor is mapped to an object that
                does not support synchronization.EIO</p>
<p>A low-level I/O error occurred during synchronization.
                This represents a real I/O error, and is often the place where
                such errors are caught.</p>
<p>Currently, a call to fsync(
          ) may fail because fsync(
          ) is not implemented by the backing filesystem, even when
          fdatasync( ) is implemented.
          Paranoid applications may want to try fdatasync( ) if fsync( ) returns EINVAL. For example:if (fsync (fd) == −1) {
        /*
         * We prefer fsync(), but let's try fdatasync(  )
         * if fsync(  ) fails, just in case.
         */
        if (errno == EINVAL) {
                if (fdatasync (fd) == −1)
                        perror ("fdatasync");
        } else
                perror ("fsync");
}</p>
<p>Because POSIX requires fsync(
          ), but labels fdatasync(
          ) as optional, the fsync(
          ) system call should always be implemented for regular
          files on any of the common Linux filesystems. Odd file types
          (perhaps those in which there is no metadata to synchronize) or
          strange filesystems may implement only fdatasync( ), however.</p>
<empty-line/>
<p><strong>sync( )</strong></p>
<p>Less optimal, but wider in scope, the old-school sync( ) system call is provided for
        synchronizing <emphasis>all</emphasis> buffers to disk:<strong>#include &lt;unistd.h&gt;

void sync (void);</strong></p>
<p>The function has no parameters, and no return value. It always
        succeeds, and upon return, all buffers—both data and metadata—are
        guaranteed to reside on disk.<sup>[8]</sup></p>
<p>The standards do not require sync(
        ) to wait until all buffers are flushed to disk before
        returning; they require only that the call initiates the process of
        committing all buffers to disk. For this reason, it is often
        recommended to synchronize multiple times to ensure that all data is
        safely on disk. Linux, however, <emphasis>does</emphasis> wait until
        all buffers are committed. Therefore, a single sync( ) is sufficient.</p>
<p>The only real use for sync( )
        is in implementing the <emphasis>sync</emphasis>(8) utility.
        Applications should use fsync( )
        and fdatasync( ) to commit to disk
        the data of just the requisite file descriptors. Note that sync( ) may take several minutes to complete
        on a busy system.</p>
<empty-line/>
<p><strong>The O_SYNC Flag</strong></p>
<p>The O_SYNC flag may be passed
        to open( ), indicating that all I/O
        on the file should be <emphasis>synchronized:</emphasis>int fd;

fd = open (file, O_WRONLY | O_SYNC);
if (fd == −1) {
        perror ("open");
        return −1;
}</p>
<p>Read requests are always synchronized. If they weren't, the
        validity of the read data in the supplied buffer would be unknown.
        However, as discussed previously, calls to write( ) are normally not synchronized.
        There is no relation between the call returning and the data being
        committed to disk. The O_SYNC flag
        forces the relationship, ensuring that calls to write( ) perform synchronized I/O.</p>
<p>One way of looking at O_SYNC
        is that it forces an implicit fsync(
        ) after each write( )
        operation, before the call returns. These are indeed the semantics
        provided, although the Linux kernel implements O_SYNC a bit more efficiently.</p>
<p>O_SYNC results in slightly
        worse <emphasis>user</emphasis> and <emphasis>kernel times</emphasis>
        (times spent in user and kernel space, respectively) for write
        operations. Moreover, depending on the size of the file being written,
        O_SYNC can cause an increase in
        total elapsed time of one or two orders of magnitude because all
        <emphasis>I/O wait time</emphasis> (time spent waiting for I/O to
        complete) is incurred by the process. The increase in cost is huge, so
        synchronized I/O should be used only after exhausting all possible
        alternatives.</p>
<p>Normally, applications which need guarantees that write
        operations have hit the disk use fsync(
        ) or fdatasync( ). These
        tend to incur less cost than O_SYNC, as they can be called less often
        (i.e., only after certain critical operations have completed).</p>
<empty-line/>
<p><strong>O_DSYNC and O_RSYNC</strong></p>
<p>POSIX defines two other synchronized-I/O-related open( ) flags: O_DSYNC and O_RSYNC. On Linux, these flags are defined
        to be synonymous with O_SYNC; they
        provide in the same behavior.</p>
<p>The O_DSYNC flag specifies
        that only normal data be synchronized after each write operation, not
        metadata. Think of it as causing an implicit fdatasync( ) after each write request.
        Because O_SYNC provides stronger
        guarantees, there is no functionality loss in not explicitly
        supporting O_DSYNC; there's only a
        potential performance loss from the stronger requirements provided by
        O_SYNC.</p>
<p>The O_RSYNC flag specifies
        the synchronization of read requests as well as write requests. It
        must be used with one of O_SYNC or
        O_DSYNC. As mentioned earlier,
        reads are already synchronized—they do not return until they have
        something to give the user, after all. The O_RSYNC flag stipulates that any side
        effects of a read operation be synchronized, too. This means that
        metadata updates resulting from a read must be written to disk before
        the call returns. In practical terms, this requirement most likely
        means only that the file access time must be updated in the on-disk
        copy of the inode before the call to read(
        ) returns. Linux defines O_RSYNC to be the same as O_SYNC, although this does not make much
        sense (the two are not as related as O_SYNC and O_DSYNC). There is currently no way in Linux
        to obtain the behavior of O_RSYNC;
        the closest a developer can come is invoking fdatasync( ) after each read( ) call. This behavior is rarely
        needed, though.</p>
<empty-line/>
<p><strong>Direct I/O</strong></p>
<p>The Linux kernel, like any modern operating system kernel,
      implements a complex layer of caching, buffering, and I/O management
      between devices and applications (see "Kernel Internals" at the end of this chapter). A
      high-performance application may wish to bypass this layer of complexity
      and perform its own I/O management. Rolling your own I/O system is
      usually not worth the effort, though, and in fact the tools available at
      the operating-system level are likely to achieve much better performance
      than those available at the application level. Still, database systems
      often prefer to perform their own caching, and want to minimize the
      presence of the operating system as much as feasible.</p>
<p>Providing the O_DIRECT flag to
      open( ) instructs the kernel to
      minimize the presence of I/O management. When this flag is provided, I/O
      will initiate directly from user-space buffers to the device, bypassing
      the page cache. All I/O will be synchronous; operations will not return
      until completed.</p>
<p>When performing direct I/O, the request length, buffer alignment,
      and file offsets must all be integer multiples of the underlying
      device's sector size—generally, this is 512 bytes. Before the 2.6 Linux
      kernel, this requirement was stricter: in 2.4, everything must be
      aligned on the filesystem's logical block size (often 4 KB). To remain
      compatible, applications should align to the larger (and potentially
      less convenient) logical block size.</p>
<empty-line/>
<p><strong>Closing Files</strong></p>
<p>After a program has finished working with a file descriptor, it
      can unmap the file descriptor from the associated file via the close( ) system call:<strong>#include &lt;unistd.h&gt;

int close (int fd);</strong></p>
<p>A call to close( ) unmaps the
      open file descriptor fd, and
      disassociates the process from the file. The given file descriptor is
      then no longer valid, and the kernel is free to reuse it as the return
      value to a subsequent open( ) or
      creat( ) call. A call to close( ) returns 0 on success. On error, it returns −1, and sets errno appropriately. Usage is simple:if (close (fd) == −1)
        perror ("close");</p>
<p>Note that closing a file has no bearing on when the file is
      flushed to disk. If an application wants to ensure that the file is
      committed to disk before closing it, it needs to make use of one of the
      synchronization options discussed earlier in "Synchronized I/O."</p>
<p>Closing a file does have some side effects, though. When the last
      open file descriptor referring to a file is closed, the data structure
      representing the file inside the kernel is freed. When this data
      structure is freed, it unpins the in-memory copy of the inode associated
      with the file. If nothing else is pinning the inode, it too may be freed
      from memory (it may stick around because the kernel caches inodes for
      performance reasons, but it need not). If a file has been unlinked from
      the disk, but was kept open before it was unlinked, it is not physically
      removed until it is closed and its inode is removed from memory.
      Therefore, calling close( ) may also
      result in an unlinked file finally being physically removed from the
      disk.</p>
<empty-line/>
<p><strong>Error Values</strong></p>
<p>It is a common mistake to not check the return value of close( ). This can result in missing a
        crucial error condition because errors associated with deferred
        operations may not manifest until later, and close( ) can report them.</p>
<p>There are a handful of possible errno values on failure. Other than EBADF (the given file descriptor was
        invalid), the most important error value is EIO, indicating a low-level I/O error
        probably unrelated to the actual close. Regardless of any reported
        error, the file descriptor, if valid, is always closed, and the
        associated data structures are freed.</p>
<p>Although POSIX allows it, close(
        ) will never return EINTR. The Linux kernel developers know
        better—such an implementation is not smart.</p>
<empty-line/>
<p><strong>Seeking with lseek( )</strong></p>
<p>Normally, I/O occurs linearly through a file, and the implicit
      updates to the file position caused by reads and writes are all the
      seeking that is needed. Some applications, however, need to jump around
      in the file. The lseek( ) system call
      is provided to set the file position of a file descriptor to a given
      value. Other than updating the file position, it performs no other
      action, and initiates no I/O whatsoever:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

off_t lseek (int fd, off_t pos, int origin);</strong></p>
<p>The behavior of lseek( )
      depends on the origin argument, which
      can be one of the following:</p>
<p>SEEK_CUR</p>
<p>The current file position of fd is set to its current value plus
            pos, which can be negative,
            zero, or positive. A pos of
            zero returns the current file position value.SEEK_END</p>
<p>The current file position of fd is set to the current length of the
            file plus pos, which can be
            negative, zero, or positive. A pos of zero sets the offset to the end
            of the file.SEEK_SET</p>
<p>The current file position of fd is set to pos. A pos of zero sets the offset to the
            beginning of the file.</p>
<p>The call returns the new file position on success. On error, it
      returns −1 and errno is set as appropriate.</p>
<p>For example, to set the file position of fd to 1825:off_t ret;

ret = lseek (fd, (off_t) 1825, SEEK_SET);
if (ret == (off_t) −1)
        /* error */</p>
<p>Alternatively, to set the file position of fd to the end of the file:off_t ret;

ret = lseek (fd, 0, SEEK_END);
if (ret == (off_t) −1)
        /* error */</p>
<p>As lseek( ) returns the updated
      file position, it can be used to find the current file position via a
      SEEK_CUR to zero:int pos;

pos = lseek (fd, 0, SEEK_CUR);
if (pos == (off_t) −1)
        /* error */
else
        /* 'pos' is the current position of fd */</p>
<p>By far, the most common uses of lseek(
      ) are seeking to the beginning, seeking to the end, or
      determining the current file position of a file descriptor.</p>
<empty-line/>
<p><strong>Seeking Past the End of a File</strong></p>
<p>It is possible to instruct lseek(
        ) to advance the file pointer past the end of a file. For
        example, this code seeks to 1,688 bytes beyond the end of the file
        mapped by fd:int ret;

ret = lseek (fd, (off_t) 1688, SEEK_END);
if (ret == (off_t) −1)
        /* error */</p>
<p>On its own, seeking past the end of a file does nothing—a read
        request to the newly created file position will return EOF. If a write
        request is subsequently made to this position, however, new space will
        be created between the old length of the file and the new length, and
        it will be padded with zeros.</p>
<p>This zero padding is called a <emphasis>hole</emphasis>. On
        Unix-style filesystems, holes do not occupy any physical disk space.
        This implies that the total size of all files on a filesystem can add
        up to more than the physical size of the disk. Files with holes are
        called <emphasis>sparse files</emphasis>. Sparse files can save
        considerable space and enhance performance because manipulating the
        holes does not initiate any physical I/O.</p>
<p>A read request to the part of a file in a hole will return the
        appropriate number of binary zeros.</p>
<empty-line/>
<p><strong>Error Values</strong></p>
<p>On error, lseek( ) returns
        −1, and errno is set to one of the following four
        values:</p>
<p>EBADF</p>
<p>The given file descriptor does not refer to an open file
              descriptor.EINVAL</p>
<p>The value given for origin is not one of SEEK_SET, SEEK_CUR, or SEEK_END, <emphasis>or</emphasis> the
              resulting file position would be negative. The fact that
              EINVAL represents both of
              these errors is unfortunate. The former is almost assuredly a
              compile-time programming error, whereas the latter can represent
              a more insidious runtime logic error.EOVERFLOW</p>
<p>The resulting file offset cannot be represented in an
              off_t. This can occur only on
              32-bit architectures. Currently, the file position
              <emphasis>is</emphasis> updated; this error indicates just that
              it is impossible to return it.ESPIPE</p>
<p>The given file descriptor is associated with an unseekable
              object, such as a pipe, FIFO, or socket.</p>
<empty-line/>
<p><strong>Limitations</strong></p>
<p>The maximum file positions are limited by the size of the
        off_t type. Most machine
        architectures define this to be the C long type, which on Linux is always the
        <emphasis>word size</emphasis> (usually the size of the machine's
        general-purpose registers). Internally, however, the kernel stores the
        offsets in the C long long type.
        This poses no problem on 64-bit machines, but it means that 32-bit
        machines can generate EOVERFLOW
        errors when performing relative seeks.</p>
<empty-line/>
<p><strong>Positional Reads and Writes</strong></p>
<p>In lieu of using lseek( ),
      Linux provides two variants of the read(
      ) and write( ) system calls
      that each take as a parameter the file position from which to read or
      write. Upon completion, they do <emphasis>not</emphasis> update the file
      position.</p>
<p>The read form is called pread(
      ):<strong>#define _XOPEN_SOURCE 500

#include &lt;unistd.h&gt;

ssize_t pread (int fd, void *buf, size_t count, off_t pos);</strong></p>
<p>This call reads up to count
      bytes into buf from the file
      descriptor fd at file position
      pos.</p>
<p>The write form is called pwrite(
      ):<strong>#define _XOPEN_SOURCE 500

#include &lt;unistd.h&gt;

ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos);</strong></p>
<p>This call writes up to count
      bytes from buf to the file descriptor
      fd at file position pos.</p>
<p>These calls are almost identical in behavior to their non-p brethren, except that they completely ignore
      the current file position; instead of using the current position, they
      use the value provided by pos. Also,
      when done, they do not update the file position. In other words, any
      intermixed read( ) and write( ) calls could potentially corrupt the
      work done by the positional calls.</p>
<p>Both positional calls can be used only on seekable file
      descriptors. They provide semantics similar to preceding a read( ) or write(
      ) call with a call to lseek(
      ), with three differences. First, these calls are easier to
      use, especially when doing a tricky operation such as moving through a
      file backward or randomly. Second, they do not update the file pointer
      upon completion. Finally, and most importantly, they avoid any potential
      races that might occur when using lseek(
      ). As threads share file descriptors, it would be possible for
      a different thread in the same program to update the file position after
      the first thread's call to lseek( ),
      but before its read or write operation executed. Such race conditions
      can be avoided by using the pread( )
      and pwrite( ) system calls.</p>
<empty-line/>
<p><strong>Error Values</strong></p>
<p>On success, both calls return the number of bytes read or
        written. A return value of 0 from
        pread( ) indicates EOF; from
        pwrite( ), a return value of
        0 indicates that the call did not
        write anything. On error, both calls return −1 and set errno appropriately. For pread( ), any valid read( ) or lseek( )
        errno value is possible. For pwrite( ), any valid write( ) or lseek(
        ) value is possible.</p>
<empty-line/>
<p><strong>Truncating Files</strong></p>
<p>Linux provides two system calls for truncating the length of a
      file, both of which are defined and required (to varying degrees) by
      various POSIX standards. They are:<strong>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int ftruncate (int fd, off_t len);</strong></p>
<p>and:<strong>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int truncate (const char *path, off_t len);</strong></p>
<p>Both system calls truncate the given file to the length given by
      len. The ftruncate( ) system call operates on the file
      descriptor given by fd, which must be
      open for writing. The truncate( )
      system call operates on the filename given by path, which must be writable. Both return
      0 on success. On error, they return
      −1, and set errno as appropriate.</p>
<p>The most common use of these system calls is to truncate a file to
      a size smaller than its current length. Upon successful return, the
      file's length is len. The data
      previously existing between len and
      the old length is discarded, and no longer accessible via a read
      request.</p>
<p>The functions can also be used to "truncate" a file to a larger
      size, similar to the seek plus write combination described earlier in
      "Seeking Past the End of a File." The extended bytes
      are filled with zeros.</p>
<p>Neither operation updates the current file position.</p>
<p>For example, consider the file <emphasis>pirate.txt</emphasis> of
      length 74 bytes with the following contents:Edward Teach was a notorious English pirate.
He was nicknamed Blackbeard.</p>
<p>From the same directory, running the following program:#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main(  )
{
        int ret;

        ret = truncate ("./pirate.txt", 45);
        if (ret == −1) {
                perror ("truncate");
                return −1;
        }

        return 0;
}</p>
<p>results in a file of length 45 bytes with the contents:Edward Teach was a notorious English pirate.</p>
<empty-line/>
<p><strong>Multiplexed I/O</strong></p>
<p>Applications often need to block on more than one file descriptor,
      juggling I/O between keyboard input (<emphasis>stdin</emphasis>),
      interprocess communication, and a handful of files. Modern event-driven
      graphical user interface (GUI) applications may contend with literally
      hundreds of pending events via their mainloops.<sup>[9]</sup></p>
<p>Without the aid of threads—essentially servicing each file
      descriptor separately—a single process cannot reasonably block on more
      than one file descriptor at the same time. Working with multiple file
      descriptors is fine, so long as they are always ready to be read from or
      written to. But as soon as one file descriptor that is not yet ready is
      encountered—say, if a read( ) system
      call is issued, and there is not yet any data—the process will block, no
      longer able to service the other file descriptors. It might block for
      just a few seconds, making the application inefficient and annoying the
      user. However, if no data becomes available on the file descriptor, it
      could block forever. Because file descriptors' I/O is often
      interrelated—think pipes—it is quite possible for one file descriptor
      not to become ready until another is serviced. Particularly with network
      applications, which may have many sockets open simultaneously, this is
      potentially quite a problem.</p>
<p>Imagine blocking on a file descriptor related to interprocess
      communication while <emphasis>stdin</emphasis> has data pending. The
      application won't know that keyboard input is pending until the blocked
      IPC file descriptor ultimately returns data—but what if the blocked
      operation never returns?</p>
<p>Earlier in this chapter, we looked at nonblocking I/O as a
      solution to this problem. With nonblocking I/O, applications can issue
      I/O requests that return a special error condition instead of blocking.
      However, this solution is inefficient, for two reasons. First, the
      process needs to continually issue I/O operations in some arbitrary
      order, waiting for one of its open file descriptors to be ready for I/O.
      This is poor program design. Second, it would be much more efficient if
      the program could sleep, freeing the processor for other tasks, to be
      woken up only when one or more file descriptors were ready to perform
      I/O.</p>
<p>Enter <emphasis>multiplexed I/O</emphasis>.</p>
<p>Multiplexed I/O allows an application to concurrently block on
      multiple file descriptors, and receive notification when any one of them
      becomes ready to read or write without blocking. Multiplexed I/O thus
      becomes the pivot point for the application, designed similarly to the
      following:</p>
<p>Multiplexed I/O: Tell me when any of these file descriptors
          are ready for I/O.</p>
<p>Sleep until one or more file descriptors are ready.</p>
<p>Woken up: What is ready?</p>
<p>Handle all file descriptors ready for I/O, without
          blocking.</p>
<p>Go back to step 1, and start over.</p>
<p>Linux provides three multiplexed I/O solutions: the
      <emphasis>select</emphasis>, <emphasis>poll</emphasis>, and
      <emphasis>epoll</emphasis> interfaces. We will cover the first two here,
      and the last, which is an advanced Linux-specific solution, in Chapter 4.</p>
<empty-line/>
<p><strong>select( )</strong></p>
<p>The select( ) system call
        provides a mechanism for implementing synchronous multiplexing
        I/O:<strong>#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select (int n,
            fd_set *readfds,
            fd_set *writefds,
            fd_set *exceptfds,
            struct timeval *timeout);

FD_CLR(int fd, fd_set *set);
FD_ISSET(int fd, fd_set *set);
FD_SET(int fd, fd_set *set);
FD_ZERO(fd_set *set);</strong></p>
<p>A call to select( ) will
        block until the given file descriptors are ready to perform I/O, or
        until an optionally specified timeout has elapsed.</p>
<p>The watched file descriptors are broken into three sets, each
        waiting for a different event. File descriptors listed in the readfds set are watched to see if data is
        available for reading (that is, if a read operation will complete
        without blocking). File descriptors listed in the writefds set are watched to see if a write
        operation will complete without blocking. Finally, file descriptors in
        the exceptfds set are watched to
        see if an exception has occurred, or if out-of-band data is available
        (these states apply only to sockets). A given set may be NULL, in which case select( ) does not watch for that
        event.</p>
<p>On successful return, each set is modified such that it contains
        only the file descriptors that are ready for I/O of the type
        delineated by that set. For example, assume two file descriptors, with
        the values 7 and 9, are placed in the readfds set. When the call returns, if 7 is
        still in the set, that file descriptor is ready to read without
        blocking. If 9 is no longer in the set, it is probably not readable
        without blocking. (I say <emphasis>probably</emphasis> here because it
        is possible that data became available after the call completed. In
        that case, a subsequent call to select(
        ) will return the file descriptor as ready to read.<sup>[10]</sup>)</p>
<p>The first parameter, n, is
        equal to the value of the highest-valued file descriptor in any set,
        plus one. Consequently, a caller to select(
        ) is responsible for checking which given file descriptor is
        the highest-valued, and passing in that value plus one for the first
        parameter.</p>
<p>The timeout parameter is a
        pointer to a timeval structure,
        which is defined as follows:<strong>#include &lt;sys/time.h&gt;

struct timeval {
        long tv_sec;         /* seconds */
        long tv_usec;        /* microseconds */
};</strong></p>
<p>If this parameter is not NULL, the call to select( ) will return after tv_sec seconds, and tv_usec microseconds, even if no file
        descriptors are ready for I/O. On return, the state of this structure
        across various Unix systems is undefined, and thus it must be
        reinitialized (along with the file descriptor sets) before every
        invocation. Indeed, current versions of Linux modify this parameter
        automatically, setting the values to the time remaining. Thus, if the
        timeout was set for 5 seconds, and 3 seconds elapsed before a file
        descriptor became ready, tv.tv_sec
        would contain 2 upon the call's
        return.</p>
<p>If both values in the timeout are set to zero, the call will
        return immediately, reporting any events that were pending at the time
        of the call, but not waiting for any subsequent events.</p>
<p>The sets of file descriptors are not manipulated directly, but
        are instead managed through helper macros. This allows Unix systems to
        implement the sets however they want. Most systems, however, implement
        the sets as simple bit arrays. FD_ZERO removes all file descriptors from
        the specified set. It should be called before every invocation of
        select( ):fd_set writefds;

FD_ZERO(&amp;writefds);</p>
<p>FD_SET adds a file descriptor
        to a given set, and FD_CLR removes
        a file descriptor from a given set:FD_SET(fd, &amp;writefds);    /* add 'fd' to the set */
FD_CLR(fd, &amp;writefds);    /* oops, remove 'fd' from the set */</p>
<p>Well-designed code should never have to make use of FD_CLR, and it is rarely, if ever,
        used.</p>
<p>FD_ISSET tests whether a file
        descriptor is part of a given set. It returns a nonzero integer if the
        file descriptor is in the set, and 0 if it is not. FD_ISSET is used after a call from select( ) returns to test whether a given
        file descriptor is ready for action:if (FD_ISSET(fd, &amp;readfds))
        /* 'fd' is readable without blocking! */</p>
<p>Because the file descriptor sets are statically created, they
        impose a limit on the maximum number of file descriptors and the
        largest-valued file descriptor that may be placed inside them, both of
        which are given by FD_SETSIZE. On
        Linux, this value is 1,024. We will look at the ramifications of this
        limit later in this chapter.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, select( )
          returns the number of file descriptors ready for I/O, among all
          three sets. If a timeout was provided, the return value may be
          0. On error, the call returns
          −1, and errno is set to one of the following
          values:</p>
<p>EBADF</p>
<p>An invalid file descriptor was provided in one of the
                sets.EINTR</p>
<p>A signal was caught while waiting, and the call can be
                reissued.EINVAL</p>
<p>The parameter n is
                negative, or the given timeout is invalid.ENOMEM</p>
<p>Insufficient memory was available to complete the
                request.</p>
<empty-line/>
<p><strong>select( ) example</strong></p>
<p>Let's consider an example program, trivial but fully
          functional, to illustrate the use of select( ). This example blocks waiting for
          input on <emphasis>stdin</emphasis> for up to 5 seconds. Because it
          watches only a single file descriptor, it is not actually
          multiplexing I/O, but the usage of the system call is made
          clear:#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define TIMEOUT 5       /* select timeout in seconds */
#define BUF_LEN 1024    /* read buffer in bytes */

int main (void)
{
        struct timeval tv;
        fd_set readfds;
        int ret;

        /* Wait on stdin for input. */
        FD_ZERO(&amp;readfds);
        FD_SET(STDIN_FILENO, &amp;readfds);

        /* Wait up to five seconds. */
        tv.tv_sec = TIMEOUT;
        tv.tv_usec = 0;

        /* All right, now block! */
        ret = select (STDIN_FILENO + 1,
                      &amp;readfds,
                      NULL,
                      NULL,
                      &amp;tv);
        if (ret == −1) {
                perror ("select");
                return 1;
        } else if (!ret) {
                printf ("%d seconds elapsed.\n", TIMEOUT);
                return 0;
        }

        /*
         * Is our file descriptor ready to read?
         * (It must be, as it was the only fd that
         * we provided and the call returned
         * nonzero, but we will humor ourselves.)
         */
        if (FD_ISSET(STDIN_FILENO, &amp;readfds)) {
                char buf[BUF_LEN+1];
                int len;

                /* guaranteed to not block */
                len = read (STDIN_FILENO, buf, BUF_LEN);
                if (len == −1) {
                        perror ("read");
                        return 1;
                }

                if (len) {
                        buf[len] = '\0';
                        printf ("read: %s\n", buf);
                }

                return 0;
        }

        fprintf (stderr, "This should not happen!\n");
        return 1;
}</p>
<empty-line/>
<p><strong>Portable sleeping with select( )</strong></p>
<p>Because select( ) has
          historically been more readily implemented on various Unix systems
          than a mechanism for subsecond-resolution sleeping, it is often
          employed as a portable way to sleep by providing a non-NULL timeout but NULL for all three sets:struct timeval tv;

tv.tv_sec = 0;
tv.tv_usec = 500;

/* sleep for 500 microseconds */
select (0, NULL, NULL, NULL, &amp;tv);</p>
<p>Linux, of course, provides interfaces for high-resolution
          sleeping. We will cover these in Chapter 10.</p>
<empty-line/>
<p><strong>pselect( )</strong></p>
<p>The select( ) system call,
          first introduced IN 4.2BSD, is popular, but POSIX defined its own
          solution, pselect( ), in POSIX
          1003.1g-2000 and later in POSIX 1003.1-2001:<strong>#define _XOPEN_SOURCE 600
#include &lt;sys/select.h&gt;

int pselect (int n,
             fd_set *readfds,
             fd_set *writefds,
             fd_set *exceptfds,
             const struct timespec *timeout,
             const sigset_t *sigmask);

FD_CLR(int fd, fd_set *set);
FD_ISSET(int fd, fd_set *set);
FD_SET(int fd, fd_set *set);
FD_ZERO(fd_set *set);</strong></p>
<p>There are three differences between pselect( ) and select( ):</p>
<p>pselect( ) uses the
              timespec structure, not the
              timeval structure, for its
              timeout parameter. The
              timespec structure uses
              seconds and nanoseconds, not seconds and microseconds, providing
              theoretically superior timeout resolution. In practice, however,
              neither call reliably provides even microsecond
              resolution.</p>
<p>A call to pselect( )
              does not modify the timeout
              parameter. Consequently, this parameter does not need to be
              reinitialized on subsequent invocations.</p>
<p>The select( ) system
              call does not have the sigmask parameter. With respect to
              signals, when this parameter is set to NULL, pselect( ) behaves like select( ).</p>
<p>The timespec structure is
          defined as follows:<strong>#include &lt;sys/time.h&gt;

struct timespec {
        long tv_sec;         /* seconds */
        long tv_nsec;        /* nanoseconds */
};</strong></p>
<p>The primary motivator behind the addition of pselect( ) to Unix's toolbox was the
          addition of the sigmask
          parameter, which attempts to solve a race condition between waiting
          on file descriptors and signals (signals are covered in depth in
          Chapter 9). Assume that a signal handler sets a
          global flag (as most do), and the process checks this flag before a
          call to select( ). Now, assume
          that the signal arrives after the check, but before the call. The
          application may block indefinitely, and never respond to the set
          flag. The pselect( ) call solves
          this problem by allowing an application to call pselect( ), providing a set of signals to
          block. Blocked signals are not handled until they are unblocked.
          Once pselect( ) returns, the
          kernel restores the old signal mask. Seriously, see Chapter 9.</p>
<p>Until the 2.6.16 kernel, the Linux implementation of pselect( ) was not a system call, but a
          simple wrapper around select( ),
          provided by <emphasis>glibc</emphasis>. This wrapper minimized—but
          did not totally eliminate—the risk of this race condition occurring.
          With the introduction of a true system call, the race is
          gone.</p>
<p>Despite the (relatively minor) improvements in pselect( ), most applications continue to
          use select( ), either out of
          habit, or in the name of greater portability.</p>
<empty-line/>
<p><strong>poll( )</strong></p>
<p>The poll( ) system call is
        System V's multiplexed I/O solution. It solves several deficiencies in
        select( ), although select( ) is still often used (again, most
        likely out of habit, or in the name of portability):<strong>#include &lt;sys/poll.h&gt;

int poll (struct pollfd *fds, unsigned int nfds, int timeout);</strong></p>
<p>Unlike select( ), with its
        inefficient three bitmask-based sets of file descriptors, poll( ) employs a single array of nfds pollfd structures, pointed to by
        fds. The structure is defined as
        follows:<strong>#include &lt;sys/poll.h&gt;

struct pollfd {
        int fd;           /* file descriptor */
        short events;     /* requested events to watch */
        short revents;    /* returned events witnessed */
};</strong></p>
<p>Each pollfd structure
        specifies a single file descriptor to watch. Multiple structures may
        be passed, instructing poll( ) to
        watch multiple file descriptors. The events field of each structure is a bitmask
        of events to watch for on that file descriptor. The user sets this
        field. The revents field is a
        bitmask of events that were witnessed on the file descriptor. The
        kernel sets this field on return. All of the events requested in the
        events field may be returned in the
        revents field. Valid events are as
        follows:</p>
<p>POLLIN</p>
<p>There is data to read.POLLRDNORM</p>
<p>There is normal data to read.POLLRDBAND</p>
<p>There is priority data to read.POLLPRI</p>
<p>There is urgent data to read.POLLOUT</p>
<p>Writing will not block.POLLWRNORM</p>
<p>Writing normal data will not block.POLLWRBAND</p>
<p>Writing priority data will not block.POLLMSG</p>
<p>A SIGPOLL message is
              available.</p>
<p>In addition, the following events may be returned in the
        revents field:</p>
<p>POLLER</p>
<p>Error on the given file descriptor.POLLHUP</p>
<p>Hung up event on the given file descriptor.POLLNVAL</p>
<p>The given file descriptor is invalid.</p>
<p>These events have no meaning in the events field, as they are always returned if
        applicable. With poll( ), unlike
        select( ), you need not explicitly
        ask for reporting of exceptions.</p>
<p>POLLIN | POLLPRI is
        equivalent to select( )'s read
        event, and POLLOUT | POLLWRBAND is
        equivalent to select( )'s write
        event. POLLIN is equivalent to
        POLLRDNORM | POLLRDBAND, and
        POLLOUT is equivalent to POLLWRNORM.</p>
<p>For example, to watch a file descriptor for both readability and
        writability, we would set events to
        POLLIN | POLLOUT. On return, we
        would check revents for these flags
        in the structure corresponding to the file descriptor in question. If
        POLLIN were set, the file
        descriptor would be readable without blocking. If POLLOUT were set, the file descriptor would
        be writable without blocking. The flags are not mutually exclusive:
        both may be set, signifying that both reads and writes will return
        instead of blocking on that file descriptor.</p>
<p>The timeout parameter
        specifies the length of time to wait, in milliseconds, before
        returning regardless of any ready I/O. A negative value denotes an
        infinite timeout. A value of 0
        instructs the call to return immediately, listing any file descriptors
        with pending ready I/O, but not waiting for any further events. In
        this manner, poll( ) is true to its
        name, polling once, and immediately returning.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, poll( ) returns
          the number of file descriptors whose structures have nonzero
          revents fields. It returns
          0 if the timeout occurred before
          any events occurred. On failure, −1 is returned, and errno is set to one of the
          following:</p>
<p>EBADF</p>
<p>An invalid file descriptor was given in one or more of
                the structures.EFAULT</p>
<p>The pointer to fds
                pointed outside of the process' address space.EINTR</p>
<p>A signal occurred before any requested event. The call
                may be reissued.EINVAL</p>
<p>The nfds parameter
                exceeded the RLIMIT_NOFILE
                value.ENOMEM</p>
<p>Insufficient memory was available to complete the
                request.</p>
<empty-line/>
<p><strong>poll( ) example</strong></p>
<p>Let's look at an example program that uses poll( ) to simultaneously check whether a
          read from <emphasis>stdin</emphasis> and a write to
          <emphasis>stdout</emphasis> will block:#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/poll.h&gt;

#define TIMEOUT 5       /* poll timeout, in seconds */

int main (void)
{
        struct pollfd fds[2];
        int ret;

        /* watch stdin for input */
        fds[0].fd = STDIN_FILENO;
        fds[0].events = POLLIN;

        /* watch stdout for ability to write (almost always true) */
        fds[1].fd = STDOUT_FILENO;
        fds[1].events = POLLOUT;

        /* All set, block! */
        ret = poll (fds, 2, TIMEOUT * 1000);
        if (ret == −1) {
                perror ("poll");
                return 1;
        }

        if (!ret) {
                printf ("%d seconds elapsed.\n", TIMEOUT);
                return 0;
        }

        if (fds[0].revents &amp; POLLIN)
                printf ("stdin is readable\n");

        if (fds[1].revents &amp; POLLOUT)
                printf ("stdout is writable\n");

        return 0;
}</p>
<p>Running this, we get the following, as expected:$ ./poll
stdout is writable</p>
<p>Running it again, but this time redirecting a file into
          standard in, we see both events:$ ./poll &lt; ode_to_my_parrot.txt
stdin is readable
stdout is writable</p>
<p>If we were using poll( ) in
          a real application, we would not need to reconstruct the pollfd structures on each invocation. The
          same structure may be passed in repeatedly; the kernel will handle
          zeroing the revents field as
          needed.</p>
<empty-line/>
<p><strong>ppoll( )</strong></p>
<p>Linux provides a ppoll( )
          cousin to poll( ), in the same
          vein as pselect( ). Unlike
          pselect( ), however, ppoll( ) is a Linux-specific
          interface:<strong>#define _GNU_SOURCE
#include &lt;sys/poll.h&gt;

int ppoll (struct pollfd *fds,
           nfds_t nfds,
           const struct timespec *timeout,
           const sigset_t *sigmask);</strong></p>
<p>As with pselect( ), the
          timeout parameter specifies a
          timeout value in seconds and nanoseconds, and the sigmask parameter provides a set of
          signals for which to wait.</p>
<empty-line/>
<p><strong>poll( ) Versus select( )</strong></p>
<p>Although they perform the same basic job, the poll( ) system call is superior to select( ) for a handful of
        reasons:</p>
<p>poll( ) does not require
            that the user calculate and pass in as a parameter the value of
            the highest-numbered file descriptor plus one.</p>
<p>poll( ) is more efficient
            for large-valued file descriptors. Imagine watching a single file
            descriptor with the value 900 via select(
            )—the kernel would have to check each bit of each
            passed-in set, up to the 900th bit.</p>
<p>select( )'s file
            descriptor sets are statically sized, introducing a tradeoff: they
            are small, limiting the maximum file descriptor that select( ) can watch, or they are
            inefficient. Operations on large bitmasks are not efficient,
            especially if it is not known whether they are sparsely
            populated.<sup>[11]</sup> With poll( ), one
            can create an array of exactly the right size. Only watching one
            item? Just pass in a single structure.</p>
<p>With select( ), the file
            descriptor sets are reconstructed on return, so each subsequent
            call must reinitialize them. The poll(
            ) system call separates the input (events field) from the output (revents field), allowing the array to be
            reused without change.</p>
<p>The timeout parameter to
            select( ) is undefined on
            return. Portable code needs to reinitialize it. This is not an
            issue with pselect( ),
            however.</p>
<p>The select( ) system call
        does have a few things going for it, though:</p>
<p>select( ) is more
            portable, as some Unix systems do not support poll( ).</p>
<p>select( ) provides better
            timeout resolution: down to the microsecond. Both ppoll( ) and pselect( ) theoretically provide
            nanosecond resolution, but in practice, none of these calls
            reliably provides even microsecond resolution.</p>
<p>Superior to both poll( ) and
        select( ) is the
        <emphasis>epoll</emphasis> interface, a Linux-specific multiplexing
        I/O solution that we'll look at in Chapter 4.</p>
<empty-line/>
<p><strong>Kernel Internals</strong></p>
<p>This section looks at how the Linux kernel implements I/O,
      focusing on three primary subsystems of the kernel: the
      <emphasis>virtual filesystem</emphasis> (VFS), the <emphasis>page
      cache</emphasis>, and <emphasis>page writeback</emphasis>. Together,
      these subsystems help make I/O seamless, efficient, and optimal.</p>
<p><strong>Tip</strong></p>
<p>In Chapter 4, we will look at
        a fourth subsystem, the <emphasis>I/O scheduler</emphasis>.</p>
<empty-line/>
<p><strong>The Virtual Filesystem</strong></p>
<p>The virtual filesystem, occasionally also called a
        <emphasis>virtual file switch</emphasis>, is a mechanism of
        abstraction that allows the Linux kernel to call filesystem functions
        and manipulate filesystem data without knowing—or even caring
        about—the specific type of filesystem being used.</p>
<p>The VFS accomplishes this abstraction by providing a
        <emphasis>common file model</emphasis>, which is the basis for all
        filesystems in Linux. Via function pointers and various
        object-oriented practices,<sup>[12]</sup> the common file model provides a framework to which
        filesystems in the Linux kernel must adhere. This allows the VFS to
        generically make requests of the filesystem. The framework provides
        hooks to support reading, creating links, synchronizing, and so on.
        Each filesystem then registers functions to handle the operations of
        which it is capable.</p>
<p>This approach forces a certain amount of commonality between
        filesystems. For example, the VFS talks in terms of inodes,
        superblocks, and directory entries. A filesystem not of Unix origins,
        possibly devoid of Unix-like concepts such as inodes, simply has to
        cope. Indeed, cope they do: Linux supports filesystems such as FAT and
        NTFS without issue.</p>
<p>The benefits of the VFS are enormous. A single system call can
        read from <emphasis>any</emphasis> filesystem on
        <emphasis>any</emphasis> medium; a single utility can copy from any
        one filesystem to any other. All filesystems support the same
        concepts, the same interfaces, and the same calls. Everything just
        works—and works well.</p>
<p>When an application issues a read(
        ) system call, it takes an interesting journey. The C
        library provides definitions of the system call that are converted to
        the appropriate trap statements at compile-time. Once a user-space
        process is trapped into the kernel, passed through the system call
        handler, and handed to the read( )
        system call, the kernel figures out what object
        <emphasis>backs</emphasis> the given file descriptor. The kernel then
        invokes the read function associated with the backing object. For
        filesystems, this function is part of the filesystem code. The
        function then does its thing—for example, physically reading the data
        from the filesystem—and returns the data to the user-space read( ) call, which then returns to the
        system call handler, which copies the data back to user space, where
        the read( ) system call returns and
        the process continues to execute.</p>
<p>To system programmers, the ramifications of the VFS are
        important. Programmers need not worry about the type of filesystem or
        media on which a file resides. Generic system calls—read( ), write(
        ), and so on—can manipulate files on any supported
        filesystem and on any supported media.</p>
<empty-line/>
<p><strong>The Page Cache</strong></p>
<p>The page cache is an in-memory store of recently accessed data
        from an on-disk filesystem. Disk access is painfully slow,
        particularly relative to today's processor speeds. Storing requested
        data in memory allows the kernel to fulfill subsequent requests for
        the same data from memory, avoiding repeated disk access.</p>
<p>The page cache exploits the concept of <emphasis>temporal
        locality</emphasis>, a type of <emphasis>locality of
        reference</emphasis>, which says that a resource accessed at one point
        has a high probability of being accessed again in the near future. The
        memory consumed to cache data on its first access therefore pays off,
        as it prevents future expensive disk accesses.</p>
<p>The page cache is the first place that the kernel looks for
        filesystem data. The kernel invokes the memory subsystem to read data
        from the disk only when it isn't found in the cache. Thus, the first
        time any item of data is read, it is transferred from the disk into
        the page cache, and is returned to the application from the cache. If
        that data is then read again, it is simply returned from the cache.
        All operations transparently execute through the page cache, ensuring
        that its data is relevant and always valid.</p>
<p>The Linux page cache is dynamic in size. As I/O operations bring
        more and more data into memory, the page cache grows larger and
        larger, consuming any free memory. If the page cache eventually does
        consume all free memory, and an allocation is committed that requests
        additional memory, the page cache is <emphasis>pruned</emphasis>,
        releasing its least-used pages, to make room for "real" memory usage.
        This pruning occurs seamlessly and automatically. A dynamically sized
        cache allows Linux to use all of the memory in the system, and cache
        as much data as possible.</p>
<p>Often, however, it would make more sense to
        <emphasis>swap</emphasis> to disk a seldom-used chunk of data than it
        would to prune an oft-used piece of the page cache that could well be
        reread into memory on the next read request (swapping allows the
        kernel to store data on the disk, to allow a larger memory footprint
        than the machine has RAM). The Linux kernel implements heuristics to
        balance the swapping of data versus the pruning of the page cache (and
        other in-memory reserves). These heuristics might decide to swap data
        out to disk in lieu of pruning the page cache, particularly if the
        data being swapped out is not in use.</p>
<p>The swap-versus-cache balance is tuned via
        <emphasis>/proc/sys/vm/swappiness</emphasis>. This virtual file has a
        value from 0 to 100, with a default of 60. A higher value implies a
        stronger preference toward keeping the page cache in memory, and
        swapping more readily. A lower value implies a stronger preference
        toward pruning the page cache and not swapping.</p>
<p>Another form of locality of reference is <emphasis>sequential
        locality</emphasis>, which says that data is often referenced
        sequentially. To take advantage of this principle, the kernel also
        implements page cache <emphasis>readahead</emphasis>. Readahead is the
        act of reading extra data off the disk and into the page cache
        following each read request—in effect, reading a little bit ahead.
        When the kernel reads a chunk of data from the disk, it also reads the
        following chunk or two. Reading large sequential chunks of data at
        once is efficient, as the disk usually need not seek. In addition, the
        kernel can fulfill the readahead request while the process is
        manipulating the first chunk of read data. If, as often happens, the
        process goes on to submit a new read request for the subsequent chunk,
        the kernel can hand over the data from the initial readahead without
        having to issue a disk I/O request.</p>
<p>As with the page cache, the kernel manages readahead
        dynamically. If it notices that a process is consistently using the
        data that was read in via readahead, the kernel grows the readahead
        window, thereby reading ahead more and more data. The readahead window
        may be as small as 16 KB, and as large as 128 KB. Conversely, if the
        kernel notices that readahead is not resulting in any useful hits—that
        is, that the application is seeking around the file and not reading
        sequentially—it can disable readahead entirely.</p>
<p>The presence of a page cache is meant to be transparent. System
        programmers generally cannot optimize their code to better take
        advantage of the fact that a page cache exists—other than, perhaps,
        not implementing such a cache in user space themselves. Normally,
        efficient code is all that is needed to best utilize the page cache.
        Utilizing readahead, on the other hand, is possible. Sequential file
        I/O is always preferred to random access, although it's not always
        feasible.</p>
<empty-line/>
<p><strong>Page Writeback</strong></p>
<p>As discussed earlier in "Behavior of write( )," the kernel defers
        writes via buffers. When a process issues a write request, the data is
        copied into a buffer, and the buffer is marked
        <emphasis>dirty</emphasis>, denoting that the in-memory copy is newer
        than the on-disk copy. The write request then simply returns. If
        another write request is made to the same chunk of a file, the buffer
        is updated with the new data. Write requests elsewhere in the same
        file generate new buffers.</p>
<p>Eventually the dirty buffers need to be committed to disk,
        synchronizing the on-disk files with the data in memory. This is known
        as writeback. It occurs in two situations:</p>
<p>When free memory shrinks below a configurable threshold,
            dirty buffers are written back to disk so that the now-clean
            buffers may be removed, freeing memory.</p>
<p>When a dirty buffer ages beyond a configurable threshold,
            the buffer is written back to disk. This prevents data from
            remaining dirty indefinitely.</p>
<p>Writebacks are carried out by a gang of kernel threads named
        <emphasis>pdflush</emphasis> threads (presumably for <emphasis>page
        dirty flush</emphasis>, but who knows). When one of the previous two
        conditions is met, the pdflush threads wake up, and begin committing
        dirty buffers to disk until neither condition is true.</p>
<p>There may be multiple pdflush threads instantiating writebacks
        at the same time. This is done to capitalize on the benefits of
        parallelism and to implement <emphasis>congestion
        avoidance</emphasis>. Congestion avoidance attempts to keep writes
        from getting backed up while waiting to be written to any one block
        device. If dirty buffers from different block devices exist, the
        various pdflush threads will work to fully use each block device. This
        fixes a deficiency in earlier kernels: the predecessor to pdflush
        threads (<emphasis>bdflush</emphasis>, a single thread) could spend
        all of its time waiting on a single block device, while other block
        devices sat idle. On a modern machine, the Linux kernel can now keep a
        very large number of disks saturated.</p>
<p>Buffers are represented in the kernel by the buffer_head data structure. This data
        structure tracks various metadata associated with the buffer, such as
        whether the buffer is clean or dirty. It also contains a pointer to
        the actual data. This data resides in the page cache. In this manner,
        the buffer subsystem and the page cache are unified.</p>
<p>In early versions of the Linux kernel—before 2.4—the buffer
        subsystem was separate from the page cache, and thus there was both a
        page and a buffer cache. This implied that data could exist in the
        buffer cache (as a dirty buffer) and the page cache (as cached data)
        at the same time. Naturally, synchronizing these two separate caches
        took some effort. The unified page cache introduced in the 2.4 Linux
        kernel was a welcomed improvement.</p>
<p>Deferred writes and the buffer subsystem in Linux enable fast
        writes, at the expense of the risk of data loss on power failure. To
        avoid this risk, paranoid and critical applications can use
        synchronized I/O (discussed earlier in this chapter).</p>
<empty-line/>
<p><strong>Conclusion</strong></p>
<p>This chapter discussed the basics of Linux system programming:
      file I/O. On a system such as Linux, which strives to represent as much
      as possible as a file, it's very important to know how to open, read,
      write, and close files. All of these operations are classic Unix, and
      are represented in many standards.</p>
<p>The next chapter tackles buffered I/O, and the standard C
      library's standard I/O interfaces. The standard C library is not just a
      convenience; buffering I/O in user space provides crucial performance
      improvements.</p>
<empty-line/><empty-line/>
<p><sup>[6] </sup><sup>*</sup> The mount options bsdgroups or sysvgroups.</p>
<p><sup>[7] </sup><sup>*</sup> Recall that system calls are
            defined on a per-architecture basis. Thus, while i386 has a
            creat( ) system call, Alpha
            does not. You can use creat( )
            on any architecture, of course, but it may be a library function
            instead of having its own system call.</p>
<p><sup>[8] </sup><sup>*</sup> Well, the same caveat applies
            as before: the hard drive may lie and inform the kernel that the
            buffers reside on disk when they actually are still in the disk's
            cache.</p>
<p><sup>[9] </sup><sup>*</sup> Mainloops should be familiar to
          anyone who has written GUI applications—for example, GNOME
          applications utilize a mainloop provided by
          <emphasis>GLib</emphasis>, their base library. A mainloop allows
          multiple events to be watched for and responded to from a single
          blocking point.</p>
<p><sup>[10] </sup><sup>*</sup> This is because select( ) and poll( ) are level-triggered and not
            edge-triggered. epoll( ), which
            we'll discuss in Chapter 4, can
            operate in either mode. Edge-triggered operation is simpler, but
            allows I/O events to be missed if care is not taken.</p>
<p><sup>[11] </sup><sup>*</sup> If a bitmask is generally
                sparsely populated, each word composing the mask can be
                checked against zero; only if that operation returns false
                need each bit be checked. This work is wasted, however, if the
                bitmask is densely populated.</p>
<p><sup>[12] </sup><sup>*</sup> Yes, in C.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 3. Buffered I/O</strong></p>
<p>Recall from Chapter 1
    that the <emphasis>block</emphasis>, a filesystem abstraction, is the
    <emphasis>lingua franca</emphasis> of I/O—all disk operations occur in
    terms of blocks. Consequently, I/O performance is optimal when requests
    are issued on block-aligned boundaries in integer multiples of the block
    size.</p>
<p>Performance degradation is exacerbated by the increased number of
    system calls required to read, say, a single byte 1,024 times rather than
    1,024 bytes all at once. Even a series of operations performed in a size
    larger than a block can be suboptimal if the size is not an integer
    multiple of the block size. For example, if the block size is one
    kilobyte, operations in chunks of 1,130 bytes may still be slower than
    1,024 byte operations.</p>
<empty-line/>
<p><strong>User-Buffered I/O</strong></p>
<p>Programs that have to issue many small I/O requests to regular
      files often perform <emphasis>user-buffered I/O</emphasis>. This refers
      to buffering done in user space, either manually by the application, or
      transparently in a library, not to buffering done by the kernel. As
      discussed in Chapter 2, for reasons of
      performance, the kernel buffers data internally by delaying writes,
      coalescing adjacent I/O requests, and reading ahead. Through different
      means, user buffering also aims to improve performance.</p>
<p>Consider an example using the user-space program
      <emphasis>dd</emphasis>:dd bs=1 count=2097152 if=/dev/zero of=pirate</p>
<p>Because of the bs=1 argument,
      this command will copy two megabytes from the device
      <emphasis>/dev/zero</emphasis> (a virtual device providing an endless
      stream of zeros) to the file <emphasis>pirate</emphasis> in 2,097,152
      one byte chunks. That is, it will copy the data via about two million
      read and write operations—one byte at a time.</p>
<p>Now consider the same two megabyte copy, but using 1,024 byte
      blocks:dd bs=1024 count=2048 if=/dev/zero of=pirate</p>
<p>This operation copies the same two megabytes to the same file, yet
      issues 1,024 times fewer read and write operations. The performance
      improvement is huge, as you can see in Table 3-1. Here, I've recorded
      the time taken (using three different measures) by four
      <emphasis>dd</emphasis> commands that differed only in block size. Real
      time is the total elapsed wall clock time, user time is the time spent
      executing the program's code in user space, and system time is the time
      spent executing system calls in kernel space on the process'
      behalf.</p>
<p><emphasis>Table 3-1. Effects of block size on performance</emphasis></p>
<p><strong>Block
              size</strong></p>
<p><strong>Real
              time</strong></p>
<p><strong>User
              time</strong></p>
<p><strong>System
              time</strong></p>
<p>1 byte</p>
<p>18.707
              seconds</p>
<p>1.118
              seconds</p>
<p>17.549
              seconds</p>
<p>1,024
              bytes</p>
<p>0.025
              seconds</p>
<p>0.002
              seconds</p>
<p>0.023
              seconds</p>
<p>1,130
              bytes</p>
<p>0.035
              seconds</p>
<p>0.002
              seconds</p>
<p>0.027
              seconds</p>
<p>Using 1,024 byte chunks results in an
      <emphasis>enormous</emphasis> performance improvement compared to the
      single byte chunk. However, the table also demonstrates that using a
      larger block size—which implies even fewer system calls—can result in
      performance degradation if the operations are not performed in multiples
      of the disk's block size. Despite requiring fewer calls, the 1,130 byte
      requests end up generating unaligned requests, and are therefore less
      efficient than the 1,024 byte requests.</p>
<p>Taking advantage of this performance boon requires prior knowledge
      of the likely physical block size. The results in the table show the
      block size is most likely 1,024, an integer multiple of 1,024, or a
      divisor of 1,024. In the case of <emphasis>/dev/zero</emphasis>, the
      block size is actually 4,096 bytes.</p>
<empty-line/>
<p><strong>Block Size</strong></p>
<p>In practice, blocks are usually 512, 1,024, 2,048, or 4,096
        bytes in size.</p>
<p>As Table 3-1
        demonstrates, a large performance gain is realized simply by
        performing operations in chunks that are integer multiples or divisors
        of the block size. This is because the kernel and hardware speak in
        terms of blocks. So, using the block size or a value that fits neatly
        inside of a block guarantees block-aligned I/O requests, and prevents
        extraneous work inside the kernel.</p>
<p>Figuring out the block size for a given device is easy using the
        stat( ) system call (covered in
        Chapter 7) or the
        <emphasis>stat</emphasis>(1) command. It turns out, however, that you
        don't usually need to know the actual block size.</p>
<p>The primary goal in picking a size for your I/O operations is to
        not pick an oddball size such as 1,130. No block in the history of
        Unix has been 1,130 bytes, and choosing such a size for your
        operations will result in unaligned I/O after the first request. Using
        any integer multiple or divisor of the block size, however, prevents
        unaligned requests. So long as your chosen size keeps everything
        block-aligned, performance will be good. Larger multiples will simply
        result in fewer system calls.</p>
<p>Therefore, the easiest choice is to perform I/O using a large
        buffer size that is a multiple of the typical block sizes. Both 4,096
        and 8,192 bytes work great.</p>
<p>The problem, of course, is that programs rarely deal in terms of
        blocks. Programs work with fields, lines, and single characters, not
        abstractions such as blocks. As described earlier, to remedy this
        situation, programs employ user-buffered I/O. As data is written, it
        is stored in a buffer inside the program's address space. When the
        buffer reaches a specific size—the <emphasis>buffer
        size</emphasis>—the entire buffer is written out in a single write
        operation. Likewise, data is read in using buffer-sized, block-aligned
        chunks. As the application issues its odd-sized read requests, the
        chunks of the buffer are handed out piece by piece. Ultimately, when
        the buffer is empty, another large block-aligned chunk is read in. If
        this buffer is the right size, huge performance benefits are
        realized.</p>
<p>It is possible to implement user buffering by hand in your own
        programs. Indeed, many mission-critical applications do just this. The
        vast majority of programs, however, make use of the popular
        <emphasis>standard I/O library</emphasis> (part of the
        <emphasis>standard C library</emphasis>), which provides a robust and
        capable user-buffering solution.</p>
<empty-line/>
<p><strong>Standard I/O</strong></p>
<p>The standard C library provides the standard I/O library (often
      simply called <emphasis>stdio</emphasis>), which in turn provides a
      platform-independent, user-buffering solution. The standard I/O library
      is simple to use, yet powerful.</p>
<p>Unlike programming languages such as FORTRAN, the C language does
      not include any built-in support or keywords providing any functionality
      more advanced than flow control, arithmetic, and so on—there's certainly
      no inherent support for I/O. As the C programming language progressed,
      users developed standard sets of routines to provide core functionality,
      such as string manipulation, mathematical routines, time and date
      functionality, and I/O. Over time, these routines matured, and with the
      ratification of the ANSI C standard in 1989 (C89) they were eventually
      formalized as the standard C library. Although both C95 and C99 added
      several new interfaces, the standard I/O library has remained relatively
      untouched since its creation in 1989.</p>
<p>The remainder of this chapter discusses user-buffered I/O as it
      pertains to file I/O, and is implemented in the standard C library—that
      is, opening, closing, reading, and writing files via the standard C
      library. Whether an application will use standard I/O, a home-rolled
      user-buffering solution, or straight system calls is a decision that
      developers must make carefully after weighing the application's needs
      and behavior.</p>
<p>The C standards always leave some details up to each
      implementation, and implementations often add additional features. This
      chapter, just like the rest of the book, documents the interfaces and
      behavior as they are implemented in <emphasis>glibc</emphasis> on a
      modern Linux system. Where Linux deviates from the basic standard, this
      is noted.</p>
<empty-line/>
<p><strong>File Pointers</strong></p>
<p>Standard I/O routines do not operate directly on file
        descriptors. Instead, they use their own unique identifier, known as
        the <emphasis>file pointer</emphasis>. Inside the C library, the file
        pointer maps to a file descriptor. The file pointer is represented by
        a pointer to the FILE typedef,
        which is defined in &lt;stdio.h&gt;.</p>
<p>In standard I/O parlance, an open file is called a
        <emphasis>stream</emphasis>. Streams may be opened for reading
        (<emphasis>input streams</emphasis>), writing (<emphasis>output
        streams</emphasis>), or both (<emphasis>input/output
        streams</emphasis>).</p>
<empty-line/>
<p><strong>Opening Files</strong></p>
<p>Files are opened for reading or writing via fopen( ):<strong>#include &lt;stdio.h&gt;

FILE * fopen (const char *path, const char *mode);</strong></p>
<p>This function opens the file path according to the given modes, and
      associates a new stream with it.</p>
<empty-line/>
<p><strong>Modes</strong></p>
<p>The mode argument describes
        how to open the given file. It is one of the following strings:</p>
<p>r</p>
<p>Open the file for reading. The stream is positioned at the
              start of the file.r+</p>
<p>Open the file for both reading and writing. The stream is
              positioned at the start of the file.w</p>
<p>Open the file for writing. If the file exists, it is
              truncated to zero length. If the file does not exist, it is
              created. The stream is positioned at the start of the
              file.w+</p>
<p>Open the file for both reading and writing. If the file
              exists, it is truncated to zero length. If the file does not
              exist, it is created. The stream is positioned at the start of
              the file.a</p>
<p>Open the file for writing in append mode. The file is
              created if it does not exist. The stream is positioned at the
              end of the file. All writes will append to the file.a+</p>
<p>Open the file for both reading and writing in append mode.
              The file is created if it does not exist. The stream is
              positioned at the end of the file. All writes will append to the
              file.</p>
<p><strong>Tip</strong></p>
<p>The given mode may also contain the character b, although this value is always ignored
          on Linux. Some operating systems treat text and binary files
          differently, and the b mode
          instructs the file to be opened in binary mode. Linux, as with all
          POSIX-conforming systems, treats text and binary files
          identically.</p>
<p>Upon success, fopen( )
        returns a valid FILE pointer. On
        failure, it returns NULL, and sets
        errno appropriately.</p>
<p>For example, the following code opens
        <emphasis>/etc/manifest</emphasis> for reading, and associates it with
        stream:FILE *stream;

stream = fopen ("/etc/manifest", "r");
if (!stream)
        /* error */</p>
<empty-line/>
<p><strong>Opening a Stream via File Descriptor</strong></p>
<p>The function fdopen( ) converts
      an already open file descriptor (fd)
      to a stream:<strong>#include &lt;stdio.h&gt;

FILE * fdopen (int fd, const char *mode);</strong></p>
<p>The possible modes are the same as for fopen( ), and must be compatible with the
      modes originally used to open the file descriptor. The modes w and w+
      may be specified, but they will not cause truncation. The stream is
      positioned at the file position associated with the file
      descriptor.</p>
<p>Once a file descriptor is converted to a stream, I/O should no
      longer be directly performed on the file descriptor. It is, however,
      legal to do so. Note that the file descriptor is not duplicated, but is
      merely associated with a new stream. Closing the stream will close the
      file descriptor as well.</p>
<p>On success, fdopen( ) returns a
      valid file pointer; on failure, it returns NULL.</p>
<p>For example, the following code opens
      <emphasis>/home/kidd/map.txt</emphasis> via the open( ) system call, and then uses the backing
      file descriptor to create an associated stream:FILE *stream;
int fd;

fd = open ("/home/kidd/map.txt", O_RDONLY);
if (fd == -1)
        /* error */

stream = fdopen (fd, "r");
if (!stream)
        /* error */</p>
<empty-line/>
<p><strong>Closing Streams</strong></p>
<p>The fclose( ) function closes a
      given stream:<strong>#include &lt;stdio.h&gt;

int fclose (FILE *stream);</strong></p>
<p>Any buffered and not-yet-written data is first flushed. On
      success, fclose( ) returns 0. On failure, it returns EOF and sets errno appropriately.</p>
<empty-line/>
<p><strong>Closing All Streams</strong></p>
<p>The fcloseall( ) function
        closes all streams associated with the current process, including
        standard in, standard out, and standard error:<strong>#define _GNU_SOURCE

#include &lt;stdio.h&gt;

int fcloseall (void);</strong></p>
<p>Before closing, all streams are flushed. The function always
        returns 0; it is
        Linux-specific.</p>
<empty-line/>
<p><strong>Reading from a Stream</strong></p>
<p>The standard C library implements multiple functions for reading
      from an open stream, ranging from the common to the esoteric. This
      section will look at three of the most popular approaches to reading:
      reading one character at a time, reading an entire line at a time, and
      reading binary data. To read from a stream, it must have been opened as
      an input stream with the appropriate mode; that is, any valid mode
      except w or a.</p>
<empty-line/>
<p><strong>Reading a Character at a Time</strong></p>
<p>Often, the ideal I/O pattern is simply reading one character at
        a time. The function fgetc( ) is
        used to read a single character from a stream:<strong>#include &lt;stdio.h&gt;

int fgetc (FILE *stream);</strong></p>
<p>This function reads the next character from stream and returns it as an unsigned char cast to an int. The casting is done to have a
        sufficient range for notification of end-of-file or error: EOF is returned in such conditions. The
        return value of fgetc( ) must be
        stored in an int. Storing it in a
        char is a common but dangerous
        mistake.</p>
<p>The following example reads a single character from stream, checks for error, and then prints
        the result as a char:int c;

c = fgetc (stream);
if (c == EOF)
        /* error */
else
        printf ("c=%c\n", (char) c);</p>
<p>The stream pointed at by stream must be open for reading.</p>
<empty-line/>
<p><strong>Putting the character back</strong></p>
<p>Standard I/O provides a function for pushing a character back
          onto a stream, allowing you to "peek" at the stream, and return the
          character if it turns out that you don't want it:<strong>#include &lt;stdio.h&gt;

int ungetc (int c, FILE *stream);</strong></p>
<p>Each call pushes back c,
          cast to an unsigned char, onto
          stream. On success, c is returned; on failure, EOF is returned. A subsequent read on
          stream will return c. If multiple characters are pushed back,
          they are returned in the reverse order—that is, the last pushed
          character is returned first. POSIX dictates that only one pushback
          is guaranteed to succeed without intervening read requests. Some
          implementations, in turn, allow only a single pushback; Linux allows
          an infinite number of pushbacks, so long as memory is available. One
          pushback, of course, always succeeds.</p>
<p>If you make an intervening call to a seeking function (see
          "Seeking a Stream" later in this chapter) after
          calling ungetc( ) but before
          issuing a read request, it will cause all pushed-back characters to
          be discarded. This is true among threads in a single process, as
          threads share the buffer.</p>
<empty-line/>
<p><strong>Reading an Entire Line</strong></p>
<p>The function fgets( ) reads a
        string from a given stream:<strong>#include &lt;stdio.h&gt;

char * fgets (char *str, int size, FILE *stream);</strong></p>
<p>This function reads up to <emphasis>one less</emphasis> than
        size bytes from stream, and stores the results in str. A null character (\0) is stored in the buffer after the bytes
        read in. Reading stops after an EOF
        or a newline character is reached. If a newline is read, the \n is stored in str.</p>
<p>On success, str is returned;
        on failure, NULL is
        returned.</p>
<p>For example:char buf[LINE_MAX];

if (!fgets (buf, LINE_MAX, stream))
        /* error */</p>
<p>POSIX defines LINE_MAX in
        &lt;limits.h&gt;: it is the maximum
        size of input line that POSIX line-manipulating interfaces can handle.
        Linux's C library has no such limitation—lines may be of any size—but
        there is no way to communicate that with the LINE_MAX definition. Portable programs can
        use LINE_MAX to remain safe; it is
        set relatively high on Linux. Linux-specific programs need not worry
        about limits on the sizes of lines.</p>
<empty-line/>
<p><strong>Reading arbitrary strings</strong></p>
<p>Often, the line-based reading of fgets( ) is useful. Nearly as often, it's
          annoying. Sometimes, developers want to use a delimiter other than
          the newline. Other times, developers do not want a delimiter at
          all—and rarely do developers want the delimiter stored in the
          buffer! In retrospect, the decision to store the newline in the
          returned buffer rarely appears correct.</p>
<p>It is not hard to write an fgets(
          ) replacement that uses fgetc(
          ). For example, this snippet reads the n − 1 bytes from stream into str, and then appends a
          \0 character:char *s;
int c;

s = str;
while (--n &gt; 0 &amp;&amp; (c = fgetc (stream)) != EOF)
        *s++ = c;
*s = '\0';</p>
<p>The snippet can be expanded to also stop reading at a
          delimiter, given by d (which
          cannot be the null character in this example):char *s;
int c = 0;

s = str;
while (--n &gt; 0 &amp;&amp; (c = fgetc (stream)) != EOF &amp;&amp; (*s++ = c) != d)
        ;

if (c == d)
        *--s = '\0';
else
        *s = '\0';</p>
<p>Setting d to \n would provide behavior similar to
          fgets( ), minus storing the
          newline in the buffer.</p>
<p>Depending on the implementation of fgets( ), this variant is probably slower,
          as it issues repeated function calls to fgetc( ). This is not the same problem
          exhibited by our original <emphasis>dd</emphasis> example, however!
          Although this snippet incurs additional function call overhead, it
          does not incur the system call overhead and unaligned I/O penalty
          burdened on <emphasis>dd</emphasis> with bs=1. The latter are much larger
          problems.</p>
<empty-line/>
<p><strong>Reading Binary Data</strong></p>
<p>For some applications, reading individual characters or lines is
        insufficient. Sometimes, developers want to read and write complex
        binary data, such as C structures. For this, the standard I/O library
        provides fread( ):<strong>#include &lt;stdio.h&gt;

size_t fread (void *buf, size_t size, size_t nr, FILE *stream);</strong></p>
<p>A call to fread( ) will read
        up to nr elements of data, each of
        size bytes, from stream into the buffer pointed at by
        buf. The file pointer is advanced
        by the number of bytes read.</p>
<p>The number of elements read (not the number of bytes read!) is
        returned. The function indicates failure or EOF via a return value less than nr. Unfortunately, it is impossible to know
        which of the two conditions occurred without using ferror( ) and feof(
        ) (see the later section "Errors and End-of-File").</p>
<p>Because of differences in variable sizes, alignment, padding,
        and byte order, binary data written with one application may not be
        readable by a different application, or even by the same application
        on a different machine.</p>
<p><strong>Issues of Alignment</strong></p>
<p>All machine architectures have <emphasis>data
          alignment</emphasis> requirements. Programmers tend to think of
          memory as simply an array of bytes. Our processors, however, do not
          read and write from memory in byte-sized chunks. Instead, processors
          access memory with a specific granularity, such as 2, 4, 8, or 16
          bytes. Because each process' address space starts at address 0,
          processes must initiate access from an address that is an integer
          multiple of the granularity.</p>
<p>Consequently, C variables must be stored at and accessed from
          aligned addresses. In general, variables are <emphasis>naturally
          aligned</emphasis>, which refers to the alignment that corresponds
          to the size of the C data type. For example, a 32-bit integer is
          aligned on a 4 byte boundary. In other words, an int would be stored at a memory address
          that is evenly divisible by four.</p>
<p>Accessing misaligned data has various penalties, which depend
          on the machine architecture. Some processors can access misaligned
          data, but with a large performance penalty. Other processors cannot
          access misaligned data at all, and attempting to do so causes a
          hardware exception. Worse, some processors silently drop the
          low-order bits in order to force the address to be aligned, almost
          certainly resulting in unintended behavior.</p>
<p>Normally, the compiler naturally aligns all data, and
          alignment is not a visible issue to the programmer. Dealing with
          structures, performing memory management by hand, saving binary data
          to disk, and communicating over a network may bring alignment issues
          to the forefront. System programmers, therefore, ought to be well
          versed in these issues!</p>
<p>Chapter 8 addresses alignment in
          greater depth.</p>
<p>The simplest example of fread(
        ) is reading a single element of linear bytes from a given
        stream:char buf[64];
size_t nr;

nr = fread (buf, sizeof(buf), 1, stream);
if (nr == 0)
        /* error */</p>
<p>We will look at examples that are more complicated when we study
        the write counterpart to fread( ),
        fwrite( ).</p>
<empty-line/>
<p><strong>Writing to a Stream</strong></p>
<p>As with reading, the standard C library defines many functions for
      writing to an open stream. This section will look at three of the most
      popular approaches to writing: writing a single character, writing a
      string of characters, and writing binary data. Such varied writing
      approaches are ideally suited to buffered I/O. To write to a stream, it
      must have been opened as an output stream with the appropriate mode;
      that is, any valid mode except r.</p>
<empty-line/>
<p><strong>Writing a Single Character</strong></p>
<p>The counterpart of fgetc( )
        is fputc( ):<strong>#include &lt;stdio.h&gt;

int fputc (int c, FILE *stream);</strong></p>
<p>The fputc( ) function writes
        the byte specified by c (cast to an
        unsigned char) to the stream
        pointed at by stream. Upon
        successful completion, the function returns c. Otherwise, it returns EOF, and errno is set appropriately.</p>
<p>Use is simple:if (fputc ('p', stream) == EOF)
        /* error */</p>
<p>This example writes the character p to stream, which must be open for
        writing.</p>
<empty-line/>
<p><strong>Writing a String of Characters</strong></p>
<p>The function fputs( ) is used
        to write an entire string to a given stream:<strong>#include &lt;stdio.h&gt;

int fputs (const char *str, FILE *stream);</strong></p>
<p>A call to fputs( ) writes all
        of the null-delimited string pointed at by str to the stream pointed at by stream. On success, fputs( ) returns a nonnegative number. On
        failure, it returns EOF.</p>
<p>The following example opens the file for writing in append mode,
        writes the given string to the associated stream, and then closes the
        stream:FILE *stream;

stream = fopen ("journal.txt", "a");
if (!stream)
        /* error */

if (fputs ("The ship is made of wood.\n", stream) == EOF)
        /* error */

if (fclose (stream) == EOF)
        /* error */</p>
<empty-line/>
<p><strong>Writing Binary Data</strong></p>
<p>Individual characters and lines will not cut it when programs
        need to write complex data. To directly store binary data such as C
        variables, standard I/O provides fwrite(
        ):<strong>#include &lt;stdio.h&gt;

size_t fwrite (void *buf,
               size_t size,
               size_t nr,
               FILE *stream);</strong></p>
<p>A call to fwrite( ) will
        write to stream up to nr elements, each size bytes in length, from the data pointed
        at by buf. The file pointer will be
        advanced by the total number of bytes written.</p>
<p>The number of elements (not the number of bytes!) successfully
        written will be returned. A return value less than nr denotes error.</p>
<empty-line/>
<p><strong>Sample Program Using Buffered I/O</strong></p>
<p>Now let's look at an example—a complete program, in fact—that
      integrates many of the interfaces we have covered thus far in this
      chapter. This program first defines struct
      pirate, and then declares two variables of that type. The
      program initializes one of the variables and subsequently writes it out
      to disk via an output stream to the file <emphasis>data</emphasis>. Via
      a different stream, the program reads the data back in from
      <emphasis>data</emphasis> directly to the other instance of struct pirate. Finally, the program writes the
      contents of the structure to standard out:#include &lt;stdio.h&gt;

int main (void)
{
        FILE *in, *out;
        struct pirate {
                char            name[100]; /* real name */
                unsigned long   booty;     /* in pounds sterling */
                unsigned int    beard_len; /* in inches */
        } p, blackbeard = { "Edward Teach", 950, 48 };

        out = fopen ("data", "w");
        if (!out) {
                perror ("fopen");
                return 1;
        }

        if (!fwrite (&amp;blackbeard, sizeof (struct pirate), 1, out)) {
                perror ("fwrite");
                return 1;
        }

        if (fclose (out)) {
                perror ("fclose");
                return 1;
        }

        in = fopen ("data", "r");
        if (!in) {
                perror ("fopen");
                return 1;
        }

        if (!fread (&amp;p, sizeof (struct pirate), 1, in)) {
                perror ("fread");
                return 1;
        }

        if (fclose (in)) {
                perror ("fclose");
                return 1;
        }

        printf ("name=\"%s\" booty=%lu beard_len=%u\n",
                p.name, p.booty, p.beard_len);

        return 0;
}</p>
<p>The output is, of course, the original values:name="Edward Teach" booty=950 beard_len=48</p>
<p>Again, it's important to bear in mind that because of differences
      in variable sizes, alignment, and so on, binary data written with one
      application may not be readable by other applications. That is, a
      different application—or even the same application on a different
      machine—may not be able to correctly read back the data written with
      fwrite( ). In our example, consider
      the ramifications if the size of unsigned
      long changed, or if the amount of padding varied. These things
      are guaranteed to remain constant only on a particular machine type with
      a particular ABI.</p>
<empty-line/>
<p><strong>Seeking a Stream</strong></p>
<p>Often, it is useful to manipulate the current stream position.
      Perhaps the application is reading a complex record-based file, and
      needs to jump around. Alternatively, perhaps the stream needs to be
      reset to file position zero. Whatever the case, standard I/O provides a
      family of interfaces equivalent in functionality to the system call
      lseek( ) (discussed in Chapter 2). The fseek(
      ) function, the most common of the standard I/O seeking
      interfaces, manipulates the file position of stream in accordance with offset and whence:<strong>#include &lt;stdio.h&gt;

int fseek (FILE *stream, long offset, int whence);</strong></p>
<p>If whence is set to SEEK_SET, the file position is set to offset. If whence is set to SEEK_CUR, the file position is set to the
      current position plus offset. If
      whence is set to SEEK_END, the file position is set to the end
      of the file plus offset.</p>
<p>Upon successful completion, fseek(
      ) returns 0, clears the
      EOF indicator, and undoes the effects
      (if any) of ungetc( ). On error, it
      returns −1, and errno is set appropriately. The most common
      errors are invalid stream (EBADF) and
      invalid whence argument (EINVAL).</p>
<p>Alternatively, standard I/O provides fsetpos( ):<strong>#include &lt;stdio.h&gt;

int fsetpos (FILE *stream, fpos_t *pos);</strong></p>
<p>This function sets the stream position of stream to pos. It works the same as fseek( ) with a whence argument of SEEK_SET. On success, it returns 0. Otherwise, it returns −1, and errno is set as appropriate. This function
      (along with its counterpart fgetpos(
      ), which we will cover shortly) is provided solely for other
      (non-Unix) platforms that have complex types representing the stream
      position. On those platforms, this function is the only way to set the
      stream position to an arbitrary value, as the C long type is presumably insufficient.
      Linux-specific applications need not use this interface, although they
      may, if they want to be portable to all possible platforms.</p>
<p>Standard I/O also provides rewind(
      ), as a shortcut:<strong>#include &lt;stdio.h&gt;

void rewind (FILE *stream);</strong></p>
<p>This invocation:rewind (stream);</p>
<p>resets the position back to the start of the stream. It is
      equivalent to:fseek (stream, 0, SEEK_SET);</p>
<p>except that it also clears the error indicator.</p>
<p>Note that rewind( ) has no
      return value, and thus cannot directly communicate error conditions.
      Callers wishing to ascertain the existence of an error should clear
      errno before invocation, and check to
      see whether the variable is nonzero afterward. For example:errno = 0;
rewind (stream);
if (errno)
        /* error */</p>
<empty-line/>
<p><strong>Obtaining the Current Stream Position</strong></p>
<p>Unlike lseek( ), fseek( ) does not return the updated
        position. A separate interface is provided for this purpose. The
        ftell( ) function returns the
        current stream position of stream:<strong>#include &lt;stdio.h&gt;

long ftell (FILE *stream);</strong></p>
<p>On error, it returns −1 and
        errno is set appropriately.</p>
<p>Alternatively, standard I/O provides fgetpos( ):<strong>#include &lt;stdioh.h&gt;

int fgetpos (FILE *stream, fpos_t *pos);</strong></p>
<p>Upon success, fgetpos( )
        returns 0, and places the current
        stream position of stream in
        pos. On failure, it returns
        −1, and sets errno appropriately. Like fsetpos( ), fgetpos( ) is provided solely for non-Linux
        platforms with complex file position types.</p>
<empty-line/>
<p><strong>Flushing a Stream</strong></p>
<p>The standard I/O library provides an interface for writing out the
      user buffer to the kernel, ensuring that all data written to a stream is
      flushed via write( ). The fflush( ) function provides this
      functionality:<strong>#include &lt;stdio.h&gt;

int fflush (FILE *stream);</strong></p>
<p>On invocation, any unwritten data in the stream pointed to by
      stream is flushed to the kernel. If
      stream is NULL, <emphasis>all</emphasis> open input
      streams in the process are flushed. On success, fflush( ) returns 0. On failure, it returns EOF, and errno is set appropriately.</p>
<p>To understand the effect of fflush(
      ), you have to understand the difference between the buffer
      maintained by the C library, and the kernel's own buffering. All of the
      calls described in this chapter work with a buffer that is maintained by
      the C library, which resides in user space, not kernel space. That is
      where the performance improvement comes in—you are staying in user
      space, and therefore running user code, not issuing system calls. A
      system call is issued only when the disk or some other medium has to be
      accessed.</p>
<p>fflush( ) merely writes the
      user-buffered data out to the kernel buffer. The effect is the same as
      if user buffering was not employed, and write(
      ) was used directly. It does not guarantee that the data is
      physically committed to any medium—for that need, use something like
      fsync( ) (see "Synchronized I/O" in Chapter 2). Most likely, you
      will want to call fflush( ), followed
      immediately by fsync( ): that is,
      first ensure that the user buffer is written out to the kernel, and then
      ensure that the kernel's buffer is written out to disk.</p>
<empty-line/>
<p><strong>Errors and End-of-File</strong></p>
<p>Some of the standard I/O interfaces, such as fread( ), communicate failures back to the
      caller poorly, as they provide no mechanism for differentiating between
      error and EOF. With these calls, and on other occasions, it can be
      useful to check the status of a given stream to determine whether it has
      encountered an error, or reached the end of a file. Standard I/O
      provides two interfaces to this end. The function ferror( ) tests whether the error indicator is
      set on stream:<strong>#include &lt;stdio.h&gt;

int ferror (FILE *stream);</strong></p>
<p>The error indicator is set by other standard I/O interfaces in
      response to an error condition. The function returns a nonzero value if
      the indicator is set, and 0
      otherwise.</p>
<p>The function feof( ) tests
      whether the EOF indicator is set on
      stream:<strong>#include &lt;stdio.h&gt;

int feof (FILE *stream);</strong></p>
<p>The EOF indicator is set by
      other standard I/O interfaces when the end of a file is reached. This
      function returns a nonzero value if the indicator is set, and 0 otherwise.</p>
<p>The clearerr( ) function clears
      the error and the EOF indicators for
      stream:<strong>#include &lt;stdio.h&gt;

void clearerr (FILE *stream);</strong></p>
<p>It has no return value, and cannot fail (there is no way to know
      whether an invalid stream was provided). You should make a call to
      clearerr( ) only after checking the
      error and EOF indicators, as they
      will be discarded irretrievably afterward. For example:/* 'f' is a valid stream */

if (ferror (f))
        printf ("Error on f!\n");

if (feof (f))
        printf ("EOF on f!\n");

clearerr (f);</p>
<empty-line/>
<p><strong>Obtaining the Associated File Descriptor</strong></p>
<p>Sometimes, it is advantageous to obtain the file descriptor
      backing a given stream. For example, it might be useful to perform a
      system call on a stream, via its file descriptor, when an associated
      standard I/O function does not exist. To obtain the file descriptor
      backing a stream, use fileno(
      ):<strong>#include &lt;stdio.h&gt;

int fileno (FILE *stream);</strong></p>
<p>Upon success, fileno( ) returns
      the file descriptor associated with stream. On failure, it returns −1. This can only happen when the given stream
      is invalid, in which case, the function sets errno to EBADF.</p>
<p>Intermixing standard I/O calls with system calls is not normally
      advised. Programmers must exercise caution when using fileno( ) to ensure proper behavior.
      Particularly, it is probably wise to flush the stream before
      manipulating the backing file descriptor. You should almost never
      intermix actual I/O operations.</p>
<empty-line/>
<p><strong>Controlling the Buffering</strong></p>
<p>Standard I/O implements three types of user buffering, and
      provides developers with an interface for controlling the type and size
      of the buffer. The different types of user buffering serve different
      purposes, and are ideal for different situations. Here are the
      options:</p>
<p><emphasis>Unbuffered</emphasis></p>
<p>No user buffering is performed. Data is submitted directly
            to the kernel. As this is the antithesis of user buffering, this
            option is not commonly used. Standard error, by default, is
            unbuffered.<emphasis>Line-buffered</emphasis></p>
<p>Buffering is performed on a per-line basis. With each
            newline character, the buffer is submitted to the kernel. Line
            buffering makes sense for streams being output to the screen.
            Consequently, this is the default buffering used for terminals
            (standard out is line-buffered by default).<emphasis>Block-buffered</emphasis></p>
<p>Buffering is performed on a per-block basis. This is the
            type of buffering discussed at the beginning of this chapter, and
            it is ideal for files. By default, all streams associated with
            files are block-buffered. Standard I/O uses the term
            <emphasis>full buffering</emphasis> for block buffering.</p>
<p>Most of the time, the default buffering type is correct and
      optimal. However, standard I/O does provide an interface for controlling
      the type of buffering employed:<strong>#include &lt;stdio.h&gt;

int setvbuf (FILE *stream, char *buf, int mode, size_t size);</strong></p>
<p>The setvbuf( ) function sets
      the buffering type of stream to
      mode, which must be one of the
      following:</p>
<p>_IONBF</p>
<p>Unbuffered_IOLBF</p>
<p>Line-buffered_IOFBF</p>
<p>Block-buffered</p>
<p>Except with _IONBF, in which
      case buf and size are ignored, buf may point to a buffer of size bytes that standard I/O will use as the
      buffer for the given stream. If buf
      is NULL, a buffer is allocated
      automatically by <emphasis>glibc</emphasis>.</p>
<p>The setvbuf( ) function must be
      called after opening the stream, but before any other operations have
      been performed on it. It returns 0 on
      success, and a nonzero value otherwise.</p>
<p>The supplied buffer, if any, must exist when the stream is closed.
      A common mistake is to declare the buffer as an automatic variable in a
      scope that ends before the stream is closed. Particularly, be careful
      not to provide a buffer local to main(
      ), and then fail to explicitly close the streams. For example,
      the following is a bug:#include &lt;stdio.h&gt;

int main (void)
{
        char buf[BUFSIZ];

        /* set stdin to block-buffered with a BUFSIZ buffer */
        setvbuf (stdout, buf, _IOFBF, BUFSIZ);
        printf ("Arrr!\n");

        return 0;
}</p>
<p>The bug can be fixed by explicitly closing the stream before
      falling out of scope, or by making buf a global variable.</p>
<p>Generally, developers need not mess with the buffering on a
      stream. With the exception of standard error, terminals are
      line-buffered, and that makes sense. Files are block-buffered, and that,
      too, makes sense. The default buffer size for block buffering is
      BUFSIZ, defined in &lt;stdio.h&gt;, and it is usually an optimal
      choice (a large multiple of a typical block size).</p>
<empty-line/>
<p><strong>Thread Safety</strong></p>
<p><emphasis>Threads</emphasis> are multiple strains of execution
      within a single process. One way to conceptualize them is as multiple
      processes that share an address space. Threads can run at any time, and
      can overwrite shared data unless care is taken to synchronize access to
      the data or make it <emphasis>thread-local</emphasis>. Operating systems
      that support threads provide locking mechanisms (programming constructs
      that ensure mutual exclusion) to ensure that threads do not trample on
      each other's feet. Standard I/O uses these mechanisms. Still, they are
      not always adequate. For example, sometimes you want to lock a group of
      calls, enlarging the <emphasis>critical region</emphasis> (the chunk of
      code that runs without interference from another thread) from one I/O
      operation to several. In other situations, you may want to eliminate
      locking altogether to improve efficiency.<sup>[13]</sup> In this section, we will discuss how to do both.</p>
<p>The standard I/O functions are inherently
      <emphasis>thread-safe</emphasis>. Internally, they associate a lock, a
      lock count, and an owning thread with each open stream. Any given thread
      must acquire the lock and become the owning thread before issuing any
      I/O requests. Two or more threads operating on the same stream cannot
      interleave standard I/O operations, and thus, within the context of
      single function calls, standard I/O operations are atomic.</p>
<p>Of course, in practice, many applications require greater
      atomicity than at the level of individual function calls. For example,
      if multiple threads were issuing write requests, although the individual
      writes would not interleave and result in garbled output, the
      application might wish to have all of the write requests complete
      without interruption. To allow for this, standard I/O provides a family
      of functions for individually manipulating the lock associated with a
      stream.</p>
<empty-line/>
<p><strong>Manual File Locking</strong></p>
<p>The function flockfile( )
        waits until stream is no longer
        locked, and then acquires the lock, bumps the lock count, becomes the
        owning thread of the stream, and returns:<strong>#include &lt;stdio.h&gt;

void flockfile (FILE *stream);</strong></p>
<p>The function funlockfile( )
        decrements the lock count associated with stream:<strong>#include &lt;stdio.h&gt;

void funlockfile (FILE *stream);</strong></p>
<p>If the lock count reaches zero, the current thread relinquishes
        ownership of the stream. Another thread is now able to acquire the
        lock.</p>
<p>These calls can nest. That is, a single thread can issue
        multiple flockfile( ) calls, and
        the stream will not unlock until the process issues a corresponding
        number of funlockfile( )
        calls.</p>
<p>The ftrylockfile( ) function
        is a nonblocking version of flockfile(
        ):<strong>#include &lt;stdio.h&gt;

int ftrylockfile (FILE *stream);</strong></p>
<p>If stream is currently
        locked, ftrylockfile( ) does
        nothing, and immediately returns a nonzero value. If stream is not currently locked, it acquires
        the lock, bumps the lock count, becomes the owning thread of stream, and returns 0.</p>
<p>Let's consider an example:flockfile (stream);

fputs ("List of treasure:\n", stream);
fputs ("    (1) 500 gold coins\n", stream);
fputs ("    (2) Wonderfully ornate dishware\n", stream);

funlockfile (stream);</p>
<p>Although the individual fputs(
        ) operations could never race—for example, we would never
        end up with anything interleaving with "List of treasure"—another
        standard I/O operation from another thread to this same stream could
        interleave between two fputs( )
        calls. Ideally, an application is designed such that multiple threads
        are not submitting I/O to the same stream. If your application does
        need to do so, however, and you need an atomic region greater than a
        single function, flockfile( ) and
        friends can save the day.</p>
<empty-line/>
<p><strong>Unlocked Stream Operations</strong></p>
<p>There is a second reason for performing manual locking on
        streams. With the finer-grained and more precise control of locking
        that only the application programmer can provide, it might be possible
        to minimize the overhead of locking, and to improve performance. To
        this end, Linux provides a family of functions, cousins to the usual
        standard I/O interfaces, that do not perform any locking whatsoever.
        They are, in effect, the unlocked counterparts to standard
        I/O:<strong>#define _GNU_SOURCE

#include &lt;stdio.h&gt;

int fgetc_unlocked (FILE *stream);
char *fgets_unlocked (char *str, int size, FILE *stream);
size_t fread_unlocked (void *buf, size_t size, size_t nr,
                       FILE *stream);
int fputc_unlocked (int c, FILE *stream);
int fputs_unlocked (const char *str, FILE *stream);
size_t fwrite_unlocked (void *buf, size_t size, size_t nr,
                        FILE *stream);
int fflush_unlocked (FILE *stream);
int feof_unlocked (FILE *stream);
int ferror_unlocked (FILE *stream);
int fileno_unlocked (FILE *stream);
void clearerr_unlocked (FILE *stream);</strong></p>
<p>These functions all behave identically to their locked cousins,
        except that they do not check for or acquire the lock associated with
        the given stream. If locking is
        required, it is the responsibility of the programmer to ensure that
        the lock is manually acquired and released.</p>
<p>Although POSIX does define some unlocked variants of the
        standard I/O functions, none of the above functions are defined by
        POSIX. They are all Linux-specific, although various other Unix
        systems support a subset.</p>
<empty-line/>
<p><strong>Critiques of Standard I/O</strong></p>
<p>As widely used as standard I/O is, some experts point to flaws in
      it. Some of the functions, such as fgets(
      ), are occasionally inadequate. Other functions, such as
      gets( ), are so horrendous that they
      have been all but evicted from the standards.</p>
<p>The biggest complaint with standard I/O is the performance impact
      from the double copy. When reading data, standard I/O issues a read( ) system call to the kernel, copying the
      data from the kernel to the standard I/O buffer. When an application
      then issues a read request via standard I/O—say, using fgetc( )—the data is copied again, this time
      from the standard I/O buffer to the supplied buffer. Write requests work
      in the opposite fashion: the data is copied once from the supplied
      buffer to the standard I/O buffer, and then later from the standard I/O
      buffer to the kernel via write(
      ).</p>
<p>An alternative implementation could avoid the double copy by
      having each read request return a pointer into the standard I/O buffer.
      The data could then be read directly, inside of the standard I/O buffer,
      without ever needing an extraneous copy. In the event that the
      application did want the data in its own local buffer—perhaps to write
      to it—it could always perform the copy manually. This implementation
      would provide a "free" interface, allowing applications to signal when
      they are done with a given chunk of the read buffer.</p>
<p>Writes would be a bit more complicated, but the double copy could
      still be avoided. When issuing a write request, the implementation would
      record the pointer. Ultimately, when ready to flush the data to the
      kernel, the implementation could walk its list of stored pointers,
      writing out the data. This could be done using scatter-gather I/O, via
      writev( ), and thus only a single
      system call. (We will discuss scatter-gather I/O in the next
      chapter.)</p>
<p>Highly optimal user-buffering libraries exist, solving the double
      copy problem with implementations similar to what we've just discussed.
      Alternatively, some developers choose to implement their own
      user-buffering solutions. But despite these alternatives, standard I/O
      remains popular.</p>
<empty-line/>
<p><strong>Conclusion</strong></p>
<p>Standard I/O is a user-buffering library provided as part of the
      standard C library. Modulo a few flaws, it is a powerful and very
      popular solution. Many C programmers, in fact, know nothing but standard
      I/O. Certainly, for terminal I/O, where line-based buffering is ideal,
      standard I/O is the only game in town. Who has ever directly used
      write( ) to print to standard
      out?</p>
<p>Standard I/O—and user buffering in general, for that matter—makes
      sense when any of the following are true:</p>
<p>You could conceivably issue many system calls, and you want to
          minimize the overhead by combining many calls into few.</p>
<p>Performance is crucial, and you want to ensure that all I/O
          occurs in block-sized chunks on block-aligned boundaries.</p>
<p>Your access patterns are character- or line-based, and you
          want interfaces to make such access easy without issuing extraneous
          system calls.</p>
<p>You prefer a higher-level interface to the low-level Linux
          system calls.</p>
<p>The most flexibility, however, exists when you work directly with
      the Linux system calls. In the next chapter, we will look at advanced
      forms of I/O and the associated system calls.</p>
<empty-line/><empty-line/>
<p><sup>[13] </sup><sup>*</sup> Normally, eliminating locking
          will lead to an assortment of problems. But some programs might
          explicitly implement their thread usage to delegate all I/O to a
          single thread. In that case, there is no need for the overhead of
          locking.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 4. Advanced File I/O</strong></p>
<p>In Chapter 2, we looked at the basic I/O
    system calls in Linux. These calls form not only the basis of file I/O,
    but also the foundation of virtually all communication on Linux. In Chapter 3, we looked at how user-space buffering
    is often needed on top of the basic I/O system calls, and we studied a
    specific user-space buffering solution, C's standard I/O library. In this
    chapter, we'll look at the more advanced I/O system calls that Linux
    provides:</p>
<p><emphasis>Scatter/gather I/O</emphasis></p>
<p>Allows a single call to read or write data to and from many
          buffers at once; useful for bunching together fields of different
          data structures to form one I/O transaction.<emphasis>Epoll</emphasis></p>
<p>Improves on the poll( ) and
          select( ) system calls described
          in Chapter 2; useful when hundreds of file
          descriptors have to be polled in a single program.<emphasis>Memory-mapped I/O</emphasis></p>
<p>Maps a file into memory, allowing file I/O to occur via simple
          memory manipulation; useful for certain patterns of I/O.<emphasis>File advice</emphasis></p>
<p>Allows a process to provide hints to the kernel on its usage
          scenarios; can result in improved I/O performance.<emphasis>Asynchronous I/O</emphasis></p>
<p>Allows a process to issue I/O requests without waiting for
          them to complete; useful for juggling heavy I/O workloads without
          the use of threads.</p>
<p>The chapter will conclude with a discussion of performance
    considerations and the kernel's I/O subsystems.</p>
<empty-line/>
<p><strong>Scatter/Gather I/O</strong></p>
<p><emphasis>Scatter/gather I/O</emphasis> is a method of input and
      output where a single system call writes to a vector of buffers from a
      single data stream, or, alternatively, reads into a vector of buffers
      from a single data stream. This type of I/O is so named because the data
      is <emphasis>scattered into</emphasis> or <emphasis>gathered
      from</emphasis> the given vector of buffers. An alternative name for
      this approach to input and output is <emphasis>vectored I/O</emphasis>.
      In comparison, the standard read and write system calls that we covered
      in Chapter 2 provide <emphasis>linear
      I/O</emphasis>.</p>
<p>Scatter/gather I/O provides several advantages over linear I/O
      methods:</p>
<p><emphasis>More natural handling</emphasis></p>
<p>If your data is naturally segmented—say, the fields of a
            predefined header file—vectored I/O allows for intuitive
            manipulation.<emphasis>Efficiency</emphasis></p>
<p>A single vectored I/O operation can replace multiple linear
            I/O operations.<emphasis>Performance</emphasis></p>
<p>In addition to a reduction in the number of issued system
            calls, a vectored I/O implementation can provide improved
            performance over a linear I/O implementation via internal
            optimizations.<emphasis>Atomicity</emphasis></p>
<p>Unlike with multiple linear I/O operations, a process can
            execute a single vectored I/O operation with no risk of
            interleaving of an operation from another process.</p>
<p>Both a more natural I/O method and atomicity are achievable
      without a scatter/gather I/O mechanism. A process can concatenate the
      disjoint vectors into a single buffer before writing, and decompose the
      returned buffer into multiple vectors after reading—that is, a
      user-space application can perform the scattering and the gathering
      manually. Such a solution, however, is neither efficient nor fun to
      implement.</p>
<empty-line/>
<p><strong>readv( ) and writev( )</strong></p>
<p>POSIX 1003.1-2001 defines, and Linux implements, a pair of
        system calls that implement scatter/gather I/O. The Linux
        implementation satisfies all of the goals listed in the previous
        section.</p>
<p>The readv( ) function reads
        count segments from the file
        descriptor fd into the buffers
        described by iov:<strong>#include &lt;sys/uio.h&gt;

ssize_t readv (int fd,
               const struct iovec *iov,
               int count);</strong></p>
<p>The writev( ) function writes
        at most count segments from the
        buffers described by iov into the
        file descriptor fd:<strong>#include &lt;sys/uio.h&gt;

ssize_t writev (int fd,
                const struct iovec *iov,
                int count);</strong></p>
<p>The readv( ) and writev( ) functions behave the same as
        read( ) and write( ), respectively, except that multiple
        buffers are read from or written to.</p>
<p>Each iovec structure
        describes an independent disjoint buffer, which is called a
        <emphasis>segment</emphasis>:<strong>#include &lt;sys/uio.h&gt;

struct iovec {
       void *iov_base;    /* pointer to start of buffer */
       size_t iov_len;    /* size of buffer in bytes */

};</strong></p>
<p>A set of segments is called a <emphasis>vector</emphasis>. Each
        segment in the vector describes the address and length of a buffer in
        memory to or from which data should be written or read. The readv( ) function fills each buffer of
        iov_len bytes completely before
        proceeding to the next buffer. The writev(
        ) function always writes out all full iov_len bytes before proceeding to the next
        buffer. Both functions always operate on the segments in order,
        starting with iov[0], then iov[1], and so on, through iov[count-1].</p>
<empty-line/>
<p><strong>Return values</strong></p>
<p>On success, readv( ) and
          writev( ) return the number of
          bytes read or written, respectively. This number should be the sum
          of all count iov_len values. On
          error, the system calls return −1, and set errno as appropriate. These system calls
          can experience any of the errors of the read( ) and write( ) system calls, and will, upon
          receiving such errors, set the same errno codes. In addition, the standards
          define two other error situations.</p>
<p>First, because the return type is an ssize_t, if the sum of all count iov_len values is greater than
          SSIZE_MAX, no data will be
          transferred, −1 will be returned,
          and errno will be set to EINVAL.</p>
<p>Second, POSIX dictates that count must be larger than zero, and less
          than or equal to IOV_MAX, which
          is defined in &lt;limits.h&gt;.
          In Linux, IOV_MAX is currently
          1024. If count is 0, the system calls return 0<sup>[14]</sup>. If count is
          greater than IOV_MAX, no data is
          transferred, the calls return −1,
          and errno is set to EINVAL.</p>
<p><strong>Optimizing the Count</strong></p>
<p>During a vectored I/O operation, the Linux kernel must
            allocate internal data structures to represent each segment.
            Normally, this allocation would occur dynamically, based on the
            size of count. As an
            optimization, however, the Linux kernel creates a small array of
            segments on the stack that it uses if count is sufficiently small, negating
            the need to dynamically allocate the segments, and thereby
            providing a small boost in performance. This threshold is
            currently eight, so if count is
            less than or equal to 8, the
            vectored I/O operation occurs in a very memory-efficient manner
            off of the process' kernel stack.</p>
<p>Most likely, you won't have a choice about how many segments
            you need to transfer at once in a given vectored I/O operation. If
            you are flexible, however, and are debating over a small value,
            choosing a value of eight or less definitely improves
            efficiency.</p>
<empty-line/>
<p><strong>writev( ) example</strong></p>
<p>Let's consider a simple example that writes out a vector of
          three segments, each containing a string of a different size. This
          self-contained program is complete enough to demonstrate writev( ), yet simple enough to serve as a
          useful code snippet:#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/uio.h&gt;

int main (  )
{
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        char *buf[] = {
                "The term buccaneer comes from the word boucan.\n",
                "A boucan is a wooden frame used for cooking meat.\n",
                "Buccaneer is the West Indies name for a pirate.\n" };

        fd = open ("buccaneer.txt", O_WRONLY | O_CREAT | O_TRUNC);
        if (fd == −1) {
                perror ("open");
                return 1;
        }

        /* fill out three iovec structures */
        for (i = 0; i &lt; 3; i++) {
                iov[i].iov_base = buf[i];
                iov[i].iov_len = strlen(buf[i]) + 1;
        }
        /* with a single call, write them all out */
        nr = writev (fd, iov, 3);
        if (nr == −1) {
                perror ("writev");
                return 1;
        }
        printf ("wrote %d bytes\n", nr);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}</p>
<p>Running the program produces the desired result:$ ./writev
wrote 148 bytes</p>
<p>As does reading the file:$ cat buccaneer.txt
The term buccaneer comes from the word boucan.
A boucan is a wooden frame used for cooking meat.
Buccaneer is the West Indies name for a pirate.</p>
<empty-line/>
<p><strong>readv( ) example</strong></p>
<p>Now, let's consider an example program that uses the readv( ) system call to read from the
          previously generated text file using vectored I/O. This
          self-contained example is likewise simple yet complete:#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/uio.h&gt;

int main (  )
{
        char foo[48], bar[51], baz[49];
        struct iovec iov[3];
        ssize_t nr;
        int fd, i;

        fd = open ("buccaneer.txt", O_RDONLY);
        if (fd == −1) {
                perror ("open");
                return 1;
        }

        /* set up our iovec structures */
        iov[0].iov_base = foo;
        iov[0].iov_len = sizeof (foo);
        iov[1].iov_base = bar;
        iov[1].iov_len = sizeof (bar);
        iov[2].iov_base = baz;
        iov[2].iov_len = sizeof (baz);

        /* read into the structures with a single call */
        nr = readv (fd, iov, 3);
        if (nr == −1) {
                perror ("readv");
                return 1;
        }

        for (i = 0; i &lt; 3; i++)
                printf ("%d: %s", i, (char *) iov[i].iov_base);

        if (close (fd)) {
                perror ("close");
                return 1;
        }

        return 0;
}</p>
<p>Running this program after running the previous program
          produces the following results:$ ./readv
0: The term buccaneer comes from the word boucan.
1: A boucan is a wooden frame used for cooking meat.
2: Buccaneer is the West Indies name for a pirate.</p>
<empty-line/>
<p><strong>Implementation</strong></p>
<p>A naïve implementation of readv(
          ) and writev( ) could
          be done in user space as a simple loop, something similar to the
          following:#include &lt;unistd.h&gt;
#include &lt;sys/uio.h&gt;

ssize_t naive_writev (int fd, const struct iovec *iov, int count)
{
        ssize_t ret = 0;
        int i;

        for (i = 0; i &lt; count; i++) {
                ssize_t nr;

                nr = write (fd, iov[i].iov_base, iov[i].iov_len);
                if (nr == −1) {
                        ret = −1;
                        break;
                }
                ret += nr;
        }

        return ret;
}</p>
<p>Thankfully, this is <emphasis>not</emphasis> the Linux
          implementation: Linux implements readv(
          ) and writev( ) as
          system calls, and internally performs scatter/gather I/O. In fact,
          all I/O inside the Linux kernel is vectored; read( ) and write( ) are implemented as vectored I/O
          with a vector of only one segment.</p>
<empty-line/>
<p><strong>The Event Poll Interface</strong></p>
<p>Recognizing the limitations of both poll(
      ) and select( ), the 2.6
      Linux kernel<sup>[15]</sup> introduced the <emphasis>event poll</emphasis> (epoll)
      facility. While more complex than the two earlier interfaces, epoll
      solves the fundamental performance problem shared by both of them, and
      adds several new features.</p>
<p>Both poll( ) and select( ) (discussed in Chapter 2) require the full list of file descriptors
      to watch on each invocation. The kernel must then walk the list of each
      file descriptor to be monitored. When this list grows large—it may
      contain hundreds or even thousands of file descriptors—walking the list
      on each invocation becomes a scalability bottleneck.</p>
<p>Epoll circumvents this problem by decoupling the monitor
      registration from the actual monitoring. One system call initializes an
      epoll context, another adds monitored file descriptors to or removes
      them from the context, and a third performs the actual event
      wait.</p>
<empty-line/>
<p><strong>Creating a New Epoll Instance</strong></p>
<p>An epoll context is created via epoll_create( ):<strong>#include &lt;sys/epoll.h&gt;

int epoll_create (int size)</strong></p>
<p>A successful call to epoll_create(
        ) instantiates a new epoll instance, and returns a file
        descriptor associated with the instance. This file descriptor has no
        relationship to a real file; it is just a handle to be used with
        subsequent calls using the epoll facility. The size parameter is a hint to the kernel about
        the number of file descriptors that are going to be monitored; it is
        not the maximum number. Passing in a good approximation will result in
        better performance, but the exact number is not required. On error,
        the call returns −1, and sets
        errno to one of the
        following:</p>
<p>EINVAL</p>
<p>The size parameter is
              not a positive number.ENFILE</p>
<p>The system has reached the limit on the total number of
              open files.ENOMEM</p>
<p>Insufficient memory was available to complete the
              operation.</p>
<p>A typical call is:int epfd;

epfd = epoll_create (100);  /* plan to watch ~100 fds */
if (epfd &lt; 0)
        perror ("epoll_create");</p>
<p>The file descriptor returned from epoll_create( ) should be destroyed via a
        call to close( ) after polling is
        finished.</p>
<empty-line/>
<p><strong>Controlling Epoll</strong></p>
<p>The epoll_ctl( ) system call
        can be used to add file descriptors to and remove file descriptors
        from a given epoll context:<strong>#include &lt;sys/epoll.h&gt;

int epoll_ctl (int epfd,
               int op,
               int fd,
               struct epoll_event *event);</strong></p>
<p>The header &lt;sys/epoll.h&gt; defines the epoll_event structure as:struct epoll_event {
        _  _u32 events;  /* events */
        union {
                void *ptr;
                int fd;
                _  _u32 u32;
                _  _u64 u64;
        } data;
};</p>
<p>A successful call to epoll_ctl(
        ) controls the epoll instance associated with the file
        descriptor epfd. The parameter
        op specifies the operation to be
        taken against the file associated with fd. The event parameter further describes the
        behavior of the operation.</p>
<p>Here are valid values for the op parameter:</p>
<p>EPOLL_CTL_ADD</p>
<p>Add a monitor on the file associated with the file
              descriptor fd to the epoll instance associated with
              epfd, per the events defined
              in event.EPOLL_CTL_DEL</p>
<p>Remove a monitor on the file associated with the file
              descriptor fd from the epoll
              instance associated with epfd.EPOLL_CTL_MOD</p>
<p>Modify an existing monitor of fd with the updated events specified
              by event.</p>
<p>The events field in the
        epoll_event structure lists which
        events to monitor on the given file descriptor. Multiple events can be
        bitwise-ORed together. Here are valid values:</p>
<p>EPOLLERR</p>
<p>An error condition occurred on the file. This event is
              always monitored, even if it's not specified.EPOLLET</p>
<p>Enables edge-triggered behavior for the monitor of the
              file (see the upcoming section "Edge- Versus Level-Triggered Events"). The default
              behavior is level-triggered.EPOLLHUP</p>
<p>A hangup occurred on the file. This event is always
              monitored, even if it's not specified.EPOLLIN</p>
<p>The file is available to be read from without
              blocking.EPOLLONESHOT</p>
<p>After an event is generated and read, the file is
              automatically no longer monitored. A new event mask must be
              specified via EPOLL_CTL_MOD
              to reenable the watch.EPOLLOUT</p>
<p>The file is available to be written to without
              blocking.EPOLLPRI</p>
<p>There is urgent out-of-band data available to read.</p>
<p>The data field inside the
        event_poll structure is for the
        user's private use. The contents are returned to the user upon receipt
        of the requested event. The common practice is to set event.data.fd to fd, which makes it easy to look up which
        file descriptor caused the event.</p>
<p>Upon success, epoll_ctl( )
        returns 0. On failure, the call
        returns −1, and sets errno to one of the following values:</p>
<p>EBADF</p>
<p>epfd is not a valid
              epoll instance, or fd is not
              a valid file descriptor.EEXIST</p>
<p>op was EPOLL_CTL_ADD, but fd is already associated with epfd.EINVAL</p>
<p>epfd is not an epoll
              instance, epfd is the same as
              fd, or op is invalid.ENOENT</p>
<p>op was EPOLL_CTL_MOD, or EPOLL_CTL_DEL, but fd is not associated with epfd.ENOMEM</p>
<p>There was insufficient memory to process the
              request.EPERM</p>
<p>fd does not support
              epoll.</p>
<p>As an example, to add a new watch on the file associated with
        fd to the epoll instance epfd, you would write:struct epoll_event event;
int ret;

event.data.fd = fd; /* return the fd to us later */
event.events = EPOLLIN | EPOLLOUT;

ret = epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &amp;event);
if (ret)
        perror ("epoll_ctl");</p>
<p>To modify an existing event on the file associated with fd on the epoll instance epfd, you would write:struct epoll_event event;
int ret;

event.data.fd = fd; /* return the fd to us later */
event.events = EPOLLIN;

ret = epoll_ctl (epfd, EPOLL_CTL_MOD, fd, &amp;event);
if (ret)
        perror ("epoll_ctl");</p>
<p>Conversely, to remove an existing event on the file associated
        with fd from the epoll instance
        epfd, you would write:struct epoll_event event;
int ret;

ret = epoll_ctl (epfd, EPOLL_CTL_DEL, fd, &amp;event);
if (ret)
        perror ("epoll_ctl");</p>
<p>Note that the event parameter
        can be NULL when op is EPOLL_CTL_DEL, as there is no event mask to
        provide. Kernel versions before 2.6.9, however, erroneously check for
        this parameter to be non-NULL. For
        portability to these older kernels, you should pass in a valid
        non-NULL pointer; it will not be
        touched. Kernel 2.6.9 fixed this bug.</p>
<empty-line/>
<p><strong>Waiting for Events with Epoll</strong></p>
<p>The system call epoll_wait( )
        waits for events on the file descriptors associated with the given
        epoll instance:<strong>#include &lt;sys/epoll.h&gt;

int epoll_wait (int epfd,
                struct epoll_event *events,
                int maxevents,
                int timeout);</strong></p>
<p>A call to epoll_wait( ) waits
        up to timeout milliseconds for
        events on the files associated with the epoll instance epfd. Upon success, events points to memory containing epoll_event structures describing each
        event, up to a maximum of maxevents
        events. The return value is the number of events, or −1 on error, in which case errno is set to one of the following:</p>
<p>EBADF</p>
<p>epfd is not a valid
              file descriptor.EFAULT</p>
<p>The process does not have write access to the memory
              pointed at by events.EINTR</p>
<p>The system call was interrupted by a signal before it
              could complete.EINVAL</p>
<p>epfd is not a valid
              epoll instance, or maxevents
              is equal to or less than 0.</p>
<p>If timeout is 0, the call returns immediately, even if no
        events are available, in which case the call will return 0. If the timeout is −1, the call will not return until an event
        is available.</p>
<p>When the call returns, the events field of the epoll_event structure describes the events
        that occurred. The data field
        contains whatever the user set it to before invocation of epoll_ctl( ).</p>
<p>A full epoll_wait( ) example
        looks like this:#define MAX_EVENTS    64

struct epoll_event *events;
int nr_events, i, epfd;

events = malloc (sizeof (struct epoll_event) * MAX_EVENTS);
if (!events) {
        perror ("malloc");
        return 1;
}

nr_events = epoll_wait (epfd, events, MAX_EVENTS, −1);
if (nr_events &lt; 0) {
        perror ("epoll_wait");
        free (events);
        return 1;
}

for (i = 0; i &lt; nr_events; i++) {
        printf ("event=%ld on fd=%d\n",
                events[i].events,
                events[i].data.fd);

        /*
         * We now can, per events[i].events, operate on
         * events[i].data.fd without blocking.
         */
}

free (events);</p>
<p>We will cover the functions malloc(
        ) and free( ) in Chapter 8.</p>
<empty-line/>
<p><strong>Edge- Versus Level-Triggered Events</strong></p>
<p>If the EPOLLET value is set
        in the events field of the event parameter passed to epoll_ctl( ), the watch on fd is <emphasis>edge-triggered</emphasis>,
        as opposed to <emphasis>level-triggered</emphasis>.</p>
<p>Consider the following events between a producer and a consumer
        communicating over a Unix pipe:</p>
<p>The producer writes 1 KB of data onto a pipe.</p>
<p>The consumer performs an epoll_wait( ) on the pipe, waiting for
            the pipe to contain data, and thus be readable.</p>
<p>With a level-triggered watch, the call to epoll_wait( ) in step 2 will return
        immediately, showing that the pipe is ready to read. With an
        edge-triggered watch, this call will not return until after step 1
        occurs. That is, even if the pipe is readable at the invocation of
        epoll_wait( ), the call will not
        return until the data is written onto the pipe.</p>
<p>Level-triggered is the default behavior. It is how poll( ) and select(
        ) behave, and it is what most developers expect.
        Edge-triggered behavior requires a different approach to programming,
        commonly utilizing nonblocking I/O, and careful checking for EAGAIN.</p>
<p><strong>Tip</strong></p>
<p>The terminology comes from electrical engineering. A
          level-triggered interrupt is issued whenever a line is asserted. An
          edge-triggered interrupt is caused only during the rising or falling
          edge of the change in assertion. Level-triggered interrupts are
          useful when the state of the event (the asserted line) is of
          interest. Edge-triggered interrupts are useful when the event itself
          (the line being asserted) is of interest.</p>
<empty-line/>
<p><strong>Mapping Files into Memory</strong></p>
<p>As an alternative to standard file I/O, the kernel provides an
      interface that allows an application to map a file into memory, meaning
      that there is a one-to-one correspondence between a memory address and a
      word in the file. The programmer can then access the file directly
      through memory, identically to any other chunk of memory-resident
      data—it is even possible to allow writes to the memory region to
      transparently map back to the file on disk.</p>
<p>POSIX.1 standardizes—and Linux implements—the mmap( ) system call for mapping objects into
      memory. This section will discuss mmap(
      ) as it pertains to mapping files into memory to perform I/O;
      in Chapter 8, we will visit other
      applications of mmap( ).</p>
<empty-line/>
<p><strong>mmap( )</strong></p>
<p>A call to mmap( ) asks the
        kernel to map len bytes of the
        object represented by the file descriptor fd, starting at offset bytes into the file, into memory. If
        addr is included, it indicates a
        preference to use that starting address in memory. The access
        permissions are dictated by prot,
        and additional behavior can be given by flags:<strong>#include &lt;sys/mman.h&gt;

void * mmap (void *addr,
             size_t len,
             int prot,
             int flags,
             int fd,
             off_t offset);</strong></p>
<p>The addr parameter offers a
        suggestion to the kernel of where best to map the file. It is only a
        hint; most users pass 0. The call
        returns the actual address in memory where the mapping begins.</p>
<p>The prot parameter describes
        the desired memory protection of the mapping. It may be either
        PROT_NONE, in which case the pages
        in this mapping may not be accessed (making little sense!), or a
        bitwise OR of one or more of the following flags:</p>
<p>PROT_READ</p>
<p>The pages may be read.PROT_WRITE</p>
<p>The pages may be written.PROT_EXEC</p>
<p>The pages may be executed.</p>
<p>The desired memory protection must not conflict with the open
        mode of the file. For example, if the program opens the file
        read-only, prot must not specify
        PROT_WRITE.</p>
<p><strong>Protection Flags, Architectures, and Security</strong></p>
<p>While POSIX defines four protection bits (read, write,
          execute, and stay the heck away), some architectures support only a
          subset of these. It is common, for example, for a processor to not
          differentiate between the actions of reading and executing. In that
          case, the processor may have only a single "read" flag. On those
          systems, PROT_READ implies
          PROT_EXEC. Until recently, the
          x86 architecture was one such system.</p>
<p>Of course, relying on such behavior is not portable. Portable
          programs should always set PROT_EXEC if they intend to execute code
          in the mapping.</p>
<p>The reverse situation is one reason for the prevalence of
          buffer overflow attacks: even if a given mapping does not specify
          execution permission, the processor may allow execution
          anyway.</p>
<p>Recent x86 processors have introduced the
          <emphasis>NX</emphasis> (no-execute) bit, which allows for readable,
          but not executable, mappings. On these newer systems, PROT_READ no longer implies PROT_EXEC.</p>
<p>The flags argument describes
        the type of mapping, and some elements of its behavior. It is a
        bitwise OR of the following values:</p>
<p>MAP_FIXED</p>
<p>Instructs mmap( ) to
              treat addr as a requirement,
              not a hint. If the kernel is unable to place the mapping at the
              given address, the call fails. If the address and length
              parameters overlap an existing mapping, the overlapped pages are
              discarded and replaced by the new mapping. As this option
              requires intimate knowledge of the process address space, it is
              nonportable, and its use is discouraged.MAP_PRIVATE</p>
<p>States that the mapping is not shared. The file is mapped
              copy-on-write, and any changes made in memory by this process
              are not reflected in the actual file, or in the mappings of
              other processes.MAP_SHARED</p>
<p>Shares the mapping with all other processes that map this
              same file. Writing into the mapping is equivalent to writing to
              the file. Reads from the mapping will reflect the writes of
              other processes.</p>
<p>Either MAP_SHARED or MAP_PRIVATE must be specified, but not both.
        Other, more advanced flags are discussed in Chapter 8.</p>
<p>When you map a file descriptor, the file's reference count is
        incremented. Therefore, you can close the file descriptor after
        mapping the file, and your process will still have access to it. The
        corresponding decrement of the file's reference count will occur when
        you unmap the file, or when the process terminates.</p>
<p>As an example, the following snippet maps the file backed by
        fd, beginning with its first byte,
        and extending for len bytes, into a
        read-only mapping:void *p;

p = mmap (0, len, PROT_READ, MAP_SHARED, fd, 0);
if (p == MAP_FAILED)
        perror ("mmap");</p>
<p>Figure 4-1 shows
        the effects of paramaters supplied with mmap(
        ) on the mapping between a file and a process' address
        space.</p>
<p><image l:href="#img_2"/></p>
<p><emphasis>Figure 4-1. Mapping a file into a process' address space</emphasis></p>
<empty-line/>
<p><strong>The page size</strong></p>
<p>The <emphasis>page</emphasis> is the smallest unit of memory
          that can have distinct permissions and behavior. Consequently, the
          page is the building block of memory mappings, which in turn are the
          building blocks of the process address space.</p>
<p>The mmap( ) system call
          operates on pages. Both the addr
          and offset parameters must be
          aligned on a page-sized boundary. That is, they must be integer
          multiples of the page size.</p>
<p>Mappings are, therefore, integer multiples of pages. If the
          len parameter provided by the
          caller is not aligned on a page boundary—perhaps because the
          underlying file's size is not a multiple of the page size—the
          mapping is rounded up to the next full page. The bytes inside this
          added memory, between the last valid byte and the end of the
          mapping, are zero-filled. Any read from that region will return
          zeros. Any writes to that memory will not affect the backing file,
          even if it is mapped as MAP_SHARED. Only the original len bytes are ever written back to the
          file.</p>
<empty-line/>
<p>sysconf( )</p>
<p>The standard POSIX method of obtaining the page size is with
            sysconf( ), which can retrieve
            a variety of system-specific information:<strong>#include &lt;unistd.h&gt;

long sysconf (int name);</strong></p>
<p>A call to sysconf( )
            returns the value of the configuration item name, or −1 if name is invalid. On error, the call sets
            errno to EINVAL. Because −1 may be a valid value for some items
            (e.g., limits, where −1 means
            no limit), it may be wise to clear errno before invocation, and check its
            value after.</p>
<p>POSIX defines _SC_PAGESIZE (and a synonym, _SC_PAGE_SIZE) to be the size of a page,
            in bytes. Therefore, getting the page size is simple:long page_size = sysconf (_SC_PAGESIZE);</p>
<empty-line/>
<p>getpagesize( )</p>
<p>Linux also provides the getpagesize( ) function:<strong>#include &lt;unistd.h&gt;

int getpagesize (void);</strong></p>
<p>A call to getpagesize( )
            will likewise return the size of a page, in bytes. Usage is even
            simpler than sysconf( ):int page_size = getpagesize (  );</p>
<p>Not all Unix systems support this function; it's been
            dropped from the 1003.1-2001 revision of the POSIX standard. It is
            included here for completeness.</p>
<empty-line/>
<p>PAGE_SIZE</p>
<p>The page size is also stored statically in the macro
            PAGE_SIZE, which is defined in
            &lt;asm/page.h&gt;. Thus, a
            third possible way to retrieve the page size is:int page_size = PAGE_SIZE;</p>
<p>Unlike the first two options, however, this approach
            retrieves the system page size at compile-time, and not runtime.
            Some architectures support multiple machine types with different
            page sizes, and some machine types even support multiple page
            sizes themselves! A single binary should be able to run on all
            machine types in a given architecture—that is, you should be able
            to build it once and run it everywhere. Hard-coding the page size
            would nullify that possibility. Consequently, you should determine
            the page size at runtime. Because addr and offset are usually 0, this requirement is not overly
            difficult to meet.</p>
<p>Moreover, future kernel versions will likely not export this
            macro to user space. We cover it in this chapter due to its
            frequent presence in Unix code, but you should not use it in your
            own programs. The sysconf( )
            approach is your best bet.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, a call to mmap(
          ) returns the location of the mapping. On failure, the
          call returns MAP_FAILED, and sets
          errno appropriately. A call to
          mmap( ) never returns 0.</p>
<p>Possible errno values
          include:</p>
<p>EACCESS</p>
<p>The given file descriptor is not a regular file, or the
                mode with which it was opened conflicts with prot or flags.EAGAIN</p>
<p>The file has been locked via a file lock.EBADF</p>
<p>The given file descriptor is not valid.EINVAL</p>
<p>One or more of the parameters addr, len, or off are invalid.ENFILE</p>
<p>The system-wide limit on open files has been
                reached.ENODEV</p>
<p>The filesystem on which the file to map resides does not
                support memory mapping.ENOMEM</p>
<p>The process does not have enough memory.EOVERFLOW</p>
<p>The result of addr+len exceeds the size of the
                address space.EPERM</p>
<p>PROT_EXEC was given,
                but the filesystem is mounted noexec.</p>
<empty-line/>
<p><strong>Associated signals</strong></p>
<p>Two signals are associated with mapped regions:</p>
<p>SIGBUS</p>
<p>This signal is generated when a process attempts to
                access a region of a mapping that is no longer valid—for
                example, because the file was truncated after it was
                mapped.SIGSEGV</p>
<p>This signal is generated when a process attempts to
                write to a region that is mapped read-only.</p>
<empty-line/>
<p><strong>munmap( )</strong></p>
<p>Linux provides the munmap( )
        system call for removing a mapping created with mmap( ):<strong>#include &lt;sys/mman.h&gt;

int munmap (void *addr, size_t len);</strong></p>
<p>A call to munmap( ) removes
        any mappings that contain pages located anywhere in the process
        address space starting at addr,
        which must be page-aligned, and continuing for len bytes. Once the mapping has been
        removed, the previously associated memory region is no longer valid,
        and further access attempts result in a SIGSEGV signal.</p>
<p>Normally, munmap( ) is passed
        the return value and the len
        parameter from a previous invocation of mmap(
        ).</p>
<p>On success, munmap( ) returns
        0; on failure, it returns −1, and errno is set appropriately. The only
        standard errno value is EINVAL, which specifies that one or more
        parameters were invalid.</p>
<p>As an example, the following snippet unmaps any memory regions
        with pages contained in the interval [addr,addr+len]:if (munmap (addr, len) == −1)
        perror ("munmap");</p>
<empty-line/>
<p><strong>Mapping Example</strong></p>
<p>Let's consider a simple example program that uses mmap( ) to print a file chosen by the user
        to standard out:#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

int main (int argc, char *argv[])
{
        struct stat sb;
        off_t len;
        char *p;
        int fd;

        if (argc &lt; 2) {
                fprintf (stderr, "usage: %s &lt;file&gt;\n", argv[0]);
                return 1;
        }

        fd = open (argv[1], O_RDONLY);
        if (fd == −1) {
                perror ("open");
                return 1;
        }

        if (fstat (fd, &amp;sb) == −1) {
                perror ("fstat");
                return 1;
        }

        if (!S_ISREG (sb.st_mode)) {
                fprintf (stderr, "%s is not a file\n", argv[1]);
                return 1;
        }

        p = mmap (0, sb.st_size, PROT_READ, MAP_SHARED, fd, 0);
        if (p == MAP_FAILED) {
                perror ("mmap");
                return 1;
        }

        if (close (fd) == −1) {
                perror ("close");
                return 1;
        }

        for (len = 0; len &lt; sb.st_size; len++)
                putchar (p[len]);

        if (munmap (p, sb.st_size) == −1) {
                perror ("munmap");
                return 1;
        }

        return 0;
}</p>
<p>The only unfamiliar system call in this example should be
        fstat( ), which we will cover in
        Chapter 7. All you need to know
        at this point is that fstat( )
        returns information about a given file. The S_ISREG( ) macro can check some of this
        information, so that we can ensure that the given file is a regular
        file (as opposed to a device file or a directory) before we map it.
        The behavior of nonregular files when mapped depends on the backing
        device. Some device files are mmap-able; other nonregular files are
        not mmap-able, and will set errno
        to EACCESS.</p>
<p>The rest of the example should be straightforward. The program
        is passed a filename as an argument. It opens the file, ensures it is
        a regular file, maps it, closes it, prints the file byte-by-byte to
        standard out, and then unmaps the file from memory.</p>
<empty-line/>
<p><strong>Advantages of mmap( )</strong></p>
<p>Manipulating files via mmap(
        ) has a handful of advantages over the standard read( ) and write(
        ) system calls. Among them are:</p>
<p>Reading from and writing to a memory-mapped file avoids the
            extraneous copy that occurs when using the read( ) or write( ) system calls, where the data
            must be copied to and from a user-space buffer.</p>
<p>Aside from any potential page faults, reading from and
            writing to a memory-mapped file does not incur any system call or
            context switch overhead. It is as simple as accessing
            memory.</p>
<p>When multiple processes map the same object into memory, the
            data is shared among all the processes. Read-only and shared
            writable mappings are shared in their entirety; private writable
            mappings have their not-yet-COW (copy-on-write) pages
            shared.</p>
<p>Seeking around the mapping involves trivial pointer
            manipulations. There is no need for the lseek( ) system call.</p>
<p>For these reasons, mmap( ) is
        a smart choice for many applications.</p>
<empty-line/>
<p><strong>Disadvantages of mmap( )</strong></p>
<p>There are a few points to keep in mind when using mmap( ):</p>
<p>Memory mappings are always an integer number of pages in
            size. Thus, the difference between the size of the backing file
            and an integer number of pages is "wasted" as slack space. For
            small files, a significant percentage of the mapping may be
            wasted. For example, with 4 KB pages, a 7 byte mapping wastes
            4,089 bytes.</p>
<p>The memory mappings must fit into the process' address
            space. With a 32-bit address space, a very large number of
            various-sized mappings can result in fragmentation of the address
            space, making it hard to find large free contiguous regions. This
            problem, of course, is much less apparent with a 64-bit address
            space.</p>
<p>There is overhead in creating and maintaining the memory
            mappings and associated data structures inside the kernel. This
            overhead is generally obviated by the elimination of the double
            copy mentioned in the previous section, particularly for larger
            and frequently accessed files.</p>
<p>For these reasons, the benefits of mmap( ) are most greatly realized when the
        mapped file is large (and thus any wasted space is a small percentage
        of the total mapping), or when the total size of the mapped file is
        evenly divisible by the page size (and thus there is no wasted
        space).</p>
<empty-line/>
<p><strong>Resizing a Mapping</strong></p>
<p>Linux provides the mremap( )
        system call for expanding or shrinking the size of a given mapping.
        This function is Linux-specific:<strong>#define _GNU_SOURCE

#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

void * mremap (void *addr, size_t old_size,
               size_t new_size, unsigned long flags);</strong></p>
<p>A call to mremap( ) expands
        or shrinks mapping in the region [addr,addr+old_size) to the new size
        new_size. The kernel can
        potentially move the mapping at the same time, depending on the
        availability of space in the process' address space and the value of
        flags.</p>
<p><strong>Tip</strong></p>
<p>The opening [ in [addr,addr+old_size) indicates that the
          region starts with (and includes) the low address, whereas the
          closing ) indicates that the
          region stops just before (does not include) the high address. This
          convention is known as <emphasis>interval
          notation</emphasis>.</p>
<p>The flags parameter can be
        either 0 or MREMAP_MAYMOVE, which specifies that the
        kernel is free to move the mapping, if required, in order to perform
        the requested resizing. A large resizing is more likely to succeed if
        the kernel can move the mapping.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, mremap( )
          returns a pointer to the newly resized memory mapping. On failure,
          it returns MAP_FAILED, and sets
          errno to one of the
          following:</p>
<p>EAGAIN</p>
<p>The memory region is locked, and cannot be
                resized.EFAULT</p>
<p>Some pages in the given range are not valid pages in the
                process' address space, or there was a problem remapping the
                given pages.EINVAL</p>
<p>An argument was invalid.ENOMEM</p>
<p>The given range cannot be expanded without moving (and
                MREMAP_MAYMOVE was not
                given), or there is not enough free space in the process'
                address space.</p>
<p>Libraries such as <emphasis>glibc</emphasis> often use
          mremap( ) to implement an
          efficient realloc( ), which is an
          interface for resizing a block of memory originally obtained via
          malloc( ). For example:void * realloc (void *addr, size_t len)
{
        size_t old_size = look_up_mapping_size (addr);
        void *p;

        p = mremap (addr, old_size, len, MREMAP_MAYMOVE);
        if (p == MAP_FAILED)
                return NULL;
        return p;
}</p>
<p>This would only work if all malloc(
          ) allocations were unique anonymous mappings; nonetheless,
          it stands as a useful example of the performance gains to be had.
          The example assumes the programmer has written a look_up_mapping_size( ) function.</p>
<p>The GNU C library does use mmap(
          ) and family for performing some memory allocations. We
          will look that topic in depth in Chapter 8.</p>
<empty-line/>
<p><strong>Changing the Protection of a Mapping</strong></p>
<p>POSIX defines the mprotect( )
        interface to allow programs to change the permissions of existing
        regions of memory:<strong>#include &lt;sys/mman.h&gt;

int mprotect (const void *addr,
              size_t len,
              int prot);</strong></p>
<p>A call to mprotect( ) will
        change the protection mode for the memory pages contained in [addr,addr+len), where addr is page-aligned. The prot parameter accepts the same values as
        the prot given to mmap( ): PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC. These values are not additive; if
        a region of memory is readable, and prot is set to only PROT_WRITE, the call will make the region
        only writable.</p>
<p>On some systems, mprotect( )
        may operate only on memory mappings previously created via mmap( ). On Linux, mprotect( ) can operate on any region of
        memory.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, mprotect( )
          returns 0. On failure, it returns
          −1, and sets errno to one of the following:</p>
<p>EACCESS</p>
<p>The memory cannot be given the permissions requested by
                prot. This can happen, for
                example, if you attempt to set the mapping of a file opened
                read-only to writable.EINVAL</p>
<p>The parameter addr is
                invalid or not page-aligned.ENOMEM</p>
<p>Insufficient kernel memory is available to satisfy the
                request, or one or more pages in the given memory region are
                not a valid part of the process' address space.</p>
<empty-line/>
<p><strong>Synchronizing a File with a Mapping</strong></p>
<p>POSIX provides a memory-mapped equivalent of the fsync( ) system call that we discussed in
        Chapter 2:<strong>#include &lt;sys/mman.h&gt;

int msync (void *addr, size_t len, int flags);</strong></p>
<p>A call to msync( ) flushes
        back to disk any changes made to a file mapped via mmap( ), synchronizing the mapped file with
        the mapping. Specifically, the file or subset of a file associated
        with the mapping starting at memory address addr and continuing for len bytes is synchronized to disk. The
        addr argument must be page-aligned;
        it is generally the return value from a previous mmap( ) invocation.</p>
<p>Without invocation of msync(
        ), there is no guarantee that a dirty mapping will be
        written back to disk until the file is unmapped. This is different
        from the behavior of write( ),
        where a buffer is dirtied as part of the writing process, and queued
        for writeback to disk. When writing into a memory mapping, the process
        directly modifies the file's pages in the kernel's page cache, without
        kernel involvement. The kernel may not synchronize the page cache and
        the disk anytime soon.</p>
<p>The flags parameter controls
        the behavior of the synchronizing operation. It is a bitwise OR of the
        following values:</p>
<p>MS_ASYNC</p>
<p>Specifies that synchronization should occur
              asynchronously. The update is scheduled, but the msync( ) call returns immediately
              without waiting for the writes to take place.MS_INVALIDATE</p>
<p>Specifies that all other cached copies of the mapping be
              invalidated. Any future access to any mappings of this file will
              reflect the newly synchronized on-disk contents.MS_SYNC</p>
<p>Specifies that synchronization should occur synchronously.
              The msync( ) call will not
              return until all pages are written back to disk.</p>
<p>Either MS_ASYNC or MS_SYNC must be specified, but not
        both.</p>
<p>Usage is simple:if (msync (addr, len, MS_ASYNC) == −1)
        perror ("msync");</p>
<p>This example asynchronously synchronizes (say that 10 times
        fast) to disk the file mapped in the region [addr,addr+len).</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, msync( )
          returns 0. On failure, the call
          returns −1, and sets errno appropriately. The following are
          valid errno values:</p>
<p>EINVAL</p>
<p>The flags parameter
                has both MS_SYNC and
                MS_ASYNC set, a bit other
                than one of the three valid flags is set, or addr is not page-aligned.ENOMEM</p>
<p>The given memory region (or part of it) is not mapped.
                Note that Linux will return ENOMEM, as POSIX dictates, when
                asked to synchronize a region that is only partly unmapped,
                but it will still synchronize any valid mappings in the
                region.</p>
<p>Before version 2.4.19 of the Linux kernel, msync( ) returned EFAULT in place of ENOMEM.</p>
<empty-line/>
<p><strong>Giving Advice on a Mapping</strong></p>
<p>Linux provides a system call named madvise( ) to let processes give the kernel
        advice and hints on how they intend to use a mapping. The kernel can
        then optimize its behavior to take advantage of the mapping's intended
        use. While the Linux kernel dynamically tunes its behavior, and
        generally provides optimal performance without explicit advice,
        providing such advice can ensure the desired caching and readahead
        behavior for some workloads.</p>
<p>A call to madvise( ) advises
        the kernel on how to behave with respect to the pages in the memory
        map starting at addr, and extending
        for len bytes:<strong>#include &lt;sys/mman.h&gt;

int madvise (void *addr,
             size_t len,
             int advice);</strong></p>
<p>If len is 0, the kernel will apply the advice to the
        entire mapping that starts at addr.
        The parameter advice delineates the
        advice, which can be one of:</p>
<p>MADV_NORMAL</p>
<p>The application has no specific advice to give on this
              range of memory. It should be treated as normal.MADV_RANDOM</p>
<p>The application intends to access the pages in the
              specified range in a random (nonsequential) order.MADV_SEQUENTIAL</p>
<p>The application intends to access the pages in the
              specified range sequentially, from lower to higher
              addresses.MADV_WILLNEED</p>
<p>The application intends to access the pages in the
              specified range in the near future.MADV_DONTNEED</p>
<p>The application does not intend to access the pages in the
              specified range in the near future.</p>
<p>The actual behavior modifications that the kernel takes in
        response to this advice are implementation-specific: POSIX dictates
        only the meaning of the advice, not any potential consequences. The
        current 2.6 kernel behaves as follows in response to the advice values:</p>
<p>MADV_NORMAL</p>
<p>The kernel behaves as usual, performing a moderate amount
              of readahead.MADV_RANDOM</p>
<p>The kernel disables readahead, reading only the minimal
              amount of data on each physical read operation.MADV_SEQUENTIAL</p>
<p>The kernel performs aggressive readahead.MADV_WILLNEED</p>
<p>The kernel initiates readahead, reading the given pages
              into memory.MADV_DONTNEED</p>
<p>The kernel frees any resources associated with the given
              pages, and discards any dirty and not-yet-synchronized pages.
              Subsequent accesses to the mapped data will cause the data to be
              paged in from the backing file.</p>
<p>Typical usage is:int ret;

ret = madvise (addr, len, MADV_SEQUENTIAL);
if (ret &lt; 0)
        perror ("madvise");</p>
<p>This call instructs the kernel that the process intends to
        access the memory region [addr,addr+len) sequentially.</p>
<p><strong>Readahead</strong></p>
<p>When the Linux kernel reads files off the disk, it performs an
          optimization known as <emphasis>readahead</emphasis>. That is, when
          a request is made for a given chunk of a file, the kernel also reads
          the following chunk of the file. If a request is subsequently made
          for that chunk—as is the case when reading a file sequentially—the
          kernel can return the requested data immediately. Because disks have
          track buffers (basically, hard disks perform their own readahead
          internally), and because files are generally laid out sequentially
          on disk, this optimization is low-cost.</p>
<p>Some readahead is usually advantageous, but optimal results
          depend on the question of how much readahead to perform. A
          sequentially accessed file may benefit from a larger readahead
          window, while a randomly accessed file may find readahead to be
          worthless overhead.</p>
<p>As discussed in "Kernel Internals" in
          Chapter 2, the kernel dynamically tunes the size of the readahead
          window in response to the hit rate inside that window. More hits
          imply that a larger window would be advantageous; fewer hits suggest
          a smaller window. The madvise( )
          system call allows applications to influence the window size right
          off the bat.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, madvise( )
          returns 0. On failure, it returns
          −1, and errno is set appropriately. The following
          are valid errors:</p>
<p>EAGAIN</p>
<p>An internal kernel resource (probably memory) was
                unavailable. The process can try again.EBADF</p>
<p>The region exists, but does not map a file.EINVAL</p>
<p>The parameter len is
                negative, addr is not
                page-aligned, the advice
                parameter is invalid, or the pages were locked or shared with
                MADV_DONTNEED.EIO</p>
<p>An internal I/O error occurred with MADV_WILLNEED.ENOMEM</p>
<p>The given region is not a valid mapping in this process'
                address space, or MADV_WILLNEED was given, but there
                is insufficient memory to page in the given regions.</p>
<empty-line/>
<p><strong>Advice for Normal File I/O</strong></p>
<p>In the previous subsection, we looked at providing advice on
      memory mappings. In this section, we will look at providing advice to
      the kernel on normal file I/O. Linux provides two interfaces for such
      advice-giving: posix_fadvise( ) and
      readahead( ).</p>
<empty-line/>
<p><strong>The posix_fadvise( ) System Call</strong></p>
<p>The first advice interface, as its name alludes, is standardized
        by POSIX 1003.1-2003:<strong>#include &lt;fcntl.h&gt;

int posix_fadvise (int fd,
                   off_t offset,
                   off_t len,
                   int advice);</strong></p>
<p>A call to posix_fadvise( )
        provides the kernel with the hint advice on the file descriptor fd in the interval [offset,offset+len). If len is 0,
        the advice will apply to the range [offset,length of file]. Common usage is to
        specify 0 for len and offset, applying the advice to the entire
        file.</p>
<p>The available advice options
        are similar to those for madvise(
        ). Exactly one of the following should be provided for
        advice:</p>
<p>POSIX_FADV_NORMAL</p>
<p>The application has no specific advice to give on this
              range of the file. It should be treated as normal.POSIX_FADV_RANDOM</p>
<p>The application intends to access the data in the
              specified range in a random (nonsequential) order.POSIX_FADV_SEQUENTIAL</p>
<p>The application intends to access the data in the
              specified range sequentially, from lower to higher
              addresses.POSIX_FADV_WILLNEED</p>
<p>The application intends to access the data in the
              specified range in the near future.POSIX_FADV_NOREUSE</p>
<p>The application intends to access the data in the
              specified range in the near future, but only once.POSIX_FADV_DONTNEED</p>
<p>The application does not intend to access the pages in the
              specified range in the near future.</p>
<p>As with madvise( ), the
        actual response to the given advice is implementation-specific—even
        different versions of the Linux kernel may react dissimilarly. The
        following are the current responses:</p>
<p>POSIX_FADV_NORMAL</p>
<p>The kernel behaves as usual, performing a moderate amount
              of readahead.POSIX_FADV_RANDOM</p>
<p>The kernel disables readahead, reading only the minimal
              amount of data on each physical read operation.POSIX_FADV_SEQUENTIAL</p>
<p>The kernel performs aggressive readahead, doubling the
              size of the readahead window.POSIX_FADV_WILLNEED</p>
<p>The kernel initiates readahead to begin reading into
              memory the given pages.POSIX_FADV_NOREUSE</p>
<p>Currently, the behavior is the same as for POSIX_FADV_WILLNEED; future kernels
              may perform an additional optimization to exploit the "use once"
              behavior. This hint does not have an madvise( ) complement.POSIX_FADV_DONTNEED</p>
<p>The kernel evicts any cached data in the given range from
              the page cache. Note that this hint, unlike the others, is
              different in behavior from its madvise(
              ) counterpart.</p>
<p>As an example, the following snippet instructs the kernel that
        the entire file represented by the file descriptor fd will be accessed in a random,
        nonsequential manner:int ret;

ret = posix_fadvise (fd, 0, 0, POSIX_FADV_RANDOM);
if (ret == −1)
        perror ("posix_fadvise");</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, posix_fadvise(
          ) returns 0. On
          failure, −1 is returned, and
          errno is set to one of the
          following values:</p>
<p>EBADF</p>
<p>The given file descriptor is invalid.EINVAL</p>
<p>The given advice is invalid, the given file descriptor
                refers to a pipe, or the specified advice cannot be applied to
                the given file.</p>
<empty-line/>
<p><strong>The readahead( ) System Call</strong></p>
<p>The posix_fadvise( ) system
        call is new to the 2.6 Linux kernel. Before, the readahead( ) system call was available to
        provide behavior identical to the POSIX_FADV_WILLNEED hint. Unlike posix_fadvise( ), readahead( ) is a Linux-specific
        interface:<strong>#include &lt;fcntl.h&gt;

ssize_t readahead (int fd,
                   off64_t offset,
                   size_t count);</strong></p>
<p>A call to readahead( )
        populates the page cache with the region [offset,offset+count) from the file
        descriptor fd.</p>
<empty-line/>
<p><strong>Return values and error codes</strong></p>
<p>On success, readahead( )
          returns 0. On failure, it returns
          −1, and errno is set to one of the following
          values:</p>
<p>EBADF</p>
<p>The given file descriptor is invalid.EINVAL</p>
<p>The given file descriptor does not map to a file that
                supports readahead.</p>
<empty-line/>
<p><strong>Advice Is Cheap</strong></p>
<p>A handful of common application workloads can readily benefit
        from a little well-intentioned advice to the kernel. Such advice can
        go a long way toward mitigating the burden of I/O. With hard disks
        being so slow, and modern processors being so fast, every little bit
        helps, and good advice can go a long way.</p>
<p>Before reading a chunk of a file, a process can provide the
        POSIX_FADV_WILLNEED hint to
        instruct the kernel to read the file into the page cache. The I/O will
        occur asynchronously, in the background. When the application
        ultimately accesses the file, the operation can complete without
        generating blocking I/O.</p>
<p>Conversely, after reading or writing a lot of data—say, while
        continuously streaming video to disk—a process can provide the
        POSIX_FADV_DONTNEED hint to
        instruct the kernel to evict the given chunk of the file from the page
        cache. A large streaming operation can continually fill the page
        cache. If the application never intends to access the data again, this
        means the page cache will be filled with superfluous data, at the
        expense of potentially more useful data. Thus, it makes sense for a
        streaming video application to periodically request that streamed data
        be evicted from the cache.</p>
<p>A process that intends to read in an entire file can provide the
        POSIX_FADV_SEQUENTIAL hint,
        instructing the kernel to perform aggressive readahead. Conversely, a
        process that knows it is going to access a file randomly, seeking to
        and fro, can provide the POSIX_FADV_RANDOM hint, instructing the
        kernel that readahead will be nothing but worthless overhead.</p>
<empty-line/>
<p><strong>Synchronized, Synchronous, and Asynchronous Operations</strong></p>
<p>Unix systems use the terms synchronized, nonsynchronized,
      synchronous, and asynchronous freely, without much regard to the fact
      that they are confusing—in English, the differences between
      "synchronous" and "synchronized" do not amount to much!</p>
<p>A <emphasis>synchronous</emphasis> write operation does not return
      until the written data is—<emphasis>at least</emphasis>—stored in the
      kernel's buffer cache. A synchronous read operation does not return
      until the read data is stored in the user-space buffer provided by the
      application. On the other side of the coin, an
      <emphasis>asynchronous</emphasis> write operation may return before the
      data even leaves user space; an asynchronous read operation may return
      before the read data is available. That is, the operations may only be
      queued for later. Of course, in this case, some mechanism must exist for
      determining when the operation has actually completed, and with what
      level of success.</p>
<p>A <emphasis>synchronized</emphasis> operation is more restrictive
      and safer than a merely synchronous operation. A synchronized write
      operation flushes the data to disk, ensuring that the on-disk data is
      always synchronized vis-à-vis the corresponding kernel buffers. A
      synchronized read operation always returns the most up-to-date copy of
      the data, presumably from the disk.</p>
<p>In sum, the terms synchronous and asynchronous refer to whether
      I/O operations wait for some event (e.g., storage of the data) before
      returning. The terms synchronized and nonsynchronized, meanwhile,
      specify exactly <emphasis>what</emphasis> event must occur (e.g.,
      writing the data to disk).</p>
<p>Normally, Unix write operations are synchronous and
      nonsynchronized; read operations are synchronous and
      synchronized.<sup>[16]</sup> For write operations, every combination of these
      characteristics is possible, as Table 4-1 illustrates.</p>
<p><emphasis>Table 4-1. Synchronicity of write operations</emphasis></p>
<p> </p>
<p><strong>Synchronized</strong></p>
<p><strong>Nonsynchronized</strong></p>
<p><strong>Synchronous</strong></p>
<p>Write operations do not
              return until the data is flushed to disk. This is the behavior
              if O_SYNC is specified during
              file open.</p>
<p>Write operations do not
              return until the data is stored in kernel buffers. This is the
              usual behavior.</p>
<p><strong>Asynchronous</strong></p>
<p>Write operations return
              as soon as the request is queued. Once the write operation
              ultimately executes, the data is guaranteed to be on
              disk.</p>
<p>Write operations return
              as soon as the request is queued. Once the write operation
              ultimately executes, the data is guaranteed to at least be
              stored in kernel buffers.</p>
<p>Read operations are always synchronized, as reading stale data
      makes little sense. Such operations can be either synchronous or
      asynchronous, however, as illustrated in Table 4-2.</p>
<p><emphasis>Table 4-2. Synchronicity of read operations</emphasis></p>
<p> </p>
<p><strong>Synchronized</strong></p>
<p><strong>Synchronous</strong></p>
<p>Read operations do not
              return until the data, which is up-to-date, is stored in the
              provided buffer (this is the usual behavior).</p>
<p><strong>Asynchronous</strong></p>
<p>Read operations return as
              soon as the request is queued, but when the read operation
              ultimately executes, the data returned is
              up-to-date.</p>
<p>In Chapter 2, we discussed how to make
      writes synchronized (via the O_SYNC
      flag), and how to ensure that all I/O is synchronized as of a given
      point (via fsync( ) and friends).
      Now, let's look at what it takes to make reads and writes
      asynchronous.</p>
<empty-line/>
<p><strong>Asynchronous I/O</strong></p>
<p>Performing asynchronous I/O requires kernel support at the very
        lowest layers. POSIX 1003.1-2003 defines the <emphasis>aio</emphasis>
        interfaces, which Linux fortunately implements. The
        <emphasis>aio</emphasis> library provides a family of functions for
        submitting asynchronous I/O and receiving notification upon its
        completion:<strong>#include &lt;aio.h&gt;

/* asynchronous I/O control block */
struct aiocb {
        int aio_filedes;              /* file descriptor *
        int aio_lio_opcode;           /* operation to perform */
        int aio_reqprio;              /* request priority offset *
        volatile void *aio_buf;       /* pointer to buffer */
        size_t aio_nbytes;            /* length of operation */
        struct sigevent aio_sigevent; /* signal number and value */

     /* internal, private members follow... */
};

int aio_read (struct aiocb *aiocbp);
int aio_write (struct aiocb *aiocbp);
int aio_error (const struct aiocb *aiocbp);
int aio_return (struct aiocb *aiocbp);
int aio_cancel (int fd, struct aiocb *aiocbp);
int aio_fsync (int op, struct aiocb *aiocbp);
int aio_suspend (const struct aiocb * const cblist[],
                 int n,
                 const struct timespec *timeout);</strong></p>
<empty-line/>
<p><strong>Thread-based asynchronous I/O</strong></p>
<p>Linux only supports <emphasis>aio</emphasis> on files opened
          with the O_DIRECT flag. To
          perform asynchronous I/O on regular files opened without O_DIRECT, we have to look inward, toward a
          solution of our own. Without kernel support, we can only hope to
          approximate asynchronous I/O, giving results similar to the real
          thing.</p>
<p>First, let's look at why an application developer would want
          asynchronous I/O:</p>
<p>To perform I/O without blocking</p>
<p>To separate the acts of queuing I/O, submitting I/O to the
              kernel, and receiving notification of operation
              completion</p>
<p>The first point is a matter of performance. If I/O operations
          never block, the overhead of I/O reaches zero, and a process need
          not be I/O-bound. The second point is a matter of procedure, simply
          a different method of handling I/O.</p>
<p>The most common way to reach these goals is with threads
          (scheduling matters are discussed thoroughly in Chapter 5 and Chapter 6). This approach involves
          the following programming tasks:</p>
<p>Create a pool of "worker threads" to handle all
              I/O.</p>
<p>Implement a set of interfaces for placing I/O operations
              onto a work queue.</p>
<p>Have each of these interfaces return an I/O descriptor
              uniquely identifying the associated I/O operation. In each
              worker thread, grab I/O requests from the head of the queue and
              submit them, waiting for their completion.</p>
<p>Upon completion, place the results of the operation
              (return values, error codes, any read data) onto a results
              queue.</p>
<p>Implement a set of interfaces for retrieving status
              information from the results queue, using the originally
              returned I/O descriptors to identify each operation.</p>
<p>This provides similar behavior to POSIX's
          <emphasis>aio</emphasis> interfaces, albeit with the greater
          overhead of thread management.</p>
<empty-line/>
<p><strong>I/O Schedulers and I/O Performance</strong></p>
<p>In a modern system, the relative performance gap between disks and
      the rest of the system is quite large—and widening. The worst component
      of disk performance is the process of moving the read/write head from
      one part of the disk to another, an operation known as a
      <emphasis>seek</emphasis>. In a world where many operations are measured
      in a handful of processor cycles (which might take all of a third of a
      nanosecond each), a single disk seek can average over eight
      milliseconds—still a small number, to be sure, but <emphasis>25 million
      times longer than a single processor cycle</emphasis>!</p>
<p>Given the disparity in performance between disk drives and the
      rest of the system, it would be incredibly crude and inefficient to send
      I/O requests to the disk in the order in which they are issued.
      Therefore, modern operating system kernels implement <emphasis>I/O
      schedulers</emphasis>, which work to minimize the number and size of
      disk seeks by manipulating the order in which I/O requests are serviced,
      and the times at which they are serviced. I/O schedulers work hard to
      lessen the performance penalties associated with disk access.</p>
<empty-line/>
<p><strong>Disk Addressing</strong></p>
<p>To understand the role of an I/O scheduler, some background
        information is necessary. Hard disks address their data using the
        familiar geometry-based addressing of cylinders, heads, and sectors,
        or <emphasis>CHS addressing</emphasis>. A hard drive is composed of
        multiple <emphasis>platters</emphasis>, each consisting of a single
        disk, spindle, and read/write head. You can think of each platter as a
        CD (or record), and the set of platters in a disk as a stack of CDs.
        Each platter is divided into circular ring-like
        <emphasis>tracks</emphasis>, like on a CD. Each track is then divided
        up into of an integer number of <emphasis>sectors</emphasis>.</p>
<p>To locate a specific unit of data on a disk, the drive's logic
        requires three pieces of information: the cylinder, head, and sector
        values. The cylinder value specifies the track on which the data
        resides. If you lay the platters on top of one another, a given track
        forms a cylinder through each platter. In other words, a cylinder is
        represented by a track at the same distance from the center on each
        disk. The head value identifies the exact read/write head (and thus
        the exact platter) in question. The search is now narrowed down to a
        single track on a single platter. The disk then uses the sector value
        to identify an exact sector on the track. The search is now complete:
        the hard disk knows what platter, what track, and what sector to look
        in for the data. It can position the read/write head of the correct
        platter over the correct track, and read from or write to the
        requisite sector.</p>
<p>Thankfully, modern hard disks do not force computers to
        communicate with their disks in terms of cylinders, heads, and
        sectors. Instead, contemporary hard drives map a unique
        <emphasis>block number</emphasis> (also called <emphasis>physical
        blocks</emphasis> or <emphasis>device blocks</emphasis>) over each
        cylinder/head/sector triplet—effectively, a block maps to a specific
        sector. Modern operating systems can then address hard drives using
        these block numbers—a process known as <emphasis>logical block
        addressing</emphasis> (LBA)—and the hard drive internally translates
        the block number into the correct CHS address.<sup>[17]</sup> Although nothing guarantees it, the block-to-CHS mapping
        tends to be sequential: logical block n tends to be physically adjacent on disk to
        logical block n + 1. This
        sequential mapping is important, as we shall soon see.</p>
<p>Filesystems, meanwhile, exist only in software. They operate on
        their own units, known as <emphasis>logical blocks</emphasis>
        (sometimes called <emphasis>filesystem blocks</emphasis>, or,
        confusingly, just <emphasis>blocks</emphasis>). The logical block size
        must be an integer multiple of the physical block size. In other
        words, a filesystem's logical blocks map to one or more of a disk's
        physical blocks.</p>
<empty-line/>
<p><strong>The Life of an I/O Scheduler</strong></p>
<p>I/O schedulers perform two basic operations: merging and
        sorting. <emphasis>Merging</emphasis> is the process of taking two or
        more adjacent I/O requests, and combining them into a single request.
        Consider two requests, one to read from disk block 5, and another to
        read from disk blocks 6 through 7. These requests can be merged into a
        single request to read from disk blocks 5 through 7. The total amount
        of I/O might be the same, but the number of I/O operations is reduced
        by half.</p>
<p><emphasis>Sorting</emphasis>, the more important of the two
        operations, is the process of arranging pending I/O requests in
        ascending block order. For example, given I/O operations to blocks 52,
        109, and 7, the I/O scheduler would sort these requests into the
        ordering 7, 52, and 109. If a request was then issued to block 81, it
        would be inserted between the requests to blocks 52 and 109. The I/O
        scheduler would then dispatch the requests to the disk in the order
        that they exist in the queue: 7, then 52, then 81, and finally
        109.</p>
<p>In this manner, the disk head's movements are minimized. Instead
        of potentially haphazard movements—here to there and back, seeking all
        over the disk—the disk head moves in a smooth, linear fashion. Because
        seeks are the most expensive part of disk I/O, performance is
        improved.</p>
<empty-line/>
<p><strong>Helping Out Reads</strong></p>
<p>Each read request must return up-to-date data. Thus, if the
        requested data is not in the page cache, the reading process must
        block until the data can be read from disk—a potentially lengthy
        operation. We call this performance impact <emphasis>read
        latency</emphasis>.</p>
<p>A typical application might initiate several read I/O requests
        in a short period. Because each request is individually synchronized,
        the later requests are <emphasis>dependent</emphasis> on the earlier
        ones' completion. Consider reading every file in a directory. The
        application opens the first file, reads a chunk of it, waits for data,
        reads another chunk, and so on, until the entire file is read. Then
        the application starts again, on the next file. The requests become
        serialized: a subsequent request cannot be issued until the current
        request completes.</p>
<p>This is in stark contrast to write requests, which (in their
        default, nonsynchronized state) need not initiate any disk I/O until
        some time in the future. Thus, from the perspective of a user-space
        application, write requests <emphasis>stream</emphasis>, unencumbered
        by the performance of the disk. This streaming behavior only compounds
        the problem for reads: as writes stream, they can hog the kernel and
        disk's attention. This phenomenon is known as the
        <emphasis>writes-starving-reads</emphasis> problem.</p>
<p>If an I/O scheduler <emphasis>always</emphasis> sorted new
        requests by the order of insertion, it would be possible to starve
        requests to far-off blocks indefinitely. Consider our previous
        example. If new requests were continually issued to blocks in, say,
        the 50s, the request to block 109 would never be serviced. Because
        read latency is critical, this behavior would greatly hurt system
        performance. Thus, I/O schedulers employ a mechanism to prevent
        starvation.</p>
<p>A simple approach—such as the one taken by the 2.4 Linux
        kernel's I/O scheduler, the <emphasis>Linus
        Elevator</emphasis><sup>[18]</sup>—is to simply stop insertion-sorting if there is a
        sufficiently old request in the queue. This trades overall performance
        for per-request fairness and, in the case of reads, improves latency.
        The problem is that this heuristic is a bit too simplistic.
        Recognizing this, the 2.6 Linux kernel witnessed the demise of the
        Linus Elevator, and unveiled several new I/O schedulers in its
        place.</p>
<empty-line/>
<p><strong>The Deadline I/O Scheduler</strong></p>
<p>The Deadline I/O Scheduler was introduced to solve the
          problems with the 2.4 I/O scheduler, and traditional elevator
          algorithms in general. The Linus Elevator maintains a sorted list of
          pending I/O requests. The I/O request at the head of the queue is
          the next one to be serviced. The Deadline I/O Scheduler keeps this
          queue, but kicks things up a notch by introducing two additional
          queues: the <emphasis>read FIFO queue</emphasis>, and the
          <emphasis>write FIFO queue</emphasis>. The items in each of these
          queues are sorted by submission time (effectively, the first in is
          the first out). The read FIFO queue, as its name suggests, contains
          only read requests. The write FIFO queue, likewise, contains only
          write requests. Each request in the FIFO queues is assigned an
          expiration value. The read FIFO queue has an expiration time of 500
          milliseconds. The write FIFO queue has an expiration time of five
          seconds.</p>
<p>When a new I/O request is submitted, it is insertion-sorted
          into the standard queue, and placed at the tail of its respective
          (read or write) FIFO queue. Normally, the hard drive is sent I/O
          requests from the head of the standard sorted queue. This maximizes
          global throughput by minimizing seeks, as the normal queue is sorted
          by block number (as with the Linus Elevator).</p>
<p>When the item at the head of one of the FIFO queues grows
          older than the expiration value associated with its queue, however,
          the I/O scheduler stops dispatching I/O requests from the standard
          queue, and begins servicing requests from that queue—the request at
          the head of the FIFO queue is serviced, plus a couple of extras for
          good measure. The I/O scheduler needs to check and handle only the
          requests at the head of the queue, as those are the oldest
          requests.</p>
<p>In this manner, the Deadline I/O Scheduler can enforce a soft
          deadline on I/O requests. Although it makes no promise that an I/O
          request will be serviced before its expiration time, the I/O
          scheduler generally services requests near their expiration times.
          Thus, the Deadline I/O Scheduler continues to provide good global
          throughput without starving any one request for an unacceptably long
          time. Because read requests are given shorter expiration times, the
          writes-starving-reads problem is minimized.</p>
<empty-line/>
<p><strong>The Anticipatory I/O Scheduler</strong></p>
<p>The Deadline I/O Scheduler's behavior is good, but not
          perfect. Recall our discussion on read dependency. With the Deadline
          I/O Scheduler, the first read request in a series of reads is
          serviced in short order, at or before its expiration time, and the
          I/O scheduler then returns to servicing I/O requests from the sorted
          queue—so far, so good. But suppose the application then swoops in
          and hits us with another read request? Eventually its expiration
          time will also approach, and the I/O scheduler will submit it to the
          disk, which will seek over to promptly handle the request, then seek
          back to continue handling requests from the sorted queue. This
          seeking back and forth can continue for some time because many
          applications exhibit this behavior. While latency is kept to a
          minimum, global throughput is not very good because the read
          requests keep coming in, and the disk has to keep seeking back and
          forth to handle them. Performance would be improved if the disk just
          took a break to wait for another read, and did not move away to
          service the sorted queue again. But, unfortunately, by the time the
          application is scheduled and submits its next dependent read
          request, the I/O scheduler has already shifted gears.</p>
<p>The problem again stems from those darn dependent reads—each
          new read request is issued only when the previous one is returned,
          but by the time the application receives the read data, is scheduled
          to run, and submits its next read request, the I/O scheduler has
          moved on, and begun servicing other requests. This results in a
          wasted pair of seeks for each read: the disk seeks to the read,
          services it, and then seeks back. If only there was some way for the
          I/O scheduler to know—to <emphasis>anticipate</emphasis>—that
          another read would soon be submitted to the same part of the disk,
          instead of seeking back and forth, it could wait in anticipation of
          the next read. Saving those awful seeks certainly would be worth a
          few milliseconds of waiting.</p>
<p>This is exactly how the Anticipatory I/O Scheduler operates.
          It began life as the Deadline I/O Scheduler, but was gifted with the
          addition of an anticipation mechanism. When a read request is
          submitted, the Anticipatory I/O Scheduler services it within its
          deadline, as usual. Unlike the Deadline I/O Scheduler, however, the
          Anticipatory I/O Scheduler then sits and waits, doing nothing, for
          up to six milliseconds. Chances are good that the application will
          issue another read to the same part of the filesystem during those
          six milliseconds. If so, that request is serviced immediately, and
          the Anticipatory I/O Scheduler waits some more. If six milliseconds
          go by without a read request, the Anticipatory I/O Scheduler decides
          it has guessed wrong, and returns to whatever it was doing before
          (i.e., servicing the standard sorted queue). If even a moderate
          number of requests are anticipated correctly, a great deal of
          time—two expensive seeks' worth at each go—is saved. Because most
          reads are dependent, the anticipation pays off much of the
          time.</p>
<empty-line/>
<p><strong>The CFQ I/O Scheduler</strong></p>
<p>The Complete Fair Queuing (CFQ) I/O Scheduler works to achieve
          similar goals, albeit via a different approach.<sup>[19]</sup> With CFQ, each process is assigned its own queue, and
          each queue is assigned a timeslice. The I/O scheduler visits each
          queue in a round-robin fashion, servicing requests from the queue
          until the queue's timeslice is exhausted, or until no more requests
          remain. In the latter case, the CFQ I/O Scheduler will then sit idle
          for a brief period—by default, 10 ms—waiting for a new request on
          the queue. If the anticipation pays off, the I/O scheduler avoids
          seeking. If not, the waiting was in vain, and the scheduler moves on
          to the next process' queue.</p>
<p>Within each process' queue, synchronized requests (such as
          reads) are given priority over nonsynchronized requests. In this
          manner, CFQ favors reads and prevents the writes-starving-reads
          problem. Because of the per-process queue setup, the CFQ I/O
          Scheduler is fair to all processes, while still providing good
          global performance.</p>
<p>The CFQ I/O Scheduler is well suited to most workloads, and
          makes an excellent first choice.</p>
<empty-line/>
<p><strong>The Noop I/O Scheduler</strong></p>
<p>The Noop I/O Scheduler is the most basic of the available
          schedulers. It performs no sorting whatsoever, only basic merging.
          It is used for specialized devices that do not require (or that
          perform) their own request sorting.</p>
<empty-line/>
<p><strong>Selecting and Configuring Your I/O Scheduler</strong></p>
<p>The default I/O scheduler is selectable at boot time via the
        <emphasis>iosched</emphasis> kernel command-line parameter. Valid
        options are <emphasis>as</emphasis>, <emphasis>cfq</emphasis>,
        <emphasis>deadline</emphasis>, and <emphasis>noop</emphasis>. The I/O
        scheduler is also runtime-selectable on a per-device basis via
        <emphasis>/sys/block/</emphasis><emphasis>device</emphasis><emphasis>/queue/scheduler</emphasis>,
        where <emphasis>device</emphasis> is the block device in
        question. Reading this file returns the current I/O scheduler; writing
        one of the valid options to this file sets the I/O scheduler. For
        example, to set the device <emphasis>hda</emphasis> to the CFQ I/O
        Scheduler, one would do the following:# echo cfq &gt; /sys/block/hda/queue/scheduler</p>
<p>The directory
        <emphasis>/sys/block/</emphasis><emphasis>device</emphasis><emphasis>/queue/iosched</emphasis>
        contains files that allow the administrator to retrieve and set
        tunable values related to the I/O scheduler. The exact options depend
        on the current I/O scheduler. Changing any of these settings requires
        root privileges.</p>
<p>A good programmer writes programs that are agnostic to the
        underlying I/O subsystem. Nonetheless, knowledge of this subsystem can
        surely help one write optimal code.</p>
<empty-line/>
<p><strong>Optimizing I/O Performance</strong></p>
<p>Because disk I/O is so slow relative to the performance of other
        components in the system, yet I/O is such an important aspect of
        modern computing, maximizing I/O performance is crucial.</p>
<p>Minimizing I/O operations (by coalescing many smaller operations
        into fewer larger operations), performing block-size-aligned I/O, or
        using user buffering (see Chapter 3),
        and taking advantage of advanced I/O techniques, such as vectored I/O,
        positional I/O (see Chapter 2), and
        asynchronous I/O, are important steps to always consider when system
        programming.</p>
<p>The most demanding mission-critical and I/O-intense
        applications, however, can employ additional tricks to maximize
        performance. Although the Linux kernel, as discussed previously,
        utilizes advanced I/O schedulers to minimize dreaded disk seeks,
        user-space applications can work toward the same end, in a similar
        fashion, to further improve performance.</p>
<empty-line/>
<p><strong>Scheduling I/O in user space</strong></p>
<p>I/O-intensive applications that issue a large number of I/O
          requests and need to extract every ounce of performance can sort and
          merge their pending I/O requests, performing the same duties as the
          Linux I/O scheduler.<sup>[20]</sup></p>
<p>Why perform the same work twice, if you know the I/O scheduler
          will sort requests block-wise, minimizing seeks, and allowing the
          disk head to move in a smooth, linear fashion? Consider an
          application that submits a large number of unsorted I/O requests.
          These requests arrive in the I/O scheduler's queue in a generally
          random order. The I/O scheduler does its job, sorting and merging
          the requests before sending them out to the disk—but the requests
          start hitting the disk while the application is still generating I/O
          and submitting requests. The I/O scheduler is able to sort only a
          small set of requests—say, a handful from this application, and
          whatever other requests are pending—at a time. Each batch of the
          application's requests is neatly sorted, but the full queue, and any
          future requests are not part of the equation.</p>
<p>Therefore, if an application is generating many
          requests—particularly if they are for data all over the disk—it can
          benefit from sorting the requests before submitting them, ensuring
          they reach the I/O scheduler in the desired order.</p>
<p>A user-space application is not bestowed with access to the
          same information as the kernel, however. At the lowest levels inside
          the I/O scheduler, requests are already specified in terms of
          physical disk blocks. Sorting them is trivial. But, in user space,
          requests are specified in terms of files and offsets. User-space
          applications must probe for information, and make educated guesses
          about the layout of the filesystem.</p>
<p>Given the goal of determining the most seek-friendly ordering
          given a list of I/O requests to specific files, user-space
          applications have a couple of options. They can sort based
          on:</p>
<p>The full path</p>
<p>The inode number</p>
<p>The physical disk block of the file</p>
<p>Each of these options involves a tradeoff. Let's look at each
          briefly.</p>
<empty-line/>
<p>Sorting by path</p>
<p>Sorting by the pathname is the easiest, yet least effective,
            way of approximating a block-wise sort. Due to the layout
            algorithms used by most filesystems, the files in each
            directory—and thus the directories sharing a parent directory—tend
            to be adjacent on disk. The probability that files in the same
            directory were created around the same time only amplifies this
            characteristic.</p>
<p>Sorting by path, therefore, roughly approximates the
            physical locations of files on the disk. It is definitely true
            that two files in the same directory have a better chance of being
            located near each other than two files in radically different
            parts of the filesystem. The downside of this approach is that it
            fails to take into account fragmentation: the more fragmented the
            filesystem, the less useful is sorting by path. Even ignoring
            fragmentation, a path-wise sort only approximates the actual
            block-wise ordering. On the upside, a path-wise sort is at least
            somewhat applicable to all filesystems. No matter the approach to
            file layout, temporal locality suggests a path-wise sort will be
            at least mildly accurate. It is also an easy sort to
            perform.</p>
<empty-line/>
<p>Sorting by inode</p>
<p>Inodes are Unix constructs that contain the metadata
            associated with individual files. While a file's data may consume
            multiple physical disk blocks, each file has exactly one inode,
            which contains information such as the file's size, permissions,
            owner, and so on. We will discuss inodes in depth in Chapter 7. For now, you need to
            know two facts: that every file has an inode associated with it,
            and that the inodes are assigned unique numbers.</p>
<p>Sorting by inode is better than sorting by path, assuming
            that this relation:file i's inode number &lt; file j's inode number</p>
<p>implies, in general, that:physical blocks of file i &lt; physical blocks of file j</p>
<p>This is certainly true for Unix-style filesystems such as
            <emphasis>ext2</emphasis> and <emphasis>ext3</emphasis>. Anything
            is possible for filesystems that do not employ actual inodes, but
            the inode number (whatever it may map to) is still a good
            first-order approximation.</p>
<p>Obtaining the inode number is done via the stat( ) system call, also discussed in
            Chapter 7. Given the inode
            associated with the file involved in each I/O request, the
            requests can be sorted in ascending order by inode number.</p>
<p>Here is a simple program that prints out the inode number of
            a given file:#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

/*
 * get_inode - returns the inode of the file associated
 * with the given file descriptor, or −1 on failure
 */
int get_inode (int fd)
{
        struct stat buf;
        int ret;

        ret = fstat (fd, &amp;buf);
       if (ret &lt; 0) {
                perror ("fstat");
                return −1;
        }

        return buf.st_ino;
}

int main (int argc, char *argv[])
{
        int fd, inode;

        if (argc &lt; 2) {
                fprintf (stderr, "usage: %s &lt;file&gt;\n", argv[0]);
                return 1;
        }

        fd = open (argv[1], O_RDONLY);
        if (fd &lt; 0) {
                perror ("open");
                return 1;
        }

        inode = get_inode (fd);
        printf ("%d\n", inode);

        return 0;
}</p>
<p>The get_inode( ) function
            is easily adaptable for use in your programs.</p>
<p>Sorting by inode number has a few upsides: the inode number
            is easy to obtain, is easy to sort on, and is a good approximation
            of the physical file layout. The major downsides are that
            fragmentation degrades the approximation, that the approximation
            is just a guess, and that the approximation is less accurate for
            non-Unix filesystems. Nonetheless, this is the most commonly used
            method for scheduling I/O requests in user space.</p>
<empty-line/>
<p>Sorting by physical block</p>
<p>The best approach to designing your own elevator algorithm,
            of course, is to sort by physical disk block. As discussed
            earlier, each file is broken up into logical blocks, which are the
            smallest allocation units of a filesystem. The size of a logical
            block is filesystem-dependent; each logical block maps to a single
            physical block. We can thus find the number of logical blocks in a
            file, determine what physical blocks they map to, and sort based
            on that.</p>
<p>The kernel provides a method for obtaining the physical disk
            block from the logical block number of a file. This is done via
            the ioctl( ) system call,
            discussed in Chapter 7,
            with the FIBMAP command:ret = ioctl (fd, FIBMAP, &amp;block);
if (ret &lt; 0)
        perror ("ioctl");</p>
<p>Here, fd is the file
            descriptor of the file in question, and block is the logical block whose
            physical block we want to determine. On successful return,
            block is replaced with the
            physical block number. The logical blocks passed in are
            zero-indexed and file-relative. That is, if a file is made up of
            eight logical blocks, valid values are 0 through 7.</p>
<p>Finding the logical-to-physical-block mapping is thus a
            two-step process. First, we must determine the number of blocks in
            a given file. This is done via the stat(
            ) system call. Second, for each logical block, we must
            issue an ioctl( ) request to
            find the corresponding physical block.</p>
<p>Here is a sample program to do just that for a file passed
            in on the command line:#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;linux/fs.h&gt;

/*
 * get_block - for the file associated with the given fd, returns
 * the physical block mapping to logical_block
 */
int get_block (int fd, int logical_block)
{
        int ret;

        ret = ioctl (fd, FIBMAP, &amp;logical_block);
        if (ret &lt; 0) {
                perror ("ioctl");
                return −1;
        }

        return logical_block;
}

/*
 * get_nr_blocks - returns the number of logical blocks
 * consumed by the file associated with fd
 */
int get_nr_blocks (int fd)
{
        struct stat buf;
        int ret;

        ret = fstat (fd, &amp;buf);
        if (ret &lt; 0) {
                perror ("fstat");
                return −1;
        }
        return buf.st_blocks;
}

/*
 * print_blocks - for each logical block consumed by the file
 * associated with fd, prints to standard out the tuple
 * "(logical block, physical block)"
 */
void print_blocks (int fd)
{
        int nr_blocks, i;

        nr_blocks = get_nr_blocks (fd);
        if (nr_blocks &lt; 0) {
                fprintf (stderr, "get_nr_blocks failed!\n");
                return;
        }

        if (nr_blocks == 0) {
                printf ("no allocated blocks\n");
                return;
        } else if (nr_blocks == 1)
                printf ("1 block\n\n");
        else
                printf ("%d blocks\n\n", nr_blocks);

        for (i = 0; i &lt; nr_blocks; i++) {
                int phys_block;

                phys_block = get_block (fd, i);
                if (phys_block &lt; 0) {
                        fprintf (stderr, "get_block failed!\n");
                        return;
                }
                if (!phys_block)
                        continue;

                printf ("(%u, %u) ", i, phys_block);
        }

        putchar ('\n');
}

int main (int argc, char *argv[])
{
        int fd;

        if (argc &lt; 2) {
                fprintf (stderr, "usage: %s &lt;file&gt;\n", argv[0]);
                return 1;
        }

        fd = open (argv[1], O_RDONLY);
        if (fd &lt; 0) {
                perror ("open");
                return 1;
        }

        print_blocks (fd);

        return 0;
}</p>
<p>Because files tend to be contiguous, and it would be
            difficult (at best) to sort our I/O requests on a
            per-logical-block basis, it makes sense to sort based on the
            location of just the first logical block of a given file.
            Consequently, get_nr_blocks( )
            is not needed, and our applications can sort based on the return
            value from:get_block (fd, 0);</p>
<p>The downside of FIBMAP is
            that it requires the CAP_SYS_RAWIO capability—effectively,
            root privileges. Consequently, nonroot applications cannot make
            use of this approach. Further, while the FIBMAP command is standardized, its
            actual implementation is left up to the filesystems. While common
            systems such as <emphasis>ext2</emphasis> and
            <emphasis>ext3</emphasis> support it, a more esoteric beast may
            not. The ioctl( ) call will
            return EINVAL if FIBMAP is not supported.</p>
<p>Among the pros of this approach, however, is that it returns
            the <emphasis>actual</emphasis> physical disk block at which a
            file resides, which is exactly what you want to sort on. Even if
            you sort all I/O to a single file based on the location of just
            one block (the kernel's I/O scheduler sorts each individual
            request on a block-wise basis), this approach comes very close to
            the optimal ordering. The root requirement, however, is a bit of a
            nonstarter for many.</p>
<empty-line/>
<p><strong>Conclusion</strong></p>
<p>Over the course of the last three chapters, we have touched on all
      aspects of file I/O in Linux. In Chapter 2, we
      looked at the basics of Linux file I/O—really, the basis of Unix
      programming—with system calls such as read(
      ), write( ), open( ), and close(
      ). In Chapter 3, we discussed
      user-space buffering and the standard C library's implementation
      thereof. In this chapter, we discussed various facets of advanced I/O,
      from the more-powerful-but-more-complex I/O system calls to optimization
      techniques and the dreaded performance-sucking disk seek.</p>
<p>In the next two chapters, we will look at process management:
      creating, destroying, and managing processes. Onward!</p>
<empty-line/><empty-line/>
<p><sup>[14] </sup><sup>*</sup> Note that other Unix systems
              may set errno to EINVAL if count is 0. This is explicitly
              allowed by the standards, which say that EINVAL may be set if
              that value is 0, or that the system can handle the zero case in
              some other (nonerror) way.</p>
<p><sup>[15] </sup><sup>*</sup> Epoll was introduced in the
          2.5.44 development kernel, and the interface was finalized as of
          2.5.66.</p>
<p><sup>[16] </sup><sup>*</sup> Read operations are technically
          also nonsynchronized, like write operations, but the kernel ensures
          that the page cache contains up-to-date data. That is, the page
          cache's data is always identical to or newer than the data on disk.
          In this manner, the behavior in practice is always synchronized.
          There is little argument for behaving any other way.</p>
<p><sup>[17] </sup><sup>*</sup> Limits on the absolute size of
            this block number are largely responsible for the various limits
            on total drive sizes over the years.</p>
<p><sup>[18] </sup><sup>*</sup> Yes, the man has an I/O
            scheduler named after him. I/O schedulers are sometimes called
            elevator algorithms, because they solve a problem similar to that
            of keeping an elevator running smoothly.</p>
<p><sup>[19] </sup><sup>*</sup> The following text discusses
              the CFQ I/O Scheduler as it is currently implemented. Previous
              incarnations did not use timeslices or the anticipation
              heuristic, but operated in a similar fashion.</p>
<p><sup>[20] </sup><sup>*</sup> One should apply the
              techniques discussed here only to I/O-intensive,
              mission-critical applications. Sorting the I/O requests—assuming
              there is even anything to sort—of applications that do not issue
              many such requests is silly and unneeded.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 5. Process Management</strong></p>
<p>As mentioned in Chapter 1, processes are the most
    fundamental abstraction in a Unix system, after files. As object code in
    execution—active, alive, running programs—processes are more than just
    assembly language; they consist of data, resources, state, and a
    virtualized computer.</p>
<p>In this chapter, we will look at the fundamentals of the process,
    from creation to termination. The basics have remained relatively
    unchanged since the earliest days of Unix. It is here, in the subject of
    process management, that the longevity and forward thinking of Unix's
    original design shines brightest. Unix took an interesting path, one
    seldom traveled, and separated the act of creating a new process from the
    act of loading a new binary image. Although the two tasks are performed in
    tandem most of the time, the division has allowed a great deal of freedom
    for experimentation and evolution for each of the tasks. This road less
    traveled has survived to this day, and while most operating systems offer
    a single system call to start up a new program, Unix requires two: a fork
    and an exec. But before we cover those system calls, let's look more
    closely at the process itself.</p>
<empty-line/>
<p><strong>The Process ID</strong></p>
<p>Each process is represented by a unique identifier, the
      <emphasis>process ID</emphasis> (frequently shortened to
      <emphasis>pid</emphasis>). The pid is guaranteed to be unique at any
      <emphasis>single point in time</emphasis>. That is, while at time
      t0 there can be only one process with
      the pid 770 (if any process at all exists with such a value), there is
      no guarantee that at time t1 a
      different process won't exist with pid 770. Essentially, however, most
      code presumes that the kernel does not readily reissue process
      identifiers—an assumption that, as you will see shortly, is fairly
      safe.</p>
<p>The <emphasis>idle process</emphasis>—the process that the kernel
      "runs" when there are no other runnable processes—has the pid 0. The
      first process that the kernel executes after booting the system, called
      the <emphasis>init process</emphasis>, has the pid 1. Normally, the init
      process on Linux is the <emphasis>init</emphasis> program. We use the
      term "init" to refer to both the initial process that the kernel runs,
      and the specific program used for that purpose.</p>
<p>Unless the user explicitly tells the kernel what process to run
      (through the <emphasis>init</emphasis> kernel command-line parameter),
      the kernel has to identify a suitable init process on its own—a rare
      example where the kernel dictates policy. The Linux kernel tries four
      executables, in the following order:</p>
<p><emphasis>/sbin/init</emphasis>: The preferred and most likely
          location for the init process.</p>
<p><emphasis>/etc/init</emphasis>: Another likely location for
          the init process.</p>
<p><emphasis>/bin/init</emphasis>: A possible location for the
          init process.</p>
<p><emphasis>/bin/sh</emphasis>: The location of the Bourne
          shell, which the kernel tries to run if it fails to find an init
          process.</p>
<p>The first of these processes that exists is executed as the init
      process. If all four processes fail to execute, the Linux kernel halts
      the system with a panic.</p>
<p>After the handoff from the kernel, the init process handles the
      remainder of the boot process. Typically, this includes initializing the
      system, starting various services, and launching a login program.</p>
<empty-line/>
<p><strong>Process ID Allocation</strong></p>
<p>By default, the kernel imposes a maximum process ID value of
        32768. This is for compatibility with older Unix systems, which used
        smaller 16-bit types for process IDs. System administrators can set
        the value higher via <emphasis>/proc/sys/kernel/pid_max</emphasis>,
        trading a larger pid space for reduced compatibility.</p>
<p>The kernel allocates process IDs to processes in a strictly
        linear fashion. If pid 17 is the highest number currently allocated,
        pid 18 will be allocated next, even if the process last assigned pid
        17 is no longer running when the new process starts. The kernel does
        not reuse process ID values until it wraps around from the top—that
        is, earlier values will not be reused until the value in
        <emphasis>/proc/sys/kernel/pid_max</emphasis> is allocated. Therefore,
        while Linux makes no guarantee of the uniqueness of process IDs over a
        long period, its allocation behavior does provide at least short-term
        comfort in the stability and uniqueness of pid values.</p>
<empty-line/>
<p><strong>The Process Hierarchy</strong></p>
<p>The process that spawns a new process is known as the
        <emphasis>parent</emphasis>; the new process is known as the
        <emphasis>child</emphasis>. Every process is spawned from another
        process (except, of course, the init process). Therefore, every child
        has a parent. This relationship is recorded in each process'
        <emphasis>parent process ID</emphasis> (ppid), which is the pid of the
        child's parent.</p>
<p>Each process is owned by a <emphasis>user</emphasis> and a
        <emphasis>group</emphasis>. This ownership is used to control access
        rights to resources. To the kernel, users and groups are mere integer
        values. Through the files <emphasis>/etc/passwd</emphasis> and
        <emphasis>/etc/group</emphasis>, these integers are mapped to the
        human-readable names with which Unix users are familiar, such as the
        user <emphasis>root</emphasis> or the group <emphasis>wheel</emphasis>
        (generally speaking, the Linux kernel has no interest in
        human-readable strings, and prefers to identify objects with
        integers). Each child process inherits its parent's user and group
        ownership.</p>
<p>Each process is also part of a <emphasis>process
        group</emphasis>, which simply expresses its relationship to other
        processes, and must not be confused with the aforementioned user/group
        concept. Children normally belong to the same process groups as their
        parents. In addition, when a shell starts up a pipeline (e.g., when a
        user enters <emphasis>ls | less</emphasis>), all the commands in the
        pipeline go into the same process group. The notion of a process group
        makes it easy to send signals to or get information on an entire
        pipeline, as well as all children of the processes in the pipeline.
        From the perspective of a user, a process group is closely related to
        a <emphasis>job</emphasis>.</p>
<empty-line/>
<p><strong>pid_t</strong></p>
<p>Programmatically, the process ID is represented by the pid_t type, which is defined in the header
        file <emphasis>&lt;sys/types.h&gt;</emphasis>. The exact backing C
        type is architecture-specific, and not defined by any C standard. On
        Linux, however, pid_t is generally
        a typedef to the C int
        type.</p>
<empty-line/>
<p><strong>Obtaining the Process ID and Parent Process ID</strong></p>
<p>The getpid( ) system call
        returns the process ID of the invoking process:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid (void);</strong></p>
<p>The getppid( ) system call
        returns the process ID of the invoking process' parent:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getppid (void);</strong></p>
<p>Neither call will return an error. Consequently, usage is
        trivial:printf ("My pid=%d\n", getpid ( ));
printf ("Parent's pid=%d\n", getppid ( ));</p>
<p>How do we know that a pid_t
        is a signed integer? Good question! The answer, simply, is that we do
        not know. Even though we can safely assume that pid_t is an int on Linux, such a guess still defeats the
        intention of the abstract type, and hurts portability. Unfortunately,
        as with all typedefs in C, there is no easy way to print pid_t values—this is part of the
        abstraction, and technically we need a pid_to_int( ) function, which we lack.
        Treating these values as integers, however, at least for the purposes
        of printf( ), is common.</p>
<empty-line/>
<p><strong>Running a New Process</strong></p>
<p>In Unix, the act of loading into memory and executing a program
      image is separate from the act of creating a new process. One system
      call (actually, one call from a family of calls) loads a binary program
      into memory, replacing the previous contents of the address space, and
      begins execution of the new program. This is called
      <emphasis>executing</emphasis> a new program, and the functionality is
      provided by the <emphasis>exec</emphasis> family of calls.</p>
<p>A different system call is used to create a new process, which
      initially is a near duplicate of its parent process. Often, the new
      process immediately executes a new program. The act of creating a new
      process is called <emphasis>forking</emphasis>, and this functionality
      is provided by the fork( ) system
      call. Two acts—first a fork, to create a new process, and then an exec,
      to load a new image into that process—are thus required to execute a new
      program image in a new process. We will cover the exec calls first, then
      fork( ).</p>
<empty-line/>
<p><strong>The Exec Family of Calls</strong></p>
<p>There is no single exec function; instead, there is a family of
        exec functions built on a single system call. Let's first look at the
        simplest of these calls, execl(
        ):<strong>#include &lt;unistd.h&gt;

int execl (const char *path,
           const char *arg,
           ...);</strong></p>
<p>A call to execl( ) replaces
        the current process image with a new one by loading into memory the
        program pointed at by path. The
        parameter arg is the first argument
        to this program. The ellipsis signifies a variable number of
        arguments—the execl( ) function is
        <emphasis>variadic</emphasis>, which means that additional arguments
        may optionally follow, one by one. The list of arguments must be
        NULL-terminated.</p>
<p>For example, the following code replaces the currently executing
        program with <emphasis>/bin/vi</emphasis>:int ret;

ret = execl ("/bin/vi", "vi", NULL);
if (ret == −1)
        perror ("execl");</p>
<p>Note that we follow the Unix convention and pass "vi" as the
        program's first argument. The shell puts the last component of the
        path, the "vi," into the first argument when it forks/execs processes,
        so a program can examine its first argument, argv[0], to discover the name of its binary
        image. In many cases, several system utilities that appear as
        different names to the user are in fact a single program with hard
        links for their multiple names. The program uses the first argument to
        determine its behavior.</p>
<p>As another example, if you wanted to edit the file
        <emphasis>/home/kidd/hooks.txt</emphasis>, you could execute the
        following code:int ret;

ret = execl ("/bin/vi", "vi", "/home/kidd/hooks.txt", NULL);
if (ret == −1)
        perror ("execl");</p>
<p>Normally, execl( ) does not
        return. A successful invocation ends by jumping to the entry point of
        the new program, and the just-executed code no longer exists in the
        process' address space. On error, however, execl( ) returns −1, and sets errno to indicate the problem. We will look
        at the possible errno values later
        in this section.</p>
<p>A successful execl( ) call
        changes not only the address space and process image, but certain
        other attributes of the process:</p>
<p>Any pending signals are lost.</p>
<p>Any signals that the process is catching (see Chapter 9) are returned to their default behavior, as
            the signal handlers no longer exist in the process' address
            space.</p>
<p>Any memory locks (see Chapter 8)
            are dropped.</p>
<p>Most thread attributes are returned to the default
            values.</p>
<p>Most process statistics are reset.</p>
<p>Anything related to the process' memory, including any
            mapped files, is dropped.</p>
<p>Anything that exists solely in user space, including
            features of the C library, such as atexit( ) behavior, is dropped.</p>
<p>Many properties of the process, however, do
        <emphasis>not</emphasis> change. For example, the pid, parent pid,
        priority, and owning user and group all remain the same.</p>
<p>Normally, open files are inherited across an exec. This means
        the newly executed program has full access to all of the files open in
        the original process, assuming it knows the file descriptor values.
        However, this is often not the desired behavior. The usual practice is
        to close files before the exec, although it is also possible to
        instruct the kernel to do so automatically via fcntl( ).</p>
<empty-line/>
<p><strong>The rest of the family</strong></p>
<p>In addition to execl( ),
          there are five other members of the exec family:<strong>#include &lt;unistd.h&gt;

int execlp (const char *file,
            const char *arg,
            ...);

int execle (const char *path,
            const char *arg,
            ...,
            char * const envp[]);

int execv (const char *path, char *const argv[]);

int execvp (const char *file, char *const argv[]);

int execve (const char *filename,
            char *const argv[],
            char *const envp[]);</strong></p>
<p>The mnemonics are simple. The l and v
          delineate whether the arguments are provided via a
          <emphasis>l</emphasis>ist or an array (<emphasis>v</emphasis>ector).
          The p denotes that the user's
          full <emphasis>p</emphasis>ath is searched for the given file.
          Commands using the p variants can
          specify just a filename, so long as it is located in the user's
          path. Finally, the e notes that a
          new environment is also supplied for the new process. Curiously,
          although there is no technical reason for the omission, the exec
          family contains no member that both searches the path and takes a
          new environment. This is probably because the p variants were implemented for use by
          shells, and shell-executed processes generally inherit their
          environments from the shell.</p>
<p>The members of the exec family that accept an array work about
          the same, except that an array is constructed and passed in instead
          of a list. The use of an array allows the arguments to be determined
          at runtime. Like the variadic list of arguments, the array must be
          NULL-terminated.</p>
<p>The following snippet uses execvp(
          ) to execute <emphasis>vi</emphasis>, as we did
          previously:const char *args[] = { "vi", "/home/kidd/hooks.txt", NULL };
int ret;

ret = execvp ("vi", args);
if (ret == −1)
        perror ("execvp");</p>
<p>Assuming <emphasis>/bin</emphasis> is in the user's path, this
          works similarly to the last example.</p>
<p>In Linux, only one member of the exec family is a system call.
          The rest are wrappers in the C library around the system call.
          Because variadic system calls would be difficult to implement, at
          best, and because the concept of the user's path exists solely in
          user space, the only option for the lone system call is execve( ). The system call prototype is
          identical to the user call.</p>
<empty-line/>
<p><strong>Error values</strong></p>
<p>On success, the exec system calls do not return. On failure,
          the calls return −1, and set
          errno to one of the following
          values:</p>
<p>E2BIG</p>
<p>The total number of bytes in the provided arguments list
                (arg) or environment
                (envp) is too large.EACCESS</p>
<p>The process lacks search permission for a component in
                path; path is not a regular file; the
                target file is not marked executable; or the filesystem on
                which path or file resides is mounted noexec.EFAULT</p>
<p>A given pointer is invalid.EIO</p>
<p>A low-level I/O error occurred (this is bad).EISDIR</p>
<p>The final component in path, or the interpreter, is a
                directory.ELOOP</p>
<p>The system encountered too many symbolic links in
                resolving path.EMFILE</p>
<p>The invoking process has reached its limit on open
                files.ENFILE</p>
<p>The system-wide limit on open files has been
                reached.ENOENT</p>
<p>The target of path or
                file does not exist, or a
                needed shared library does not exist.ENOEXEC</p>
<p>The target of path or
                file is an invalid binary,
                or is intended for a different machine architecture.ENOMEM</p>
<p>There is insufficient kernel memory available to execute
                a new program.ENOTDIR</p>
<p>A nonfinal component in path is not a directory.EPERM</p>
<p>The filesystem on which path or file resides is mounted nosuid, the user is not root, and
                path or file has the suid or sgid bit
                set.ETXTBSY</p>
<p>The target of path or
                file is open for writing by
                another process.</p>
<empty-line/>
<p><strong>The fork( ) System Call</strong></p>
<p>A new process running the same image as the current one can be
        created via the fork( ) system
        call:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork (void);</strong></p>
<p>A successful call to fork( )
        creates a new process, identical in almost all aspects to the invoking
        process. Both processes continue to run, returning from fork( ) as if nothing special had
        happened.</p>
<p>The new process is called the "child" of the original process,
        which in turn is called the "parent." In the child, a successful
        invocation of fork( ) returns
        0. In the parent, fork( ) returns the pid of the child. The
        child and the parent process are identical in nearly every facet,
        except for a few necessary differences:</p>
<p>The pid of the child is, of course, newly allocated, and
            different from that of the parent.</p>
<p>The child's parent pid is set to the pid of its parent
            process.</p>
<p>Resource statistics are reset to zero in the child.</p>
<p>Any pending signals are cleared, and not inherited by the
            child (see Chapter 9).</p>
<p>Any acquired file locks are not inherited by the
            child.</p>
<p>On error, a child process is not created, fork( ) returns −1, and errno is set appropriately. There are two
        possible errno values, with three
        possible meanings:</p>
<p>EAGAIN</p>
<p>The kernel failed to allocate certain resources, such as a
              new pid, or the RLIMIT_NPROC
              resource limit (rlimit) has been reached (see Chapter 6).ENOMEM</p>
<p>Insufficient kernel memory was available to complete the
              request.</p>
<p>Use is simple:pid_t pid;

pid = fork (  );
if (pid &gt; 0)
        printf ("I am the parent of pid=%d!\n", pid);
else if (!pid)
        printf ("I am the baby!\n");
else if (pid == −1)
        perror ("fork");</p>
<p>The most common usage of fork(
        ) is to create a new process in which a new binary image is
        then loaded—think a shell running a new program for the user or a
        process spawning a helper program. First the process forks a new
        process, and then the child executes a new binary image. This "fork
        plus exec" combination is frequent and simple. The following example
        spawns a new process running the binary
        <emphasis>/bin/windlass</emphasis>:pid_t pid;

pid = fork (  );
if (pid == −1)
        perror ("fork");

/* the child ... */
if (!pid) {
        const char *args[] = { "windlass", NULL };
        int ret;

        ret = execv ("/bin/windlass", args);
        if (ret == −1) {
                perror ("execv");
                exit (EXIT_FAILURE);
        }
}</p>
<p>The parent process continues running with no change, other than
        that it now has a new child. The call to execv( ) changes the child to running the
        <emphasis>/bin/windlass</emphasis> program.</p>
<empty-line/>
<p><strong>Copy-on-write</strong></p>
<p>In early Unix systems, forking was simple, if not naïve. Upon
          invocation, the kernel created copies of all internal data
          structures, duplicated the process' page table entries, and then
          performed a page-by-page copy of the parent's address space into the
          child's new address space. But this page-by-page copy was, at least
          from the standpoint of the kernel, time-consuming.</p>
<p>Modern Unix systems behave more optimally. Instead of a
          wholesale copy of the parent's address space, modern Unix systems
          such as Linux employ <emphasis>copy-on-write</emphasis> (COW)
          pages.</p>
<p>Copy-on-write is a lazy optimization strategy designed to
          mitigate the overhead of duplicating resources. The premise is
          simple: if multiple consumers request read access to their own
          copies of a resource, duplicate copies of the resource need not be
          made. Instead, each consumer can be handed a pointer to the same
          resource. So long as no consumer attempts to modify its "copy" of
          the resource, the illusion of exclusive access to the resource
          remains, and the overhead of a copy is avoided. If a consumer does
          attempt to modify its copy of the resource, at that point, the
          resource is transparently duplicated, and the copy is given to the
          modifying consumer. The consumer, never the wiser, can then modify
          its copy of the resource while the other consumers continue to share
          the original, unchanged version. Hence the name: the
          <emphasis>copy</emphasis> occurs only <emphasis>on
          write</emphasis>.</p>
<p>The primary benefit is that if a consumer never modifies its
          copy of the resource, a copy is never needed. The general advantage
          of lazy algorithms—that they defer expensive actions until the last
          possible moment—also applies.</p>
<p>In the specific example of virtual memory, copy-on-write is
          implemented on a per-page basis. Thus, so long as a process does not
          modify all of its address space, a copy of the entire address space
          is not required. At the completion of a fork, the parent and child
          believe that they each have a unique address space, while in fact
          they are sharing the parent's original pages—which in turn may be
          shared with other parent or child processes, and so on!</p>
<p>The kernel implementation is simple. The pages are marked as
          read-only and as copy-on-write in the kernel's page-related data
          structures. If either process attempts to modify a page, a page
          fault occurs. The kernel then handles the page fault by
          transparently making a copy of the page; at this point, the page's
          copy-on-write attribute is cleared, and it is no longer
          shared.</p>
<p>Because modern machine architectures provide hardware-level
          support for copy-on-write in their memory management units (MMUs),
          the charade is simple and easy to implement.</p>
<p>Copy-on-write has yet a bigger benefit in the case of forking.
          Because a large percentage of forks are followed by an exec, copying
          the parent's address space into the child's address space is often a
          complete waste of time: if the child summarily executes a new binary
          image, its previous address space is wiped out. Copy-on-write
          optimizes for this case.</p>
<empty-line/>
<p><strong>vfork( )</strong></p>
<p>Before the arrival of copy-on-write pages, Unix designers were
          concerned with the wasteful address-space copy during a fork that is
          immediately followed by an exec. BSD developers therefore unveiled
          the vfork( ) system call in
          3.0BSD:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t vfork (void);</strong></p>
<p>A successful invocation of vfork(
          ) has the same behavior as fork(
          ), except that the child process must immediately issue a
          successful call to one of the exec functions, or exit by calling
          _exit( ) (discussed in the next
          section). The vfork( ) system
          call avoids the address space and page table copies by suspending
          the parent process until the child terminates or executes a new
          binary image. In the interim, the parent and the child share—without
          copy-on-write semantics—their address space and page table entries.
          In fact, the only work done during a vfork(
          ) is the duplication of internal kernel data structures.
          Consequently, the child must not modify any memory in the address
          space.</p>
<p>The vfork( ) system call is
          a relic, and should never have been implemented on Linux, although
          it should be noted that even with copy-on-write, vfork( ) is faster than fork( ) because the page table entries
          need not be copied.<sup>[21]</sup> Nonetheless, the advent of copy-on-write pages weakens
          any argument for an alternative to fork(
          ). Indeed, until the 2.2.0 Linux kernel, vfork( ) was simply a wrapper around
          fork( ). As the requirements for
          vfork( ) are weaker than the
          requirements for fork( ), such a
          vfork( ) implementation is
          feasible.</p>
<p>Strictly speaking, no vfork(
          ) implementation is bug-free: consider the situation if
          the exec call were to fail! The parent would be suspended
          indefinitely while the child figured out what to do or until it
          exited.</p>
<empty-line/>
<p><strong>Terminating a Process</strong></p>
<p>POSIX and C89 both define a standard function for terminating the
      current process:<strong>#include &lt;stdlib.h&gt;

void exit (int status);</strong></p>
<p>A call to exit( ) performs some
      basic shutdown steps, and then instructs the kernel to terminate the
      process. This function has no way of returning an error—in fact, it
      never returns at all. Therefore, it does not make sense for any
      instructions to follow the exit( )
      call.</p>
<p>The status parameter is used to
      denote the process' exit status. Other programs—as well as the user at
      the shell—can check this value. Specifically, status &amp; 0377 is returned to the parent.
      We will look at retrieving the return value later in this
      chapter.</p>
<p>EXIT_SUCCESS and EXIT_FAILURE are defined as portable ways to
      represent success and failure. On Linux, 0 typically represents success; a nonzero
      value, such as 1 or −1, corresponds to failure.</p>
<p>Consequently, a successful exit is as simple as this
      one-liner:exit (EXIT_SUCCESS);</p>
<p>Before terminating the process, the C library performs the
      following shutdown steps, in order:</p>
<p>Call any functions registered with atexit( ) or on_exit( ), in the reverse order of their
          registration. (We will discuss these functions later in this
          chapter.)</p>
<p>Flush all open standard I/O streams (see Chapter 3).</p>
<p>Remove any temporary files created with the tmpfile( ) function.</p>
<p>These steps finish all the work the process needs to do in user
      space, so exit( ) invokes the system
      call _exit( ) to let the kernel
      handle the rest of the termination process:<strong>#include &lt;unistd.h&gt;

void _exit (int status);</strong></p>
<p>When a process exits, the kernel cleans up all of the resources
      that it created on the process' behalf that are no longer in use. This
      includes, but is not limited to, allocated memory, open files, and
      System V semaphores. After cleanup, the kernel destroys the process and
      notifies the parent of its child's demise.</p>
<p>Applications can call _exit( )
      directly, but such a move seldom makes sense: most applications need to
      do some of the cleanup provided by a full exit, such as flushing the
      <emphasis>stdout</emphasis> stream. Note, however, that vfork( ) users should call _exit( ), and not exit( ), after a fork.</p>
<p><strong>Tip</strong></p>
<p>In a brilliant stroke of redundancy, the ISO C99 standard added
        the _Exit( ) function, which has
        identical behavior to _exit(
        ):<strong>#include &lt;stdlib.h&gt;

void _Exit (int status);</strong></p>
<empty-line/>
<p><strong>Other Ways to Terminate</strong></p>
<p>The classic way to end a program is not via an explicit system
        call, but by simply "falling off the end" of the program. In the case
        of C, this happens when the main( )
        function returns. The "falling off the end" approach, however, still
        invokes a system call: the compiler simply inserts an implicit
        _exit( ) after its own shutdown
        code. It is good coding practice to explicitly return an exit status,
        either via exit( ), or by returning
        a value from main( ). The shell
        uses the exit value for evaluating the success or failure of commands.
        Note that a successful return is exit(0), or a return from main( ) of 0.</p>
<p>A process can also terminate if it is sent a signal whose
        default action is to terminate the process. Such signals include
        SIGTERM and SIGKILL (see Chapter 9).</p>
<p>A final way to end a program's execution is by incurring the
        wrath of the kernel. The kernel can kill a process for executing an
        illegal instruction, causing a segmentation violation, running out of
        memory, and so on.</p>
<empty-line/>
<p><strong>atexit( )</strong></p>
<p>POSIX 1003.1-2001 defines, and Linux implements, the atexit( ) library call, used to register
        functions to be invoked on process termination:<strong>#include &lt;stdlib.h&gt;

int atexit (void (*function)(void));</strong></p>
<p>A successful invocation of atexit(
        ) registers the given function to run during normal process
        termination; i.e., when a process is terminated via either exit( ) or a return from main( ). If a process invokes an exec
        function, the list of registered functions is cleared (as the
        functions no longer exist in the new process' address space). If a
        process terminates via a signal, the registered functions are not
        called.</p>
<p>The given function takes no parameters, and returns no value. A
        prototype has the form:void my_function (void);</p>
<p>Functions are invoked in the reverse order that they are
        registered. That is, the functions are stored in a stack, and the last
        in is the first out (LIFO). Registered functions must not call
        exit( ), lest they begin an endless
        recursion. If a function needs to end the termination process early,
        it should call _exit( ). Such
        behavior is not recommended, however, as a possibly important function
        may then not run.</p>
<p>The POSIX standard requires that atexit( ) support at least ATEXIT_MAX registered functions, and that
        this value has to be at least 32. The exact maximum may be obtained
        via sysconf( ) and the value of
        _SC_ATEXIT_MAX:long atexit_max;

atexit_max = sysconf (_SC_ATEXIT_MAX);
printf ("atexit_max=%ld\n", atexit_max);</p>
<p>On success, atexit( ) returns
        0. On error, it returns −1.</p>
<p>Here's a simple example:#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void out (void)
{
        printf ("atexit(  ) succeeded!\n");
}

int main (void)
{
        if (atexit (out))
                fprintf(stderr, "atexit(  ) failed!\n");

        return 0;
}</p>
<empty-line/>
<p><strong>on_exit( )</strong></p>
<p>SunOS 4 defined its own equivalent to atexit( ), and Linux's
        <emphasis>glibc</emphasis> supports it:<strong>#include &lt;stdlib.h&gt;

int on_exit (void (*function)(int, void *), void *arg);</strong></p>
<p>This function works the same as atexit(
        ), but the registered function's prototype is
        different:void my_function (int status, void *arg);</p>
<p>The status argument is the
        value passed to exit( ) or returned
        from main( ). The arg argument is the second parameter passed
        to on_exit( ). Care must be taken
        to ensure that the memory pointed at by arg is valid when the function is ultimately
        invoked.</p>
<p>The latest version of Solaris no longer supports this function.
        You should use the standards-compliant atexit( ) instead.</p>
<empty-line/>
<p><strong>SIGCHLD</strong></p>
<p>When a process terminates, the kernel sends the signal SIGCHLD to the parent. By default, this
        signal is ignored, and no action is taken by the parent. Processes can
        elect to handle this signal, however, via the signal( ) or sigaction( ) system calls. These calls, and
        the rest of the wonderful world of signals, are covered in Chapter 9.</p>
<p>The SIGCHLD signal may be
        generated and dispatched at any time, as a child's termination is
        asynchronous with respect to its parent. But often, the parent wants
        to learn more about its child's termination, or even explicitly wait
        for the event's occurrence. This is possible with the system calls
        discussed next.</p>
<empty-line/>
<p><strong>Waiting for Terminated Child Processes</strong></p>
<p>Receiving notification via a signal is nice, but many parents want
      to obtain more information when one of their child processes
      terminates—for example, the child's return value.</p>
<p>If a child process were to entirely disappear when terminated, as
      one might expect, no remnants would remain for the parent to
      investigate. Consequently, the original designers of Unix decided that
      when a child dies before its parent, the kernel should put the child
      into a special process state. A process in this state is known as a
      <emphasis>zombie</emphasis>. Only a minimal skeleton of what was once
      the process—some basic kernel data structures containing potentially
      useful data—is retained. A process in this state waits for its parent to
      inquire about its status (a procedure known as <emphasis>waiting
      on</emphasis> the zombie process). Only after the parent obtains the
      information preserved about the terminated child does the process
      formally exit and cease to exist even as a zombie.</p>
<p>The Linux kernel provides several interfaces for obtaining
      information about terminated children. The simplest such interface,
      defined by POSIX, is wait( ):<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pid_t wait (int *status);</strong></p>
<p>A call to wait( ) returns the
      pid of a terminated child, or −1 on
      error. If no child has terminated, the call blocks until a child
      terminates. If a child has already terminated, the call returns
      immediately. Consequently, a call to wait(
      ) in response to news of a child's demise—say, upon receipt of
      a SIGCHLD—will always return without
      blocking.</p>
<p>On error, there are two possible errno values:</p>
<p>ECHILD</p>
<p>The calling process does not have any children.EINTR</p>
<p>A signal was received while waiting, and the call returned
            early.</p>
<p>If not NULL, the status pointer contains additional information
      about the child. Because POSIX allows implementations to define the bits
      in status as they see fit, the
      standard provides a family of macros for interpreting the
      parameter:<strong>#include &lt;sys/wait.h&gt;

int WIFEXITED (status);
int WIFSIGNALED (status);
int WIFSTOPPED (status);
int WIFCONTINUED (status);

int WEXITSTATUS (status);
int WTERMSIG (status);
int WSTOPSIG (status);
int WCOREDUMP (status);</strong></p>
<p>Either of the first two macros may return true (a nonzero value),
      depending on how the process terminated. The first, WIFEXITED, returns true if the process
      terminated normally—that is, if the process called _exit( ). In this case, the macro WEXITSTATUS provides the low-order eight bits
      that were passed to _exit( ).</p>
<p>WIFSIGNALED returns true if a
      signal caused the process' termination (see Chapter 9
      for further discussion on signals). In this case, WTERMSIG returns the number of the signal that
      caused the termination, and WCOREDUMP
      returns true if the process dumped core in response to receipt of the
      signal. WCOREDUMP is not defined by
      POSIX, although many Unix systems, Linux included, support it.</p>
<p>WIFSTOPPED and WIFCONTINUED return true if the process was
      stopped or continued, respectively, and is currently being traced via
      the ptrace( ) system call. These
      conditions are generally applicable only when implementing a debugger,
      although when used with waitpid( )
      (see the following subsection), they are used to implement job control,
      too. Normally, wait( ) is used only
      to communicate information about a process' termination. If WIFSTOPPED is true, WSTOPSIG provides the number of the signal
      that stopped the process. WIFCONTINUED is not defined by POSIX, although
      future standards define it for waitpid(
      ). As of the 2.6.10 Linux kernel, Linux provides this macro
      for wait( ), too.</p>
<p>Let's look at an example program that uses wait( ) to figure out what happened to its
      child:#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

int main (void)
{
        int status;
        pid_t pid;

        if (!fork (  ))
                return 1;

        pid = wait (&amp;status);
        if (pid == −1)
                perror ("wait");

        printf ("pid=%d\n", pid);

        if (WIFEXITED (status))
                printf ("Normal termination with exit status=%d\n",
                        WEXITSTATUS (status));

        if (WIFSIGNALED (status))
                printf ("Killed by signal=%d%s\n",
                        WTERMSIG (status),
                        WCOREDUMP (status) ? " (dumped core)" : "");

        if (WIFSTOPPED (status))
                printf ("Stopped by signal=%d\n",
                        WSTOPSIG (status));

        if (WIFCONTINUED (status))
                printf ("Continued\n");

       return 0;
}</p>
<p>This program forks a child, which immediately exits. The parent
      process then executes the wait( )
      system call to determine the status of its child. The process prints the
      child's pid, and how it died. Because in this case the child terminated
      by returning from main( ), we know
      that we will see output similar to the following:$ ./wait
pid=8529
Normal termination with exit status=1</p>
<p>If, instead of having the child return, we have it call abort( ), <sup>[22]</sup> which sends itself the SIGABRT signal, we will instead see something
      resembling the following:$ ./wait
pid=8678
Killed by signal=6</p>
<empty-line/>
<p><strong>Waiting for a Specific Process</strong></p>
<p>Observing the behavior of child processes is important. Often,
        however, a process has multiple children, and does not wish to wait
        for all of them, but rather for a specific child process. One solution
        would be to make multiple invocations of wait( ), each time noting the return value.
        This is cumbersome, though—what if you later wanted to check the
        status of a different terminated process? The parent would have to
        save all of the wait( ) output, in
        case it needed it later.</p>
<p>If you know the pid of the process you want to wait for, you can
        use the waitpid( ) system
        call:<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pid_t waitpid (pid_t pid, int *status, int options);</strong></p>
<p>The waitpid( ) call is a more
        powerful version of wait( ). Its
        additional parameters allow for fine-tuning.</p>
<p>The pid parameter specifies
        exactly which process or processes to wait for. Its values fall into
        four camps:</p>
<p>&lt; −1</p>
<p>Wait for any child process whose process group ID is equal
              to the absolute value of this value. For example, passing
              −500 waits for any process in
              process group 500.−1</p>
<p>Wait for any child process. This is the same behavior as
              wait( ).0</p>
<p>Wait for any child process that belongs to the same
              process group as the calling process.&gt; 0</p>
<p>Wait for any child process whose pid is exactly the value
              provided. For example, passing 500 waits for the child process with
              pid 500.</p>
<p>The status parameter works
        identically to the sole parameter to wait(
        ), and can be operated on using the macros discussed
        previously.</p>
<p>The options parameter is a
        binary OR of zero or more of the following options:</p>
<p>WNOHANG</p>
<p>Do not block, but return immediately if no matching child
              process has already terminated (or stopped or continued).WUNTRACED</p>
<p>If set, WIFSTOPPED is
              set, even if the calling process is not tracing the child
              process. This flag allows for the implementation of more general
              job control, as in a shell.WCONTINUED</p>
<p>If set, WIFCONTINUED is
              set even if the calling process is not tracing the child
              process. As with WUNTRACED,
              this flag is useful for implementing a shell.</p>
<p>On success, waitpid( )
        returns the pid of the process whose state has changed. If WNOHANG is specified, and the specified
        child or children have not yet changed state, waitpid( ) returns 0. On error, the call returns −1, and errno is set to one of three values:</p>
<p>ECHILD</p>
<p>The process or processes specified by the pid argument do not exist, or are not
              children of the calling process.EINTR</p>
<p>The WNOHANG option was
              not specified, and a signal was received while waiting.EINVAL</p>
<p>The options argument is
              invalid.</p>
<p>As an example, assume your program wants to grab the return
        value of the specific child with pid 1742 but return immediately if
        the child has not yet terminated. You might code up something similar
        to the following:int status;
pid_t pid;

pid = waitpid (1742, &amp;status, WNOHANG);
if (pid == −1)
        perror ("waitpid");
else {
        printf ("pid=%d\n", pid);

        if (WIFEXITED (status))
                printf ("Normal termination with exit status=%d\n",
                        WEXITSTATUS (status));

        if (WIFSIGNALED (status))
                printf ("Killed by signal=%d%s\n",
                        WTERMSIG (status),
                        WCOREDUMP (status) ? " (dumped core)" : "");
}</p>
<p>As a final example, note that the following usage of wait( ):wait (&amp;status);</p>
<p>is identical to the following usage of waitpid( ):waitpid (−1, &amp;status, 0);</p>
<empty-line/>
<p><strong>Even More Waiting Versatility</strong></p>
<p>For applications that require even greater versatility in their
        waiting-for-children functionality, the XSI extension to POSIX
        defines, and Linux provides, waitid(
        ):<strong>#include &lt;sys/wait.h&gt;

int waitid (idtype_t idtype,
            id_t id,
            siginfo_t *infop,
            int options);</strong></p>
<p>As with wait( ) and waitpid( ), waitid(
        ) is used to wait for and obtain information about the
        status change (termination, stopping, continuing) of a child process.
        It provides even more options, but it offers them with the tradeoff of
        greater complexity.</p>
<p>Like waitpid( ), waitid( ) allows the developer to specify
        what to wait for. However, waitid(
        ) accomplishes this task with not one, but two parameters.
        The idtype and id arguments specify which children to wait
        for, accomplishing the same goal as the sole pid argument in waitpid( ). idtype may be one of the following
        values:</p>
<p>P_PID</p>
<p>Wait for a child whose pid matches id.P_GID</p>
<p>Wait for a child whose process group ID matches id.P_ALL</p>
<p>Wait for any child; id
              is ignored.</p>
<p>The id argument is the rarely
        seen id_t type, which is a type
        representing a generic identification number. It is employed in case
        future implementations add a new idtype value, and supposedly offers greater
        insurance that the predefined type will be able to hold the newly
        created identifier. The type is guaranteed to be sufficiently large to
        hold any pid_t. On Linux,
        developers may use it as if it were a pid_t—for example, by directly passing
        pid_t values, or numeric constants.
        Pedantic programmers, however, are free to typecast.</p>
<p>The options parameter is a
        binary OR of one or more of the following values:</p>
<p>WEXITED</p>
<p>The call will wait for children (as determined by id and idtype) that have terminated.WSTOPPED</p>
<p>The call will wait for children that have stopped
              execution in response to receipt of a signal.WCONTINUED</p>
<p>The call will wait for children that have continued
              execution in response to receipt of a signal.WNOHANG</p>
<p>The call will never block, but will return immediately if
              no matching child process has already terminated (or stopped, or
              continued).WNOWAIT</p>
<p>The call will not remove the matching process from the
              zombie state. The process may be waited upon in the
              future.</p>
<p>Upon successfully waiting for a child, waitid( ) fills in the infop parameter, which must point to a valid
        siginfo_t type. The exact layout of
        the siginfo_t structure is
        implementation-specific, <sup>[23]</sup> but a handful of fields are valid after a call to
        waitid( ). That is, a successful
        invocation will ensure that the following fields are filled in:</p>
<p>si_pid</p>
<p>The child's pid.si_uid</p>
<p>The child's uid.si_code</p>
<p>Set to one of CLD_EXITED, CLD_KILLED, CLD_STOPPED, or CLD_CONTINUED in response to the child
              terminating, dying via signal, stopping via signal, or
              continuing via signal, respectively.si_signo</p>
<p>Set to SIGCHLD.si_status</p>
<p>If si_code is CLD_EXITED, this field is the exit
              code of the child process. Otherwise, this field is the number
              of the signal delivered to the child that caused the state
              change.</p>
<p>On success, waitid( ) returns
        0. On error, waitid( ) returns −1, and errno is set to one of the following
        values:</p>
<p>ECHLD</p>
<p>The process or processes delineated by id and idtype do not exist.EINTR</p>
<p>WNOHANG was not set in
              options, and a signal
              interrupted execution.EINVAL</p>
<p>The options argument or
              the combination of the id and
              idtype arguments is
              invalid.</p>
<p>The waitid( ) function
        provides additional, useful semantics not found in wait( ) and waitpid( ). In particular, the information
        retrievable from the siginfo_t
        structure may prove quite valuable. If such information is not needed,
        however, it may make more sense to stick to the simpler functions,
        which are supported on a wider range of systems, and thus are portable
        to more non-Linux systems.</p>
<empty-line/>
<p><strong>BSD Wants to Play: wait3( ) and wait4( )</strong></p>
<p>While waitpid( ) derives from
        AT&amp;T's System V Release 4, BSD takes its own route, and provides
        two other functions used to wait for a child to change
        state:<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sys/wait.h&gt;

pid_t wait3 (int *status,
             int options,
             struct rusage *rusage);

pid_t wait4 (pid_t pid,
             int *status,
             int options,
             struct rusage *rusage);</strong></p>
<p>The 3 and 4 come from the fact that these two
        functions are three- and four-parameter versions, respectively, of
        wait( ).</p>
<p>The functions work similarly to waitpid( ), with the exception of the
        rusage argument. The following
        wait3( ) invocation:pid = wait3 (status, options, NULL);</p>
<p>is equivalent to the following waitpid(
        ) call:pid = waitpid (−1, status, options);</p>
<p>And the following wait4( )
        invocation:pid = wait4 (pid, status, options, NULL);</p>
<p>is equivalent to this waitpid(
        ) call:pid = waitpid (pid, status, options);</p>
<p>That is, wait3( ) waits for
        any child to change state, and wait4(
        ) waits for the specific child identified by the pid parameter to change state. The options argument behaves the same as with
        waitpid( ).</p>
<p>As mentioned earlier, the big difference between these calls and
        waitpid( ) is the rusage parameter. If it is non-NULL, the function fills out the pointer at
        rusage with information about the
        child. This structure provides information about the child's resource
        usage:<strong>#include &lt;sys/resource.h&gt;

struct rusage {
        struct timeval ru_utime; /* user time consumed */
        struct timeval ru_stime; /* system time consumed */
        long ru_maxrss;   /* maximum resident set size */
        long ru_ixrss;    /* shared memory size */
        long ru_idrss;    /* unshared data size */
        long ru_isrss;    /* unshared stack size */
        long ru_minflt;   /* page reclaims */
        long ru_majflt;   /* page faults */
        long ru_nswap;    /* swap operations */
        long ru_inblock;  /* block input operations */
        long ru_oublock;  /* block output operations */
        long ru_msgsnd;   /* messages sent */
        long ru_msgrcv;   /* messages received */
        long ru_nsignals; /* signals received */
        long ru_nvcsw;    /* voluntary context switches */
        long ru_nivcsw;   /* involuntary context switches */
};</strong></p>
<p>I will address resource usage further in the next
        chapter.</p>
<p>On success, these functions return the pid of the process that
        changed state. On failure, they return −1, and set errno to one of the same error values
        returned by waitpid( ).</p>
<p>Because wait3( ) and wait4( ) are not POSIX-defined,<sup>[24]</sup> it is advisable to use them only when resource-usage
        information is critical. Despite the lack of POSIX standardization,
        however, nearly every Unix system supports these two calls.</p>
<empty-line/>
<p><strong>Launching and Waiting for a New Process</strong></p>
<p>Both ANSI C and POSIX define an interface that couples spawning
        a new process and waiting for its termination—think of it as
        synchronous process creation. If a process is spawning a child only to
        immediately wait for its termination, it makes sense to use this
        interface:<strong>#define _XOPEN_SOURCE    /* if we want WEXITSTATUS, etc. */
#include &lt;stdlib.h&gt;

int system (const char *command);</strong></p>
<p>The system( ) function is so
        named because the synchronous process invocation is called
        <emphasis>shelling out to the system</emphasis>. It is common to use
        system( ) to run a simple utility
        or shell script, often with the explicit goal of simply obtaining its
        return value.</p>
<p>A call to system( ) invokes
        the command provided by the command
        parameter, including any additional arguments. The command parameter is suffixed to the
        arguments <emphasis>/bin/sh -c</emphasis>. In this sense, the
        parameter is passed wholesale to the shell.</p>
<p>On success, the return value is the return status of the command
        as provided by wait( ).
        Consequently, the exit code of the executed command is obtained via
        WEXITSTATUS. If invoking
        <emphasis>/bin/sh</emphasis> itself failed, the value given by
        WEXITSTATUS is the same as that
        returned by exit(127). Because it
        is also possible for the invoked command to return 127, there is no surefire method to check
        whether the shell itself returned that error. On error, the call
        returns −1.</p>
<p>If command is NULL, system(
        ) returns a nonzero value if the shell
        <emphasis>/bin/sh</emphasis> is available, and 0 otherwise.</p>
<p>During execution of the command, SIGCHLD is blocked, and SIGINT and SIGQUIT are ignored. Ignoring SIGINT and SIGQUIT has several implications,
        particularly if system( ) is
        invoked inside a loop. If calling system(
        ) from within a loop, you should ensure that the program
        properly checks the exit status of the child. For example:do {
        int ret;

        ret = system ("pidof rudderd");
        if (WIFSIGNALED (ret) &amp;&amp;
            (WTERMSIG (ret) == SIGINT ||
             WTERMSIG (ret) == SIGQUIT))
                break; /* or otherwise handle */
} while (1);</p>
<p>Implementing system( ) using
        fork( ), a function from the exec
        family, and waitpid( ) is a useful
        exercise. You should attempt this yourself, as it ties together many
        of the concepts of this chapter. In the spirit of completeness,
        however, here is a sample implementation:/*
 * my_system - synchronously spawns and waits for the command
 * "/bin/sh -c &lt;cmd&gt;".
 *
 * Returns −1 on error of any sort, or the exit code from the
 * launched process. Does not block or ignore any signals.
 */
int my_system (const char *cmd)
{
        int status;
        pid_t pid;

        pid = fork (  );
        if (pid == −1)
                return −1;
        else if (pid == 0) {
                const char *argv[4];

                argv[0] = "sh";
                argv[1] = "-c";
                argv[2] = cmd;
                argv[3] = NULL;
                execv ("/bin/sh", argv);

                exit (−1);
        }

        if (waitpid (pid, &amp;status, 0) == −1)
                return −1;
        else if (WIFEXITED (status))
                return WEXITSTATUS (status);

        return −1;
}</p>
<p>Note that this example does not block or disable any signals,
        unlike the official system( ). This
        behavior may be better or worse, depending on your program's
        situation, but leaving at least SIGINT unblocked is often smart because it
        allows the invoked command to be interrupted in the way a user
        normally expects. A better implementation could add additional
        pointers as parameters that, when non-NULL, signify errors currently
        differentiable from each other. For example, one might add fork_failed and shell_failed.</p>
<empty-line/>
<p><strong>Zombies</strong></p>
<p>As discussed earlier, a process that has terminated, but that
        has not yet been waited upon by its parent is called a "zombie."
        Zombie processes continue to consume system resources, although only a
        small percentage—enough to maintain a mere skeleton of what they once
        were. These resources remain so that parent processes that want to
        check up on the status of their children can obtain information
        relating to the life and termination of those processes. Once the
        parent does so, the kernel cleans up the process for good and the
        zombie ceases to exist.</p>
<p>However, anyone who has used Unix for a good while is sure to
        have seen zombie processes sitting around. These processes, often
        called <emphasis>ghosts</emphasis>, have irresponsible parents. If
        your application forks a child process, it is your application's
        responsibility (unless it is short-lived, as you will see shortly) to
        wait on the child, even if it will merely discard the information
        gleaned. Otherwise, all of your process' children will become ghosts
        and live on, crowding the system's process listing, and generating
        disgust at your application's sloppy implementation.</p>
<p>What happens, however, if the parent process dies before the
        child, or if it dies before it has a chance to wait on its zombie
        children? Whenever a process terminates, the Linux kernel walks a list
        of its children, and <emphasis>reparents</emphasis> all of them to the
        init process (the process with a pid value of 1). This guarantees that
        no process is ever without an immediate parent. The init process, in
        turn, periodically waits on all of its children, ensuring that none
        remain zombies for too long—no ghosts! Thus, if a parent dies before
        its children or does not wait on its children before exiting, the
        child processes are eventually reparented to init and waited upon,
        allowing them to fully exit. Although doing so is still considered
        good practice, this safeguard means that short-lived processes need
        not worry excessively about waiting on all of their children.</p>
<empty-line/>
<p><strong>Users and Groups</strong></p>
<p>As mentioned earlier in this chapter, and discussed in Chapter 1, processes are
      associated with users and groups. The user and group identifiers are
      numeric values represented by the C types uid_t and gid_t, respectively. The mapping between
      numeric values and human-readable names—as in the root user having the
      uid 0—is performed in user space using the files
      <emphasis>/etc/passwd</emphasis> and <emphasis>/etc/group</emphasis>.
      The kernel deals only with the numeric values.</p>
<p>In a Linux system, a process' user and group IDs dictate the
      operations that the process may undertake. Processes must therefore run
      under the appropriate users and groups. Many processes run as the root
      user. However, best practices in software development encourage the
      doctrine of <emphasis>least-privileged</emphasis> rights, meaning that a
      process should execute with the minimum level of rights possible. This
      requirement is dynamic: if a process requires root privileges to perform
      an operation early in its life, but does not require these extensive
      privileges thereafter, it should drop root privileges as soon as
      possible. To this end, many processes—particularly those that need root
      privileges to carry out certain operations—often manipulate their user
      or group IDs.</p>
<p>Before we can look at how this is accomplished, we need to cover
      the complexities of user and group IDs.</p>
<empty-line/>
<p><strong>Real, Effective, and Saved User and Group IDs</strong></p>
<p><strong>Tip</strong></p>
<p>The following discussion focuses on user IDs, but the
          situation is identical for group IDs.</p>
<p>There are, in fact, not one, but four user IDs associated with a
        process: the real, effective, saved, and filesystem user IDs. The
        <emphasis>real user ID</emphasis> is the uid of the user who
        originally ran the process. It is set to the real user ID of the
        process' parent, and does not change during an exec call. Normally,
        the login process sets the real user ID of the user's login shell to
        that of the user, and all of the user's processes continue to carry
        this user ID. The superuser (root) may change the real user ID to any
        value, but no other user can change this value.</p>
<p>The <emphasis>effective user ID</emphasis> is the user ID that
        the process is currently wielding. Permission verifications normally
        check against this value. Initially, this ID is equal to the real user
        ID, because when a process forks, the effective user ID of the parent
        is inherited by the child. Furthermore, when the process issues an
        exec call, the effective user is usually unchanged. But, it is during
        the exec call that the key difference between real and effective IDs
        emerges: by executing a <emphasis>setuid</emphasis>
        (<emphasis>suid</emphasis>) binary, the process can change its
        effective user ID. To be exact, the effective user ID is set to the
        user ID of the owner of the program file. For instance, because the
        <emphasis>/usr/bin/passwd</emphasis> file is a setuid file, and root
        is its owner, when a normal user's shell spawns a process to exec this
        file, the process takes on the effective user ID of root regardless of
        who the executing user is.</p>
<p>Nonprivileged users may set the effective user ID to the real or
        the saved user ID, as you'll see momentarily. The superuser may set
        the effective user ID to any value.</p>
<p>The <emphasis>saved user ID</emphasis> is the process' original
        effective user ID. When a process forks, the child inherits the saved
        user ID of its parent. Upon an exec call, however, the kernel sets the
        saved user ID to the effective user ID, thereby making a record of the
        effective user ID at the time of the exec. Nonprivileged users may not
        change the saved user ID; the superuser can change it to the same
        value as the real user ID.</p>
<p>What is the point of all these values? The effective user ID is
        the value that matters: it's the user ID that is checked in the course
        of validating a process' credentials. The real user ID and saved user
        ID act as surrogates, or potential user ID values that non-root
        processes are allowed to switch to and from. The real user ID is the
        effective user ID belonging to the user actually running the program,
        and the saved user ID is the effective user ID from before a suid
        binary caused a change during exec.</p>
<empty-line/>
<p><strong>Changing the Real or Saved User or Group ID</strong></p>
<p>The user and group IDs are set via two system calls:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int setuid (uid_t uid);
int setgid (gid_t gid);</strong></p>
<p>A call to setuid( ) sets the
        effective user ID of the current process. If the current effective
        user ID of the process is 0 (root), the real and saved user IDs are
        also set. The root user may provide any value for uid, thereby setting all three of the user
        ID values to uid. A nonroot user is
        allowed only to provide the real or saved user ID for uid. In other words, a nonroot user can only
        set the effective user ID to one of those values.</p>
<p>On success, setuid( ) returns
        0. On error, the call returns
        −1, and errno is set to one of the following
        values:</p>
<p>EAGAIN</p>
<p>uid is different from
              the real user ID, and setting the real user ID to uid will put the user over its
              NPROC rlimit (which specifies
              the number of processes that a user may own).EPERM</p>
<p>The user is not root, and uid is neither the effective nor the
              saved user ID.</p>
<p>The preceding discussion also applies to groups—simply replace
        setuid( ) with setgid( ), and uid with gid.</p>
<empty-line/>
<p><strong>Changing the Effective User or Group ID</strong></p>
<p>Linux provides two POSIX-mandated functions for setting the
        effective user and group IDs of the currently executing
        process:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int seteuid (uid_t euid);
int setegid (gid_t egid);</strong></p>
<p>A call to seteuid( ) sets the
        effective user ID to euid. Root may
        provide any value for euid. Nonroot
        users may set the effective user ID only to the real or saved user ID.
        On success, seteuid( ) returns
        0. On failure, it returns −1, and sets errno to EPERM, which signifies that the current
        process is not owned by root, and that euid is equal to neither the real nor the
        saved user ID.</p>
<p>Note that in the nonroot case, seteuid(
        ) and setuid( ) behave
        the same. It is thus standard practice and a good idea to always use
        seteuid( ), unless your process
        tends to run as root, in which case setuid(
        ) makes more sense.</p>
<p>The preceding discussion also applies to groups—simply replace
        seteuid( ) with setegid( ), and euid with egid.</p>
<empty-line/>
<p><strong>Changing the User and Group IDs, BSD Style</strong></p>
<p>BSD settled on its own interfaces for setting the user and group
        IDs. Linux provides these interfaces for compatibility:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int setreuid (uid_t ruid, uid_t euid);
int setregid (gid_t rgid, gid_t egid);</strong></p>
<p>A call to setreuid( ) sets
        the real and effective user IDs of a process to ruid and euid, respectively. Specifying a value of
        −1 for either parameter leaves the
        associated user ID unchanged. Nonroot processes are only allowed to
        set the effective user ID to the real or saved user ID, and the real
        user ID to the effective user ID. If the real user ID is changed, or
        if the effective user ID is changed to a value not equal to the
        previous real user ID value, the saved user ID is changed to the new
        effective user ID. At least, that's how Linux and most other Unix
        systems react to such changes; the behavior is left undefined by
        POSIX.</p>
<p>On success, setreuid( )
        returns 0. On failure, it returns
        −1, and sets errno to EPERM, which signifies that the current
        process is not owned by root, and that euid is equal to neither the real nor the
        saved user ID, or that ruid is not
        equal to the effective user ID.</p>
<p>The preceding discussion also applies to groups—simply replace
        setreuid( ) with setregid( ), ruid with rgid, and euid with egid.</p>
<empty-line/>
<p><strong>Changing the User and Group IDs, HP-UX Style</strong></p>
<p>You may feel the situation is growing insane, but HP-UX,
        Hewlett-Packard's Unix system, has also introduced its own mechanisms
        for setting a process' user and group IDs. Linux follows along and
        provides these interfaces:<strong>#define _GNU_SOURCE
#include &lt;unistd.h&gt;

int setresuid (uid_t ruid, uid_t euid, uid_t suid);
int setresgid (gid_t rgid, gid_t egid, gid_t sgid);</strong></p>
<p>A call to setresuid( ) sets
        the real, effective, and saved user IDs to ruid, euid, and suid, respectively. Specifying a value of
        −1 for any of the parameters leaves
        its value unchanged.</p>
<p>The root user may set any user ID to any value. Nonroot users
        may set any user ID to the current real, effective, or saved user ID.
        On success, setuid( ) returns
        0. On error, the call returns
        −1, and errno is set to one of the following
        values:</p>
<p>EAGAIN</p>
<p>uid does not match the
              real user ID, and setting the real user ID to uid will put the user over its
              NPROC rlimit (which specifies
              the number of processes that a user may own).EPERM</p>
<p>The user is not root and attempted to set new values for
              the real, effective, or saved user ID that did not match one of
              the current real, effective, or saved user IDs.</p>
<p>The preceding discussion also applies to groups—simply replace
        setresuid( ) with setresgid( ), ruid with rgid, euid with egid, and suid with sgid.</p>
<empty-line/>
<p><strong>Preferred User/Group ID Manipulations</strong></p>
<p>Nonroot processes should use seteuid(
        ) to change their effective user IDs. Root processes should
        use setuid( ) if they wish to
        change all three user IDs, and seteuid(
        ) if they wish to temporarily change just the effective user
        ID. These functions are simple, and behave in accordance with POSIX,
        properly taking into account saved user IDs.</p>
<p>Despite providing additional functionality, the BSD and HP-UX
        style functions do not allow for any useful changes that setuid( ) and seteuid( ) do not.</p>
<empty-line/>
<p><strong>Support for Saved User IDs</strong></p>
<p>The existence of the saved user and group IDs is mandated by
        IEEE Std 1003.1-2001 (POSIX 2001), and Linux has supported these IDs
        since the early days of the 1.1.38 kernel. Programs written only for
        Linux may rest assured of the existence of the saved user IDs.
        Programs written for older Unix systems should check for the macro
        _POSIX_SAVED_IDS before making any
        references to a saved user or group ID.</p>
<p>In the absence of saved user and group IDs, the preceding
        discussions are still valid; just ignore any parts of the rules that
        mention the saved user or group ID.</p>
<empty-line/>
<p><strong>Obtaining the User and Group IDs</strong></p>
<p>These two system calls return the real user and group IDs,
        respectively:<strong>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

uid_t getuid (void);
gid_t getgid (void);</strong></p>
<p>They cannot fail. Likewise, these two system calls return the
        effective user and group IDs, respectively:<strong>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

uid_t geteuid (void);
gid_t getegid (void);</strong></p>
<p>These two system calls cannot fail, either.</p>
<empty-line/>
<p><strong>Sessions and Process Groups</strong></p>
<p>Each process is a member of a <emphasis>process group</emphasis>,
      which is a collection of one or more processes generally associated with
      each other for the purposes of <emphasis>job control</emphasis>. The
      primary attribute of a process group is that signals may be sent to all
      processes in the group: a single action can terminate, stop, or continue
      all processes in the same process group.</p>
<p>Each process group is identified by a <emphasis>process group
      ID</emphasis> (pgid), and has a <emphasis>process group
      leader</emphasis>. The process group ID is equal to the pid of the
      process group leader. Process groups exist so long as they have one
      remaining member. Even if the process group leader terminates, the
      process group continues to exist.</p>
<p>When a new user first logs into a machine, the login process
      creates a new <emphasis>session</emphasis> that consists of a single
      process, the user's <emphasis>login shell</emphasis>. The login shell
      functions as the <emphasis>session leader</emphasis>. The pid of the
      session leader is used as the <emphasis>session ID</emphasis>. A session
      is a collection of one or more process groups. Sessions arrange a
      logged-in user's activities, and associate that user with a
      <emphasis>controlling terminal</emphasis>, which is a specific tty
      device that handles the user's terminal I/O. Consequently, sessions are
      largely the business of shells. In fact, nothing else really cares about
      them.</p>
<p>While process groups provide a mechanism to address signals to all
      of their members, making job control and other shell functions easy,
      sessions exist to consolidate logins around controlling terminals.
      Process groups in a session are divided into a single
      <emphasis>foreground process group</emphasis>, and zero or more
      <emphasis>background process groups</emphasis>. When a user exits a
      terminal, a SIGQUIT is sent to all
      processes in the foreground process group. When a network disconnect is
      detected by a terminal, a SIGHUP is
      sent to all processes in the foreground process group. When the user
      enters the interrupt key (generally Ctrl-C), a SIGINT is sent to all processes in the
      foreground process group. Thus, sessions make managing terminals and
      logins easier for shells.</p>
<p>As a review, say a user logs into the system and her login shell,
      <emphasis>bash</emphasis>, has the pid 1700. The user's
      <emphasis>bash</emphasis> instance is now the sole member and leader of
      a new process group, with the process group ID 1700. This process group
      is inside a new session with the session ID 1700, and
      <emphasis>bash</emphasis> is the sole member and the leader of this
      session. New commands that the user runs in the shell run in new process
      groups within session 1700. One of these process groups—the one
      connected directly to the user and in control of the terminal—is the
      <emphasis>foreground process group</emphasis>. All the other process
      groups are <emphasis>background process groups</emphasis>.</p>
<p>On a given system, there are many sessions: one for each user
      login session, and others for processes not tied to user login sessions,
      such as daemons. Daemons tend to create their own sessions to avoid the
      issues of association with other sessions that may exit.</p>
<p>Each of these sessions contains one or more process groups, and
      each process group contains at least one process. Process groups that
      contain more than one process are generally implementing job
      control.</p>
<p>A command on the shell such as this one:$ cat ship-inventory.txt | grep booty | sort</p>
<p>results in one process group containing three processes. This way,
      the shell can signal all three processes in one fell swoop. Because the
      user has typed this command on the console without a trailing ampersand,
      we can also say that this process group is in the foreground. Figure 5-1 illustrates the
      relationship between sessions, process groups, processes, and
      controlling terminals.</p>
<p><image l:href="#img_3"/></p>
<p><emphasis>Figure 5-1. Relationship between sessions, process groups, processes, and
        controlling terminals</emphasis></p>
<p>Linux provides several interfaces for setting and retrieving the
      session and process group associated with a given process. These are
      primarily of use for shells, but can also be useful to processes such as
      daemons that want to get out of the business of sessions and process
      groups altogether.</p>
<empty-line/>
<p><strong>Session System Calls</strong></p>
<p>Shells create new sessions on login. They do so via a special
        system call, which makes creating a new session easy:<strong>#include &lt;unistd.h&gt;

pid_t setsid (void);</strong></p>
<p>A call to setsid( ) creates a
        new session, assuming that the process is not already a process group
        leader. The calling process is made the session leader and sole member
        of the new session, which has no controlling tty. The call also
        creates a new process group inside the session, and makes the calling
        process the process group leader and sole member. The new session's
        and process group's IDs are set to the calling process' pid.</p>
<p>In other words, setsid( )
        creates a new process group inside of a new session, and makes the
        invoking process the leader of both. This is useful for daemons, which
        do not want to be members of existing sessions, or to have controlling
        terminals, and for shells, which want to create a new session for each
        user upon login.</p>
<p>On success, setsid( ) returns
        the session ID of the newly created session. On error, the call
        returns −1. The only possible
        errno code is EPERM, which indicates that the process is
        currently a process group leader. The easiest way to ensure that any
        given process is not a process group leader is to fork, have the
        parent terminate, and have the child perform the setsid( ). For example:pid_t pid;

pid = fork (  );
if (pid == −1) {
        perror ("fork");
        return −1;
} else if (pid != 0)
        exit (EXIT_SUCCESS);

if (setsid (  ) == −1) {
        perror ("setsid");
        return −1;
}</p>
<p>Obtaining the current session ID, while less useful, is also
        possible:<strong>#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;

pid_t getsid (pid_t pid);</strong></p>
<p>A call to getsid( ) returns
        the session ID of the process identified by pid. If the pid argument is 0, the call returns the session ID of the
        calling process. On error, the call returns −1. The only possible errno value is ESRCH, indicating that pid does not correspond to a valid process.
        Note that other Unix systems may also set errno to EPERM, indicating that pid and the invoking process do not belong
        to the same session; Linux does not return this error, and happily
        returns the session ID of any process.</p>
<p>Usage is rare and primarily for diagnostic purposes:pid_t sid;

sid = getsid (0);
if (sid == −1)
        perror ("getsid"); /* should not be possible */
else
        printf ("My session id=%d\n", sid);</p>
<empty-line/>
<p><strong>Process Group System Calls</strong></p>
<p>A call to setpgid( ) sets the
        process group ID of the process identified by pid to pgid:<strong>#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;

int setpgid (pid_t pid, pid_t pgid);</strong></p>
<p>The current process is used if the pid argument is 0. If pgid is 0, the process ID of the process identified
        by pid is used as the process group
        ID.</p>
<p>On success, setpgid( )
        returns 0. Success is contingent on
        several conditions:</p>
<p>The process identified by pid must be the calling process, or a
            child of the calling process, that has not issued an exec call,
            and is in the same session as the calling process.</p>
<p>The process identified by pid must not be a session leader.</p>
<p>If pgid already exists,
            it must be in the same session as the calling process.</p>
<p>pgid must be
            nonnegative.</p>
<p>On error, the call returns −1, and sets errno to one of the following error
        codes:</p>
<p>EACCESS</p>
<p>The process identified by pid is a child of the calling process
              that has already invoked exec.EINVAL</p>
<p>pgid is less than
              0.EPERM</p>
<p>The process identified by pid is a session leader, or is in a
              different session from the calling process. Alternatively, an
              attempt was made to move a process into a process group inside a
              different session.ESRCH</p>
<p>pid is not the current
              process, 0, or a child of the
              current process.</p>
<p>As with sessions, obtaining a process' process group ID is
        possible, although less useful:<strong>#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;

pid_t getpgid (pid_t pid);</strong></p>
<p>A call to getpgid( ) returns
        the process group ID of the process identified by pid. If pid is 0,
        the process group ID of the current process is used. On error, it
        returns −1, and sets errno to ESRCH, the only possible value, indicating
        that pid is an invalid process
        identifier.</p>
<p>As with getsid( ), usage is
        largely for diagnostic purposes:pid_t pgid;

pgid = getpgid (0);
if (pgid == −1)
        perror ("getpgid"); /* should not be possible */
else
        printf ("My process group id=%d\n", pgid);</p>
<empty-line/>
<p><strong>Obsolete Process Group Functions</strong></p>
<p>Linux supports two older interfaces from BSD for manipulating or
        obtaining the process group ID. As they are less useful than the
        previously discussed system calls, new programs should use them only
        when portability is stringently required. setpgrp( ) can be used to set the process
        group ID:<strong>#include &lt;unistd.h&gt;

int setpgrp (void);</strong></p>
<p>This invocation:if (setpgrp (  ) == −1)
        perror ("setpgrp");</p>
<p>is identical to the following invocation:if (setpgid (0,0) == −1)
        perror ("setpgid");</p>
<p>Both attempt to assign the current process to the process group
        with the same number as the current process' pid, returning 0 on success, and −1 on failure. All of the errno values of setpgid( ) are applicable to setpgrp( ), except ERSCH.</p>
<p>Similarly, a call to getpgrp(
        ) can be used to retrieve the process group ID:<strong>#include &lt;unistd.h&gt;

pid_t getpgrp (void);</strong></p>
<p>This invocation:pid_t pgid = getpgrp (  );</p>
<p>is identical to:pid_t pgid = getpgid (0);</p>
<p>Both return the process group ID of the calling process. The
        function getpgid( ) cannot
        fail.</p>
<empty-line/>
<p><strong>Daemons</strong></p>
<p>A <emphasis>daemon</emphasis> is a process that runs in the
      background, not connecting to any controlling terminal. Daemons are
      normally started at boot time, are run as root or some other special
      user (such as <emphasis>apache</emphasis> or
      <emphasis>postfix</emphasis>), and handle system-level tasks. As a
      convention, the name of a daemon often ends in <emphasis>d</emphasis>
      (as in <emphasis>crond</emphasis> and <emphasis>sshd</emphasis>), but
      this is not required, or even universal.</p>
<p>The name derives from Maxwell's demon, an 1867 thought experiment
      by the physicist James Maxwell. Daemons are also supernatural beings in
      Greek mythology, existing somewhere between humans and the gods and
      gifted with powers and divine knowledge. Unlike the demons of
      Judeo-Christian lore, the Greek daemon need not be evil. Indeed, the
      daemons of mythology tended to be aides to the gods, performing tasks
      that the denizens of Mount Olympus found themselves unwilling to do—much
      as Unix daemons perform tasks that foreground users would rather
      avoid.</p>
<p>A daemon has two general requirements: it must run as a child of
      init, and it must not be connected to a terminal.</p>
<p>In general, a program performs the following steps to become a
      daemon:</p>
<p>Call fork( ). This creates
          a new process, which will become the daemon.</p>
<p>In the parent, call exit(
          ). This ensures that the original parent (the daemon's
          grandparent) is satisfied that its child terminated, that the
          daemon's parent is no longer running, and that the daemon is not a
          process group leader. This last point is a requirement for the
          successful completion of the next step.</p>
<p>Call setsid( ), giving the
          daemon a new process group and session, both of which have it as
          leader. This also ensures that the process has no associated
          controlling terminal (as the process just created a new session, and
          will not assign one).</p>
<p>Change the working directory to the root directory via
          chdir( ). This is done because
          the inherited working directory can be anywhere on the filesystem.
          Daemons tend to run for the duration of the system's uptime, and you
          don't want to keep some random directory open, and thus prevent an
          administrator from unmounting the filesystem containing that
          directory.</p>
<p>Close all file descriptors. You do not want to inherit open
          file descriptors, and, unaware, hold them open.</p>
<p>Open file descriptors 0, 1, and 2 (standard in, standard out,
          and standard error) and redirect them to
          <emphasis>/dev/null</emphasis>.</p>
<p>Following these rules, here is a program that daemonizes
      itself:#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/fs.h&gt;

int main (void)
{
        pid_t pid;
        int i;

        /* create new process */
        pid = fork (  );
        if (pid == −1)
                return −1;
        else if (pid != 0)
                exit (EXIT_SUCCESS);

        /* create new session and process group */
        if (setsid (  ) == −1)
                return −1;

        /* set the working directory to the root directory */
        if (chdir ("/") == −1)
                return −1;

        /* close all open files--NR_OPEN is overkill, but works */
        for (i = 0; i &lt; NR_OPEN; i++)
                close (i);

        /* redirect fd's 0,1,2 to /dev/null */
        open ("/dev/null", O_RDWR);     /* stdin */
        dup (0);                        /* stdout */
        dup (0);                        /* stderror */

        /* do its daemon thing... */

        return 0;
}</p>
<p>Most Unix systems provide a daemon(
      ) function in their C library that automates these steps,
      turning the cumbersome into the simple:<strong>#include &lt;unistd.h&gt;

int daemon (int nochdir, int noclose);</strong></p>
<p>If nochdir is nonzero, the
      daemon will not change its working directory to the root directory. If
      noclose is nonzero, the daemon will
      not close all open file descriptors. These options are useful if the
      parent process already set up these aspects of the daemonizing
      procedure. Normally, though, one passes 0 for both of these parameters.</p>
<p>On success, the call returns 0.
      On failure, the call returns −1, and
      errno is set to a valid error code
      from fork( ) or setsid( ).</p>
<empty-line/>
<p><strong>Conclusion</strong></p>
<p>We covered the fundamentals of Unix process management, from
      process creation to process termination, in this chapter. In the next
      chapter, we will cover more advanced process management interfaces, as
      well as interfaces for changing the scheduling behavior of
      processes.</p>
<empty-line/><empty-line/>
<p><sup>[21] </sup><sup>*</sup> Although not currently part
              of the 2.6 Linux kernel, a patch implementing copy-on-write
              shared page table entries has been floated on the Linux Kernel
              Mailing List (<emphasis>lkml</emphasis>). Should it be merged,
              there would be absolutely no benefit to using vfork( ).</p>
<p><sup>[22] </sup><sup>*</sup> Defined in the header &lt;stdlib.h&gt;.</p>
<p><sup>[23] </sup><sup>*</sup> Indeed, the siginfo_t structure is very complicated
            on Linux. For its definition, see
            <emphasis>/usr/include/bits/siginfo.h</emphasis>. We will study
            this structure in more detail in Chapter 9.</p>
<p><sup>[24] </sup><sup>*</sup> wait3(
            ) was included in the original Single UNIX
            Specification, but it has since been removed.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 6. Advanced Process Management</strong></p>
<p>Chapter 5 introduced the abstraction of
    the process, and discussed the kernel interfaces used to create, control,
    and destroy it. This chapter builds on those ideas, beginning with a
    discussion of the Linux process scheduler and its scheduling algorithm,
    and then presenting advanced process management interfaces. These system
    calls manipulate the scheduling behavior and semantics of a process,
    influencing the scheduler's behavior in pursuit of an application or
    user-dictated goal.</p>
<empty-line/>
<p><strong>Process Scheduling</strong></p>
<p>The <emphasis>process scheduler</emphasis> is the component of a
      kernel that selects which process to run next. In other words, the
      process scheduler—or simply the <emphasis>scheduler</emphasis>—is the
      subsystem of the kernel that divides the finite resource of processor
      time among a system's processes. In deciding which processes can run and
      when, the scheduler is responsible for maximizing processor usage while
      simultaneously providing the impression that multiple processes are
      executing concurrently and seamlessly.</p>
<p>In this chapter, we will talk a lot about
      <emphasis>runnable</emphasis> processes. A runnable process is one that,
      first of all, is not blocked. Processes that interact with users, read
      and write files heavily, or respond to I/O or network events, tend to
      spend a lot of time blocked while they wait for resources to become
      available, and they are not runnable during those long periods (long,
      that is, compared to the time it takes to execute machine instructions).
      A runnable process must also have at least part of its
      <emphasis>timeslice</emphasis>—the amount of time the scheduler has
      decided to let it run—remaining. The kernel places all runnable
      processes on a <emphasis>run list</emphasis>. Once a process has
      exhausted its timeslice, it is removed from this list, and not
      considered runnable again until all other runnable processes have also
      exhausted their timeslices.</p>
<p>Given only one runnable process (or none at all), the job of a
      process scheduler is trivial. A scheduler proves its worth, however,
      when there are more runnable processes than processors. In such a
      situation, some processes must obviously run while others wait. Deciding
      which processes to run, when, and for how long is the process
      scheduler's fundamental responsibility.</p>
<p>An operating system on a single-processor machine is
      <emphasis>multitasking</emphasis> if it can interleave the execution of
      more than one process, giving the illusion of there being more than one
      process running at the same time. On multiprocessor machines, a
      multitasking operating system allows processes to actually run in
      parallel, on different processors. A nonmultitasking operating system,
      such as DOS, can run only one application at a time.</p>
<p>Multitasking operating systems come in two variants:
      <emphasis>cooperative</emphasis> and <emphasis>preemptive</emphasis>.
      Linux implements the latter form of multitasking, where the scheduler
      decides when one process is to stop running, and a different process is
      to resume running. We call the act of suspending a running process in
      lieu of another <emphasis>preemption</emphasis>. Again, the length of
      time a process runs before the scheduler preempts it is known as the
      process' timeslice (so called because the scheduler allocates each
      runnable process a "slice" of the processor's time).</p>
<p>In cooperative multitasking, conversely, a process does not stop
      running until it voluntarily decides to do so. We call the act of a
      process voluntarily suspending itself <emphasis>yielding</emphasis>.
      Ideally, processes yield often, but the operating system is unable to
      enforce this behavior. A rude or broken program can run for a longer
      than optimal time, or even bring down the entire system. Due to the
      shortcomings of this approach, modern operating systems are almost
      universally preemptively multitasked; Linux is no exception.</p>
<p>The <emphasis>O(1) process scheduler</emphasis>, introduced during
      the 2.5 kernel series, is the heart of Linux scheduling.<sup>[25]</sup> The Linux scheduling algorithm provides preemptive
      multitasking along with support for multiple processors, processor
      affinity, nonuniform memory access (NUMA) configurations,
      multithreading, real-time processes, and user-provided
      priorities.</p>
<empty-line/>
<p><strong>Big-Oh Notation</strong></p>
<p>O(1)—read "big oh of one"—is an example of <emphasis>big-oh
        notation</emphasis>, which is used to represent an algorithm's
        complexity and scalability. Formally,</p>
<p><image l:href="#img_4"/></p>
<p>In English, the value of some algorithm, <emphasis>f</emphasis>,
        is always less than or equal to the value of <emphasis>g</emphasis>
        multiplied by some arbitrary constant, so long as the input
        <emphasis>x</emphasis> is larger than some initial value
        <emphasis>x'</emphasis>. That is, <emphasis>g</emphasis> is as big as
        or bigger than <emphasis>f</emphasis>; <emphasis>g</emphasis> bounds
        <emphasis>f</emphasis> from above.</p>
<p>O(1), therefore, implies that the algorithm in question is
        valued at less than some constant, <emphasis>c</emphasis>. All this
        pomp and circumstance boils down to one important promise: the Linux
        process scheduler will always perform the same, regardless of the
        number of processes on the system. This is important because the act
        of picking a new process to run would seemingly involve at least one,
        if not multiple, iterations over lists of processes. With more naïve
        schedulers (including those used by earlier versions of Linux), as the
        number of processes on a system grows, such iterations quickly grow to
        become a potential bottleneck. At best, such loops introduce
        uncertainty—a lack of determinism—into the scheduling process.</p>
<p>The Linux scheduler, operating in constant time regardless of
        any factor, has no such bottleneck.</p>
<empty-line/>
<p><strong>Timeslices</strong></p>
<p>The timeslice that Linux allots to each process is an important
        variable in the overall behavior and performance of a system. If
        timeslices are too large, processes must wait a long time in between
        executions, minimizing the appearance of concurrent execution. The
        user may become frustrated at the perceptible delay. Conversely, if
        the timeslices are too small, a significant amount of the system's
        time is spent switching from one application to another, and benefits
        such as temporal locality are lost.</p>
<p>Consequently, determining an ideal timeslice is not easy. Some
        operating systems give processes large timeslices, hoping to maximize
        system throughput and overall performance. Other operating systems
        give processes very small timeslices, hoping to provide a system with
        excellent interactive performance. As we will see, Linux aims for the
        best of both worlds by dynamically allocating process
        timeslices.</p>
<p>Note that a process need not consume all of its timeslice in one
        go. A process assigned a 100 ms timeslice might run for 20 ms, and
        then block on some resource, such as keyboard input. The scheduler
        will temporarily remove this process from the list of runnable
        processes. When the blocked resource becomes available—in this case,
        when the keyboard buffer becomes nonempty—the scheduler wakes up the
        process. The process can then continue running until it exhausts its
        remaining 80 ms of timeslice, or until it again blocks on a
        resource.</p>
<empty-line/>
<p><strong>I/O- Versus Processor-Bound Processes</strong></p>
<p>Processes that continually consume all of their available
        timeslices are considered <emphasis>processor-bound</emphasis>. Such
        processes are hungry for CPU time, and will consume all that the
        scheduler gives them. The simplest trivial example is an infinite
        loop. Other examples include scientific computations, mathematical
        calculations, and image processing.</p>
<p>On the other hand, processes that spend more time blocked
        waiting for some resource than executing are considered
        <emphasis>I/O-bound</emphasis>. I/O-bound processes are often issuing
        and waiting for file I/O, blocking on keyboard input, or waiting for
        the user to move the mouse. Examples of I/O-bound applications include
        file utilities that do very little except issue system calls asking
        the kernel to perform I/O, such as <emphasis>cp</emphasis> or
        <emphasis>mv</emphasis>, and many GUI applications, which spend a
        great deal of time waiting for user input.</p>
<p>Processor- and I/O-bound applications differ in the type of
        scheduler behavior that benefits them most. Processor-bound
        applications crave the largest timeslices possible, allowing them to
        maximize cache hit rates (via temporal locality), and get their jobs
        done as quickly as possible. In contrast, I/O-bound processes do not
        necessarily need large timeslices, because they typically run for only
        very short periods before issuing I/O requests and blocking on some
        kernel resource. I/O-bound processes, however, do benefit from
        constant attention from the scheduler. The quicker such an application
        can restart after blocking and dispatch more I/O requests, the better
        it can utilize the system's hardware. Further, if the application was
        waiting for user input, the faster it is scheduled, the greater the
        user's perception of seamless execution will be.</p>
<p>Juggling the needs of processor- and I/O-bound processes is not
        easy. The Linux scheduler attempts to identify and provide
        preferential treatment to I/O-bound applications: heavily I/O-bound
        applications are given a priority boost, while heavily processor-bound
        applications are served a priority penalty.</p>
<p>In reality, most applications are some mix of I/O- and
        processor-bound. Audio/video encoding/decoding is a good example of a
        type of application that defies categorization. Many games are also
        quite mixed. It is not always possible to identify the proclivity of a
        given application, and, at any point in time, a given process may
        behave in one way or the other.</p>
<empty-line/>
<p><strong>Preemptive Scheduling</strong></p>
<p>When a process exhausts its timeslice, the kernel suspends it,
        and begins running a new process. If there are no runnable processes
        on the system, the kernel takes the set of processes with exhausted
        timeslices, replenishes their timeslices, and begins running them
        again. In this fashion, all processes eventually get to run, even if
        there are higher-priority processes on the system—the lower-priority
        processes just have to wait for the higher-priority processes to
        exhaust their timeslices or block. This behavior formulates an
        important but tacit rule of Unix scheduling: all processes must
        progress.</p>
<p>If there are no runnable processes left on the system, the
        kernel "runs" the <emphasis>idle process</emphasis>. The idle process
        is actually not a process at all; nor does it actually run (to the
        relief of batteries everywhere). Instead, the idle process is a
        special routine that the kernel executes to simplify the scheduler
        algorithm, and to make accounting easy. Idle time is simply the time
        spent running the idle process.</p>
<p>If a process is running, and a process with a higher priority
        becomes runnable (perhaps because it was blocked waiting for keyboard
        input, and the user just typed a word), the currently running process
        is immediately suspended, and the kernel switches to the
        higher-priority process. Thus, there are never
        runnable-but-not-running processes with a higher priority than the
        currently running process. The running process is always the
        highest-priority runnable process on the system.</p>
<empty-line/>
<p><strong>Threading</strong></p>
<p>Threads are units of execution within a single process. All
        processes have at least one thread. Each thread has its own
        virtualization of the processor: its own set of registers, instruction
        pointer, and processor state. While most processes have but one
        thread, processes can have large numbers of threads, all performing
        different tasks, but sharing the same address space (and thus the same
        dynamic memory, mapped files, object code, and so on), list of open
        files, and other kernel resources.</p>
<p>The Linux kernel has an interesting and unique view of threads.
        Essentially, the kernel has no such concept. To the Linux kernel, all
        threads are unique processes. At a broad level, there is no difference
        between two unrelated processes and two threads inside of a single
        process. The kernel simply views threads as processes that share
        resources. That is, the kernel considers a process consisting of two
        threads as two distinct processes that share a set of kernel resources
        (address space, list of open files, and so on).</p>
<p><emphasis>Multithreaded programming</emphasis> is the art of
        programming with threads. The most common API on Linux for programming
        with threads is the API standardized by IEEE Std 1003.1c-1995 (POSIX
        1995 or POSIX.1c). Developers often call the library that implements
        this API <emphasis>pthreads</emphasis>. Programming with threads is a
        complicated subject, and the pthreads API is large and complex.
        Consequently, pthreads are outside the scope of this book. Instead,
        this book focuses on the interfaces on which the pthreads library is
        built.</p>
<empty-line/>
<p><strong>Yielding the Processor</strong></p>
<p>Although Linux is a preemptively multitasked operating system, it
      also provides a system call that allows processes to explicitly yield
      execution and instruct the scheduler to select a new process for
      execution:<strong>#include &lt;sched.h&gt;

int sched_yield (void);</strong></p>
<p>A call to sched_yield( )
      results in suspension of the currently running process, after which the
      process scheduler selects a new process to run, in the same manner as if
      the kernel had itself preempted the currently running process in favor
      of executing a new process. Note that if no other runnable process
      exists, which is often the case, the yielding process will immediately
      resume execution. Because of this uncertainty, coupled with the general
      belief that there are generally better choices, use of this system call
      is not common.</p>
<p>On success, the call returns 0;
      on failure, it returns −1, and sets
      errno to the appropriate error code.
      On Linux—and, more than likely, most other Unix systems—sched_yield( ) cannot fail, and thus always
      returns 0. A thorough programmer may
      still check the return value, however:if (sched_yield (  ))
        perror ("sched_yield");</p>
<empty-line/>
<p><strong>Legitimate Uses</strong></p>
<p>In practice, there are few (if any) legitimate uses of sched_yield( ) on a proper preemptive
        multitasking system such as Linux. The kernel is fully capable of
        making the optimal and most efficient scheduling decisions—certainly,
        the kernel is better equipped than an individual application to decide
        what to preempt and when. This is precisely why operating systems
        ditched cooperative multitasking in favor of preemptive
        multitasking.</p>
<p>Why, then, do we have a "reschedule me" system call at all? The
        answer lies in applications having to wait for external events, which
        may be caused by the user, a hardware component, or another process.
        For instance, if one process needs to wait for another, "just yield
        the processor until the other process is done" is a first-pass
        solution. As an example, the implementation of a naïve consumer in a
        consumer/producer pair might be similar to the following:/* the consumer... */
do {
        while (producer_not_ready (  ))
                sched_yield (  );
        process_data (  );
} while (!time_to_quit (  ));</p>
<p>Thankfully, Unix programmers do not tend to write code such as
        this. Unix programs are normally event-driven and tend to utilize some
        sort of blockable mechanism (such as a pipe) between the consumer and
        the producer, in lieu of sched_yield(
        ). In this case, the consumer reads from the pipe, blocking
        as necessary until data is available. The producer, in turn, writes to
        the pipe as fresh data becomes available. This removes the
        responsibility for coordination from the user-space process, which
        just busy-loops, to the kernel, which can optimally manage the
        situation by putting the processes to sleep, and waking them up only
        as needed. In general, Unix programs should aim toward event-driven
        solutions that rely on blockable file descriptors.</p>
<p>Until recently, one situation vexingly required sched_yield( ): user-space thread locking.
        When a thread attempted to acquire a lock that another thread already
        held, the new thread would yield the processor until the lock became
        available. Without kernel support for user-space locks, this approach
        was the simplest, and most efficient. Thankfully, the modern Linux
        thread implementation (the New POSIX Threading Library, or NPTL)
        ushered in an optimal solution using <emphasis>futexes</emphasis>,
        which provide kernel support for user-space locks.</p>
<p>One other use for sched_yield(
        ) is "playing nicely": a processor-intensive program can
        call sched_yield( ) periodically,
        attempting to minimize its impact on the system. While noble in
        pursuit, this strategy has two flaws. First, the kernel is able to
        make global scheduling decisions much better than an individual
        process, and, consequently, the responsibility for ensuring smooth
        system operation should lie on the process scheduler, not the
        processes. Toward this end, the scheduler's interactivity bonus aims
        to reward I/O-intensive applications, and punish processor-intensive
        ones. Second, mitigating the overhead of a processor-intensive
        application with respect to other applications is the responsibility
        of the user, not of individual applications. The user can convey her
        relative preferences for application performance via the
        <emphasis>nice</emphasis> shell command, which we will discuss later
        in this chapter.</p>
<empty-line/>
<p><strong>Yielding, Past and Present</strong></p>
<p>Before the introduction of the 2.6 Linux kernel, a call to
        sched_yield( ) had only a minor
        effect. If another runnable process was available, the kernel would
        switch to it and place the invoking process at the tail of the list of
        runnable processes. In short order, the kernel would reschedule the
        invoking process. In the likely case of no other runnable process
        being available, the invoking process would simply continue
        executing.</p>
<p>The 2.6 kernel changed this behavior. The current algorithm is
        as follows:</p>
<p>Is this process a real-time process? If so, stick it at the
            tail of the runnable process list, and return (this is the old
            behavior). If not, continue to the next step. (For more on
            real-time processes, see "Real-Time Systems"
            later in this chapter.)</p>
<p>Remove this process from the list of runnable processes
            altogether, and place it on the list of expired processes. This
            implies that all runnable processes must execute and exhaust their
            timeslices before the invoking process, along with the other
            expired processes, is able to resume execution.</p>
<p>Schedule the next runnable process in the list for
            execution.</p>
<p>The net effect of a call to sched_yield( ), therefore, is the same as if
        the process had exhausted its timeslice. This behavior differs from
        earlier kernels, where the effect of sched_yield( ) was milder (tantamount to "if
        another process is ready and waiting, run it for a bit, but come right
        back to me").</p>
<p>One reason for this change was to prevent the so-called
        "ping-pong" pathological case. Imagine two processes, A and B, both
        calling sched_yield( ). Presume
        these are the only runnable processes (there might be other processes
        able to run, but none with nonzero timeslices). With the old sched_yield( ) behavior, the result of this
        situation is that the kernel schedules both processes in rotation,
        with each saying in turn, "No, schedule someone else!" This persists
        until both processes exhaust their timeslices. If we were to draw a
        diagram of the process selections made by the process scheduler, it
        would resemble "A, B, A, B, A, B" and so on—hence the "ping pong"
        moniker.</p>
<p>The new behavior prevents this case. As soon as process A asks
        to yield the processor, the scheduler removes it from the list of
        runnable processes. Likewise, as soon as process B makes the same
        request, the scheduler removes it from the list of runnable processes.
        The scheduler will not consider running process A or process B until
        there are no other runnable processes left, preventing the ping-pong
        effect, and allowing other processes to receive their fair share of
        the processor time.</p>
<p>Consequently, when asking to yield the processor, a process
        should truly intend to yield it!</p>
<empty-line/>
<p><strong>Process Priorities</strong></p>
<p><strong>Tip</strong></p>
<p>The discussion in this section pertains to normal, nonreal-time
        processes. Real-time processes require different scheduling criteria,
        and a separate priority system. We will discuss real-time computing
        later in this chapter.</p>
<p>Linux does not schedule processes willy-nilly. Instead,
      applications are assigned <emphasis>priorities</emphasis> that affect
      when their processes run, and for how long. Unix has historically called
      these priorities <emphasis>nice values</emphasis>, because the idea
      behind them was to "be nice" to other processes on the system by
      lowering a process' priority, allowing other processes to consume more
      of the system's processor time.</p>
<p>The nice value dictates when a process runs. Linux schedules
      runnable processes in order of highest to lowest priority: a process
      with a higher priority runs before a process with a lower priority. The
      nice value also dictates the size of a process' timeslice.</p>
<p>Legal nice values range from −20 to 19 inclusive, with a default
      value of 0. Somewhat confusingly, the lower a process' nice value, the
      higher its priority, and the larger its timeslice; conversely, the
      higher the value, the lower the process' priority, and the smaller its
      timeslice. Increasing a process' nice value is therefore "nice" to the
      rest of the system. The numerical inversion is rather confusing. When we
      say a process has a "high priority" we mean that it is chosen more
      quickly to run, and can run for longer than lower-priority processes,
      but such a process will have a lower nice value.</p>
<empty-line/>
<p><strong>nice( )</strong></p>
<p>Linux provides several system calls for retrieving and setting a
        process' nice value. The simplest is nice(
        ):<strong>#include &lt;unistd.h&gt;

int nice (int inc);</strong></p>
<p>A successful call to nice( )
        increments a process' nice value by inc, and returns the newly updated value.
        Only a process with the CAP_SYS_NICE capability (effectively,
        processes owned by root) may provide a negative value for inc, decreasing its nice value, and thereby
        increasing its priority. Consequently, nonroot processes may only
        lower their priorities (by increasing their nice values).</p>
<p>On error, nice( ) returns
        −1. However, because nice( ) returns the new nice value, −1 is also a successful return value. To
        differentiate between success and failure, you can zero out errno before invocation, and subsequently
        check its value. For example:int ret;

errno = 0;
ret = nice (10);    /* increase our nice by 10 */
if (ret == −1 &amp;&amp; errno != 0)
        perror ("nice");
else
        printf ("nice value is now %d\n", ret);</p>
<p>Linux returns only a single error code: EPERM, signifying that the invoking process
        attempted to increase its priority (via a negative inc value), but it does not possess the
        CAP_SYS_NICE capability. Other
        systems also return EINVAL when
        inc would place the nice value out
        of the range of valid values, but Linux does not. Instead, Linux
        silently rounds invalid inc values
        up or down to the value at the limit of the allowable range, as
        needed.</p>
<p>Passing 0 for inc is an easy way to obtain the current
        nice value:printf ("nice value is currently %d\n", nice (0));</p>
<p>Often, a process wants to set an absolute nice value rather than
        a relative increment. This can be done with code like the
        following:int ret, val;

/* get current nice value */
val = nice (0);

/* we want a nice value of 10 */
val = 10 - val;
errno = 0;
ret = nice (val);
if (ret == −1 &amp;&amp; errno != 0)
        perror ("nice");
else
        printf ("nice value is now %d\n", ret);</p>
<empty-line/>
<p><strong>getpriority( ) and setpriority( )</strong></p>
<p>A preferable solution is to use the getpriority( ) and setpriority( ) system calls, which allow
        more control, but are more complex in operation:<strong>#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;

int getpriority (int which, int who);
int setpriority (int which, int who, int prio);</strong></p>
<p>These calls operate on the process, process group, or user, as
        specified by which and who. The value of which must be one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER, in which case who specifies a process ID, process group
        ID, or user ID, respectively. If who is 0,
        the call operates on the current process ID, process group ID, or user
        ID, respectively.</p>
<p>A call to getpriority( )
        returns the highest priority (lowest numerical nice value) of any of
        the specified processes. A call to setpriority( ) sets the priority of all
        specified processes to prio. As
        with nice( ), only a process
        possessing CAP_SYS_NICE may raise a
        process' priority (lower the numerical nice value). Further, only a
        process with this capability can raise or lower the priority of a
        process not owned by the invoking user.</p>
<p>Like nice( ), getpriority( ) returns −1 on error. As this is also a successful
        return value, programmers should clear errno before invocation if they want to
        handle error conditions. Calls to setpriority( ) have no such problem;
        setpriority( ) always returns
        0 on success, and −1 on error.</p>
<p>The following code returns the current process' priority:int ret;

ret = getpriority (PRIO_PROCESS, 0);
printf ("nice value is %d\n", ret);</p>
<p>The following code sets the priority of all processes in the
        current process group to 10:int ret;

ret = setpriority (PRIO_PGRP, 0, 10);
if (ret == −1)
        perror ("setpriority");</p>
<p>On error, both functions set errno to one of the following values:</p>
<p>EACCESS</p>
<p>The process attempted to raise the specified process'
              priority, but does not possess CAP_SYS_NICE (setpriority( ) only).EINVAL</p>
<p>The value specified by which was not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.EPERM</p>
<p>The effective user ID of the matched process does not
              match the effective user ID of the running process, and the
              running process does not possess CAP_SYS_NICE (setpriority( ) only).ESRCH</p>
<p>No process was found matching the criteria provided by
              which and who.</p>
<empty-line/>
<p><strong>I/O Priorities</strong></p>
<p>In addition to a scheduling priority, Linux allows processes to
        specify an <emphasis>I/O priority</emphasis>. This value affects the
        relative priority of the processes' I/O requests. The kernel's I/O
        scheduler (discussed in Chapter 4)
        services requests originating from processes with higher I/O
        priorities before requests from processes with lower I/O
        priorities.</p>
<p>By default, I/O schedulers use a process' nice value to
        determine the I/O priority. Ergo, setting the nice value automatically
        changes the I/O priority. However, the Linux kernel additionally
        provides two system calls for explicitly setting and retrieving the
        I/O priority independently of the nice value:<strong>int ioprio_get (int which, int who)
int ioprio_set (int which, int who, int ioprio)</strong></p>
<p>Unfortunately, the kernel does not yet export these system
        calls, and <emphasis>glibc</emphasis> does not provide any user-space
        access. Without <emphasis>glibc</emphasis> support, usage is
        cumbersome at best. Further, when and if <emphasis>glibc</emphasis>
        support arrives, the interfaces may differ from the system calls.
        Until such support is available, there are two portable ways to
        manipulate a process' I/O priority: via the nice value, or a utility
        such as <emphasis>ionice</emphasis>, part of the
        <emphasis>util-linux</emphasis> package.<sup>[26]</sup></p>
<p>Not all I/O schedulers support I/O priorities. Specifically, the
        Complete Fair Queuing (CFQ) I/O Scheduler supports them; currently,
        the other standard schedulers do not. If the current I/O scheduler
        does not support I/O priorities, they are silently ignored.</p>
<empty-line/>
<p><strong>Processor Affinity</strong></p>
<p>Linux supports multiple processors in a single system. Aside from
      the boot process, the bulk of the work of supporting multiple processors
      rests on the process scheduler. On a symmetric multiprocessing (SMP)
      machine, the process scheduler must decide which processes run on each
      CPU. Two challenges derive from this responsibility: the scheduler must
      work toward fully utilizing all of the system's processors, because it
      is inefficient for one CPU to sit idle while a process is waiting to
      run.</p>
<p>However, once a process has been scheduled on one CPU, the process
      scheduler should aim to schedule it on the same CPU in the future. This
      is beneficial because <emphasis>migrating</emphasis> a process from one
      processor to another has costs.</p>
<p>The largest of these costs are related to the <emphasis>cache
      effects</emphasis> of migration. Due to the design of modern SMP
      systems, the caches associated with each processor are separate and
      distinct. That is, the data in one processor's cache is not in
      another's. Therefore, if a process moves to a new CPU, and writes new
      data into memory, the data in the old CPU's cache can become stale.
      Relying on that cache would now cause corruption. To prevent this,
      caches <emphasis>invalidate</emphasis> each other's data whenever they
      cache a new chunk of memory. Consequently, a given piece of data is
      strictly in only one processor's cache at any given moment (assuming the
      data is cached at all). When a process moves from one processor to
      another, there are thus two associated costs: cached data is no longer
      accessible to the process that moved, and data in the original
      processor's cache must be invalidated. Because of these costs, process
      schedulers attempt to keep a process on a specific CPU for as long as
      possible.</p>
<p>The process scheduler's two goals, of course, are potentially
      conflicting. If one processor has a significantly larger process load
      than another—or, worse, if one processor is busy while another is
      idle—it makes sense to reschedule some processes on the less-busy CPU.
      Deciding when to move processes in response to such imbalances, called
      <emphasis>load balancing</emphasis>, is of great importance to the
      performance of SMP machines.</p>
<p><emphasis>Processor affinity</emphasis> refers to the likelihood
      of a process to be scheduled consistently on the same processor. The
      term <emphasis>soft affinity</emphasis> refers to the scheduler's
      natural propensity to continue scheduling a process on the same
      processor. As we've discussed, this is a worthwhile trait. The Linux
      scheduler attempts to schedule the same processes on the same processors
      for as long as possible, migrating a process from one CPU to another
      only in situations of extreme load imbalance. This allows the scheduler
      to minimize the cache effects of migration, but still ensure that all
      processors in a system are evenly loaded.</p>
<p>Sometimes, however, the user or an application wants to enforce a
      process-to-processor bond. This is often because the process is strongly
      cache-sensitive, and desires to remain on the same processor. Bonding a
      process to a particular processor and having the kernel enforce the
      relationship is called setting a <emphasis>hard
      affinity</emphasis>.</p>
<empty-line/>
<p><strong>sched_getaffinity() and sched_setaffinity( )</strong></p>
<p>Processes inherit the CPU affinities of their parents and, by
        default, processes may run on any CPU. Linux provides two system calls
        for retrieving and setting a process' hard affinity:<strong>#define _GNU_SOURCE

#include &lt;sched.h&gt;

typedef struct cpu_set_t;

size_t CPU_SETSIZE;

void CPU_SET (unsigned long cpu, cpu_set_t *set);
void CPU_CLR (unsigned long cpu, cpu_set_t *set);
int CPU_ISSET (unsigned long cpu, cpu_set_t *set);
void CPU_ZERO (cpu_set_t *set);

int sched_setaffinity (pid_t pid, size_t setsize,
                       const cpu_set_t *set);

int sched_getaffinity (pid_t pid, size_t setsize,
                       cpu_set_t *set);</strong></p>
<p>A call to sched_getaffinity(
        ) retrieves the CPU affinity of the process pid, and stores it in the special cpu_set_t type, which is accessed via
        special macros. If pid is 0, the call retrieves the current process'
        affinity. The setsize parameter is
        the size of the cpu_set_t type,
        which may be used by <emphasis>glibc</emphasis> for compatibility with
        future changes in the size of this type. On success, sched_getaffinity( ) returns 0; on failure, it returns −1, and errno is set. Here's an example:cpu_set_t set;
int ret, i;

CPU_ZERO (&amp;set);
ret = sched_getaffinity (0, sizeof (cpu_set_t), &amp;set);
if (ret == −1)
        perror ("sched_getaffinity");

for (i = 0; i &lt; CPU_SETSIZE; i++) {
        int cpu;

        cpu = CPU_ISSET (i, &amp;set);
        printf ("cpu=%i is %s\n", i,
                cpu ? "set" : "unset");
}</p>
<p>Before invocation, we use CPU_ZERO to "zero out" all of the bits in
        the set. We then iterate from 0 to
        CPU_SETSIZE over the set. Note that
        CPU_SETSIZE is, confusingly, not
        the size of the set—you should <emphasis>never</emphasis> pass it for
        setsize—but rather the number of
        processors that could potentially be represented by a set. Because the
        current implementation represents each processor with a single bit,
        CPU_SETSIZE is much larger than
        sizeof(cpu_set_t). We use CPU_ISSET to check whether a given processor
        in the system, i, is bound or
        unbound to this process. It returns 0 if unbound, and a nonzero value if
        bound.</p>
<p>Only processors physically on the system are set. Thus, running
        this snippet on a system with two processors will yield:cpu=0 is set
cpu=1 is set
cpu=2 is unset
cpu=3 is unset
...
cpu=1023 is unset</p>
<p>As the output shows, CPU_SETSIZE (which is zero-based) is
        currently 1,024.</p>
<p>We are concerned only with CPUs #0 and #1 because they are the
        only physical processors on this system. Perhaps we want to ensure
        that our process runs only on CPU #0, and never on #1. This code does
        just that:cpu_set_t set;
int ret, i;

CPU_ZERO (&amp;set);        /* clear all CPUs */
CPU_SET (0, &amp;set);      /* allow CPU #0 */
CPU_SET (1, &amp;set);      /* allow CPU #1 */
ret = sched_setaffinity (0, sizeof (cpu_set_t), &amp;set);
if (ret == −1)
        perror ("sched_setaffinity");

for (i = 0; i &lt; CPU_SETSIZE; i++) {
        int cpu;

        cpu = CPU_ISSET (i, &amp;set);
        printf ("cpu=%i is %s\n", i,
                cpu ? "set" : "unset");
}</p>
<p>We start, as always, by zeroing out the set with CPU_ZERO. We then set CPU #0 with CPU_SET and unset (clear) CPU #1 with
        CPU_CLR. The CPU_CLR operation is redundant as we just
        zeroed out the whole set, but it is provided for completeness.</p>
<p>Running this on the same two-processor system will result in
        slightly different output than before:cpu=0 is set
cpu=1 is unset
cpu=2 is unset
...
cpu=1023 is unset</p>
<p>Now, CPU #1 is unset. This process will run only on CPU #0, no
        matter what!</p>
<p>Four errno values are
        possible:</p>
<p>EFAULT</p>
<p>The provided pointer was outside of the process' address
              space or otherwise invalid.EINVAL</p>
<p>In this case, there were no processors physically on the
              system enabled in set
              (sched_setaffinity( ) only),
              or setsize is smaller than
              the size of the kernel's internal data structure that represents
              sets of processors.EPERM</p>
<p>The process associated with pid is not owned by the current
              effective user ID of the calling process, and the process does
              not possess CAP_SYS_NICE.ESRCH</p>
<p>No process associated with pid was found.</p>
<empty-line/>
<p><strong>Real-Time Systems</strong></p>
<p>In computing, the term <emphasis>real-time</emphasis> is often the
      source of some confusion and misunderstanding. A system is "real-time"
      if it is subject to <emphasis>operational deadlines</emphasis>: minimum
      and mandatory times between stimuli and responses. A familiar real-time
      system is the <emphasis>anti-lock braking system</emphasis>(ABS) found
      on nearly all modern automobiles. In this system, when the brake is
      pressed, a computer regulates the brake pressure, often applying and
      releasing maximum brake pressure many times a second. This prevents the
      wheels from "locking up," which can reduce stopping performance, or even
      send the car into an uncontrolled skid. In such a system, the
      operational deadlines are how fast the system must respond to a "locked"
      wheel condition and how quickly the system can apply brake
      pressure.</p>
<p>Most modern operating systems, Linux included, provide some level
      of real-time support.</p>
<empty-line/>
<p><strong>Hard Versus Soft Real-Time Systems</strong></p>
<p>Real-time systems come in two varieties: hard and soft. A
        <emphasis>hard real-time system</emphasis> requires absolute adherence
        to operational deadlines. Exceeding the deadlines constitutes failure,
        and is a major bug. A <emphasis>soft real-time system</emphasis>, on
        the other hand, does not consider overrunning a deadline to be a
        critical failure.</p>
<p>Hard real-time applications are easy to identify: some examples
        are anti-lock braking systems, military weapons systems, medical
        devices, and signal processing. Soft real-time applications are not
        always so easy to identify. One obvious member of that group is
        video-processing applications: users notice a drop in quality if their
        deadlines are missed, but a few lost frames can be tolerated.</p>
<p>Many other applications have timing constraints that, if not
        met, result in a detriment to the user experience. Multimedia
        applications, games, and networking programs come to mind. What about
        a text editor, however? If the program cannot respond quickly enough
        to keypresses, the experience is poor, and the user may grow angry or
        frustrated. Is this a soft real-time application? Certainly, when the
        developers were writing the application, they realized that they
        needed to respond to keypresses in a timely manner. But does this
        count as an operational deadline? The line defining soft real-time
        applications is anything but clear.</p>
<p>Contrary to common belief, a real-time system is not necessarily
        fast. Indeed, given comparable hardware, a real-time system is
        probably slower than a nonreal-time system—due to, if nothing else,
        the increase in overhead required to support real-time processes.
        Likewise, the division between hard and soft real-time systems is
        independent of the size of the operational deadlines. A nuclear
        reactor will overheat if the SCRAM system does not lower the control
        rods within several seconds of detecting excessive neutron flux. This
        is a hard real-time system with a lengthy (as far as computers are
        concerned) operational deadline. Conversely, a video player might skip
        a frame or stutter the sound if the application cannot refill the
        playback buffer within 100 ms. This is a soft real-time system with a
        demanding operational deadline.</p>
<empty-line/>
<p><strong>Latency, Jitter, and Deadlines</strong></p>
<p><emphasis>Latency</emphasis> refers to the period from the
        occurrence of the stimulus until the execution of the response. If
        latency is less than or equal to the operational deadline, the system
        is operating correctly. In many hard real-time systems, the
        operational deadline and the latency are equal—the system handles
        stimuli in fixed intervals, at exact times. In soft real-time systems,
        the required response is less exact, and latency exhibits some amount
        of variance—the aim is simply for the response to occur within the
        deadline.</p>
<p>It is often hard to measure latency, because its calculation
        requires knowing the time when the stimulus occurred. The ability to
        timestamp the stimulus, however, often begs the ability to respond to
        it. Therefore, many attempts at instrumenting latency do no such
        thing; instead, they measure the variation in timing between
        responses. The variation in timing between successive events is
        <emphasis>jitter</emphasis>, not latency.</p>
<p>For example, consider a stimulus that occurs every 10
        milliseconds. To measure the performance of our system, we might
        timestamp our responses to ensure that they occur every 10
        milliseconds. The deviation from this target is not latency,
        however—it is jitter. What we are measuring is the variance in
        successive responses. Without knowing when the stimulus occurred, we
        do not know the actual difference in time between stimulus and
        response. Even knowing that the stimulus occurs every 10 ms, we do not
        know when the <emphasis>first</emphasis> occurrence was. Perhaps
        surprisingly, many attempts at measuring latency make this mistake and
        report jitter, not latency. To be sure, jitter is a useful metric, and
        such instrumentation is probably quite useful. Nevertheless, we must
        call a duck a duck!</p>
<p>Hard real-time systems often exhibit very low jitter because
        they respond to stimuli after—not <emphasis>within</emphasis>—an exact
        amount of time. Such systems aim for a jitter of zero, and a latency
        equal to the operational delay. If the latency exceeds the delay, the
        system fails.</p>
<p>Soft real-time systems are more susceptible to jitter. In these
        systems, the response time is ideally within the operational
        delay—often much sooner, sometimes not. Jitter, therefore, is often an
        excellent surrogate for latency as a performance metric.</p>
<empty-line/>
<p><strong>Linux's Real-Time Support</strong></p>
<p>Linux provides applications with soft real-time support via a
        family of system calls defined by IEEE Std 1003.1b-1993 (often
        shortened to POSIX 1993 or POSIX.1b).</p>
<p>Technically speaking, the POSIX standard does not dictate
        whether the provided real-time support is soft or hard. In fact, all
        the POSIX standard really does is describe several scheduling policies
        that respect priorities. What sorts of timing constraints the
        operating system enforces on these policies is up to the OS
        designers.</p>
<p>Over the years, the Linux kernel has gained better and better
        real-time support, providing lower and lower latency, and more
        consistent jitter, without compromising system performance. Much of
        this is because improving latency helps many classes of application,
        such as desktop and I/O-bound processes, and not just real-time
        applications. The improvements are also attributable to the success of
        Linux in embedded and real-time systems.</p>
<p>Unfortunately, many of the embedded and real-time modifications
        that have been made to the Linux kernel exist only in custom Linux
        solutions, outside of the mainstream official kernel. Some of these
        modifications provide further reductions in latency, and even hard
        real-time behavior. The following sections discuss only the official
        kernel interfaces and the behavior of the mainstream kernel. Luckily,
        most real-time modifications continue to utilize the POSIX interfaces.
        Ergo, the subsequent discussion is also relevant on modified
        systems.</p>
<empty-line/>
<p><strong>Linux Scheduling Policies and Priorities</strong></p>
<p>The behavior of the Linux scheduler with respect to a process
        depends on the process' <emphasis>scheduling policy</emphasis>, also
        called the <emphasis>scheduling class</emphasis>. In addition to the
        normal default policy, Linux provides two real-time scheduling
        policies. A preprocessor macro from the header &lt;sched.h&gt; represents each policy: the
        macros are SCHED_FIFO, SCHED_RR, and SCHED_OTHER.</p>
<p>Every process possesses a <emphasis>static priority</emphasis>,
        unrelated to the nice value. For normal applications, this priority is
        always 0. For the real-time processes, it ranges from 1 to 99,
        inclusive. The Linux scheduler always selects the highest-priority
        process to run (i.e., the one with the largest numerical static
        priority value). If a process is running with a static priority of 50,
        and a process with a priority of 51 becomes runnable, the scheduler
        will immediately preempt the running process, and switch to the newly
        runnable process. Conversely, if a process is running with a priority
        of 50, and a process with a priority of 49 becomes runnable, the
        scheduler will not run it until the priority-50 process blocks,
        becoming unrunnable. Because normal processes have a priority of 0,
        any real-time process that is runnable will always preempt a normal
        process and run.</p>
<empty-line/>
<p><strong>The first in, first out policy</strong></p>
<p>The <emphasis>first in, first out (FIFO) class</emphasis> is a
          very simple real-time policy without timeslices. A FIFO-classed
          process will continue running so long as no higher-priority process
          becomes runnable. The FIFO class is represented by the macro
          SCHED_FIFO.</p>
<p>As the policy lacks timeslices, its rules of operation are
          rather simple:</p>
<p>A runnable FIFO-classed process will always run if it is
              the highest-priority process on the system. Particularly, once a
              FIFO-classed process becomes runnable, it will immediately
              preempt a normal process.</p>
<p>A FIFO-classed process will continue running until it
              blocks or calls sched_yield(
              ), or until a higher-priority process becomes
              runnable.</p>
<p>When a FIFO-classed process blocks, the scheduler removes
              it from the list of runnable processes. When it again becomes
              runnable, it is inserted at the end of the list of processes at
              its priority. Thus, it will not run until any other processes of
              higher <emphasis>or equal</emphasis> priority cease
              execution.</p>
<p>When a FIFO-classed process calls sched_yield( ), the scheduler moves it
              to the end of the list of processes at its priority. Thus, it
              will not run until any other equal-priority processes cease
              execution. If the invoking process is the only process at its
              priority, sched_yield( ) will
              have no effect.</p>
<p>When a higher-priority process preempts a FIFO-classed
              process, the FIFO-classed process remains at the same location
              in the list of processes for its given priority. Thus, once the
              higher-priority process ceases execution, the preempted
              FIFO-classed process will continue executing.</p>
<p>When a process joins the FIFO class, or when a process'
              static priority changes, it is put at the head of the list of
              processes for its given priority. Consequently, a newly
              prioritized FIFO-classed process can preempt an executing
              process of the same priority.</p>
<p>Essentially, we can say that FIFO-classed processes always run
          for as long as they want, so long as they are the highest-priority
          processes on the system. The interesting rules pertain to what
          happens among FIFO-classed processes with the same priority.</p>
<empty-line/>
<p><strong>The round-robin policy</strong></p>
<p>The <emphasis>round-robin (RR) class</emphasis> is identical
          to the FIFO class, except that it imposes additional rules in the
          case of processes with the same priority. The macro SCHED_RR represents this class.</p>
<p>The scheduler assigns each RR-classed process a timeslice.
          When an RR-classed process exhausts its timeslice, the scheduler
          moves it to the end of the list of processes at its priority. In
          this manner, RR-classed processes of a given priority are scheduled
          round-robin amongst themselves. If there is only one process at a
          given priority, the RR class is identical to the FIFO class. In such
          a case, when its timeslice expires, the process simply resumes
          execution.</p>
<p>We can think of an RR-classed process as identical to a
          FIFO-classed process, except that it additionally ceases execution
          when it exhausts its timeslice, at which time it moves to the end of
          the list of runnable processes at its priority.</p>
<p>Deciding whether to use SCHED_FIFO or SCHED_RR is entirely a question of
          intra-priority behavior. The RR class' timeslices are relevant only
          among processes of the same priority. FIFO-classed processes will
          continue running unabated; RR-classed processes will schedule
          amongst themselves at a given priority. In neither case will a
          lower-priority process ever run if a higher-priority process
          exists.</p>
<empty-line/>
<p><strong>The normal policy</strong></p>
<p>SCHED_OTHER represents the
          standard scheduling policy, the default nonreal-time class. All
          normal-classed processes have a static priority of 0. Consequently,
          any runnable FIFO- or RR-classed process will preempt a running
          normal-classed process.</p>
<p>The scheduler uses the nice value, discussed earlier, to
          prioritize processes within the normal class. The nice value has no
          bearing on the static priority, which remains 0.</p>
<empty-line/>
<p><strong>The batch scheduling policy</strong></p>
<p>SCHED_BATCH is the
          <emphasis>batch</emphasis> or <emphasis>idle scheduling
          policy</emphasis>. Its behavior is somewhat the antithesis of the
          real-time policies: processes in this class run only when there are
          no other runnable processes on the system, even if the other
          processes have exhausted their timeslices. This is different from
          the behavior of processes with the largest nice values (i.e., the
          lowest-priority processes) in that eventually such processes will
          run, as the higher-priority processes exhaust their
          timeslices.</p>
<empty-line/>
<p><strong>Setting the Linux scheduling policy</strong></p>
<p>Processes can manipulate the Linux scheduling policy via
          sched_getscheduler( ) and
          sched_setscheduler( ):<strong>#include &lt;sched.h&gt;

struct sched_param {
        /* ... */
        int sched_priority;
        /* ... */
};

int sched_getscheduler (pid_t pid);

int sched_setscheduler (pid_t pid,
                        int policy,
                        const struct sched_param *sp);</strong></p>
<p>A successful call to sched_getscheduler( ) returns the
          scheduling policy of the process represented by pid. If pid is 0, the call returns the invoking process'
          scheduling policy. An integer defined in &lt;sched.h&gt; represents the scheduling
          policy: the first in, first out policy is SCHED_FIFO; the round-robin policy is
          SCHED_RR; and the normal policy
          is SCHED_OTHER. On error, the
          call returns −1 (which is never a
          valid scheduling policy), and errno is set as appropriate.</p>
<p>Usage is simple:int policy;

/* get our scheduling policy */
policy = sched_getscheduler (0);

switch (policy) {
case SCHED_OTHER:
        printf ("Policy is normal\n");
        break;
case SCHED_RR:
        printf ("Policy is round-robin\n");
        break;
case SCHED_FIFO:
        printf ("Policy is first-in, first-out\n");
        break;
case -1:
        perror ("sched_getscheduler");
        break;
default:
        fprintf (stderr, "Unknown policy!\n");
}</p>
<p>A call to sched_setscheduler(
          ) sets the scheduling policy of the process represented by
          pid to policy. Any parameters associated with the
          policy are set via sp. If
          pid is 0, the invoking process' policy and
          parameters are set. On success, the call returns 0. On failure, the call returns −1, and errno is set as appropriate.</p>
<p>The valid fields inside the sched_param structure depend on the
          scheduling policies supported by the operating system. The SCHED_RR and SCHED_FIFO policies require one field,
          sched_priority, which represents
          the static priority. SCHED_OTHER
          does not use any field, while scheduling policies supported in the
          future may use new fields. Portable and legal programs must
          therefore not make assumptions about the layout of the
          structure.</p>
<p>Setting a process' scheduling policy and parameters is
          easy:struct sched_param sp = { .sched_priority = 1 };
int ret;

ret = sched_setscheduler (0, SCHED_RR, &amp;sp);
if (ret == −1) {
        perror ("sched_setscheduler");
        return 1;
}</p>
<p>This snippet sets the invoking process' scheduling policy to
          round-robin with a static priority of 1. We presume that 1 is a
          valid priority—technically, it need not be. We will discuss how to
          find the valid priority range for a given policy in an upcoming
          section.</p>
<p>Setting a scheduling policy other than SCHED_OTHER requires the CAP_SYS_NICE capability. Consequently, the
          root user typically runs real-time processes. Since the 2.6.12
          kernel, the RLIMIT_RTPRIO
          resource limit allows nonroot users to set real-time policies up to
          a certain priority ceiling.</p>
<empty-line/>
<p>Error codes</p>
<p>On error, four errno
            values are possible:</p>
<p>EFAULT</p>
<p>The pointer sp
                  points to an invalid or inaccessible region of
                  memory.EINVAL</p>
<p>The scheduling policy denoted by policy is invalid, or a value set
                  in sp does not make sense
                  for the given policy (sched_setscheduler( )
                  only).EPERM</p>
<p>The invoking process does not have the necessary
                  capabilities.ESRCH</p>
<p>The value pid does
                  not denote a running process.</p>
<empty-line/>
<p><strong>Setting Scheduling Parameters</strong></p>
<p>The POSIX-defined sched_getparam(
        ) and sched_setparam( )
        interfaces retrieve and set the parameters associated with a
        scheduling policy that has already been set:<strong>#include &lt;sched.h&gt;

struct sched_param {
        /* ... */
        int sched_priority;
        /* ... */
};

int sched_getparam (pid_t pid, struct sched_param *sp);

int sched_setparam (pid_t pid, const struct sched_param *sp);</strong></p>
<p>The sched_getscheduler( )
        interface returns only the scheduling policy, not any associated
        parameters. A call to sched_getparam(
        ) returns via sp the
        scheduling parameters associated with pid:struct sched_param sp;
int ret;

ret = sched_getparam (0, &amp;sp);
if (ret == −1) {
        perror ("sched_getparam");
        return 1;
}

printf ("Our priority is %d\n", sp.sched_priority);</p>
<p>If pid is 0, the call returns the parameters of the
        invoking process. On success, the call returns 0. On failure, it returns −1, and sets errno as appropriate.</p>
<p>Because sched_setscheduler( )
        also sets any associated scheduling parameters, sched_setparam( ) is useful only to later
        modify the parameters:struct sched_param sp;
int ret;

sp.sched_priority = 1;
ret = sched_setparam (0, &amp;sp);
if (ret == −1) {
        perror ("sched_setparam");
        return 1;
}</p>
<p>On success, the scheduling parameters of pid are set according to sp, and the call returns 0. On failure, the call returns −1, and errno is set as appropriate.</p>
<p>If we ran the two preceding snippets in order, we would see the
        following output:Our priority is 1</p>
<p>This example again assumes that 1 is a valid priority. It is,
        but portable applications should make sure. We'll look at how to check
        the range of valid priorities momentarily.</p>
<empty-line/>
<p><strong>Error codes</strong></p>
<p>On error, four errno values
          are possible:</p>
<p>EFAULT</p>
<p>The pointer sp points
                to an invalid or inaccessible region of memory.EINVAL</p>
<p>A value set in sp
                does not make sense for the given policy (sched_getparam( ) only).EPERM</p>
<p>The invoking process does not have the necessary
                capabilities.ESRCH</p>
<p>The value pid does
                not denote a running process.</p>
<empty-line/>
<p><strong>Determining the range of valid priorities</strong></p>
<p>Our previous examples have passed hardcoded priority values
          into the scheduling system calls. POSIX makes no guarantees about
          what scheduling priorities exist on a given system, except to say
          that there must be at least 32 priorities between the minimum and
          maximum values. As mentioned earlier in "Linux Scheduling Policies and Priorities," Linux
          implements a range of 1 to 99 inclusive for the two real-time
          scheduling policies. A clean, portable program normally implements
          its own range of priority values, and maps them onto the operating
          system's range. For instance, if you want to run processes at four
          different real-time priority levels, you dynamically determine the
          range of priorities and choose four values.</p>
<p>Linux provides two system calls for retrieving the range of
          valid priority values. One returns the minimum value and the other
          returns the maximum:<strong>#include &lt;sched.h&gt;

int sched_get_priority_min (int policy);

int sched_get_priority_max (int policy);</strong></p>
<p>On success, the call sched_get_priority_min( ) returns the
          minimum, and the call sched_get_priority_max( ) returns the
          maximum valid priority associated with the scheduling policy denoted
          by policy. Both calls then return
          0. Upon failure, the calls both
          return −1. The only possible
          error is if policy is invalid, in
          which case errno is set to
          EINVAL.</p>
<p>Usage is simple:int min, max;

min = sched_get_priority_min (SCHED_RR);
if (min == −1) {
        perror ("sched_get_priority_min");
        return 1;
}

max = sched_get_priority_max (SCHED_RR);
if (max == −1) {
        perror ("sched_get_priority_max");
        return 1;
}

printf ("SCHED_RR priority range is %d - %d\n", min, max);</p>
<p>On a standard Linux system, this snippet yields the
          following:SCHED_RR priority range is 1 - 99</p>
<p>As discussed previously, numerically larger priority values
          denote higher priorities. To set a process to the highest priority
          for its scheduling policy, you can do the following:/*
 * set_highest_priority - set the associated pid's scheduling
 * priority to the highest value allowed by its current
 * scheduling policy. If pid is zero, sets the current
 * process's priority.
 *
 * Returns zero on success.
 */
int set_highest_priority (pid_t pid)
{
        struct sched_param sp;
        int policy, max, ret;

        policy = sched_getscheduler (pid);
        if (policy == −1)
                return −1;

        max = sched_get_priority_max (policy);
        if (max == −1)
                return −1;

        memset (&amp;sp, 0, sizeof (struct sched_param));
        sp.sched_priority = max;
        ret = sched_setparam (pid, &amp;sp);

        return ret;
}</p>
<p>Programs typically retrieve the system's minimum or maximum
          value, and then use increments of 1 (such as max-1, max-2, etc.) to assign priorities as
          desired.</p>
<empty-line/>
<p><strong>sched_rr_get_interval( )</strong></p>
<p>As discussed earlier, SCHED_RR processes behave the same as
        SCHED_FIFO processes, except that
        the scheduler assigns these processes timeslices. When a SCHED_RR process exhausts its timeslice, the
        scheduler moves the process to the end of the run list for its current
        priority. In this manner, all SCHED_RR processes of the same priority are
        executed in a round-robin rotation. Higher-priority processes (and
        SCHED_FIFO processes of the same or
        higher priority) will always preempt a running SCHED_RR process, regardless of whether it
        has any of its timeslice remaining.</p>
<p>POSIX defines an interface for retrieving the length of a given
        process' timeslice:<strong>#include &lt;sched.h&gt;

struct timespec {
        time_t  tv_sec;     /* seconds */
        long    tv_nsec;    /* nanoseconds */
};

int sched_rr_get_interval (pid_t pid, struct timespec *tp);</strong></p>
<p>A successful call to the awfully named sched_rr_get_interval( ) saves in the
        timespec structure pointed at by
        tp the duration of the timeslice
        allotted to pid and returns
        0. On failure, the call returns
        −1, and errno is set as appropriate.</p>
<p>According to POSIX, this function is required to work only with
        SCHED_RR processes. On Linux,
        however, it can retrieve the length of any process' timeslice.
        Portable applications should assume that the function works only with
        round-robin processes; Linux-specific programs may exploit the call as
        needed. Here's an example:struct timespec tp;
int ret;

/* get the current task's timeslice length */
ret = sched_rr_get_interval (0, &amp;tp);
if (ret == −1) {
        perror ("sched_rr_get_interval");
        return 1;
}

/* convert the seconds and nanoseconds to milliseconds */
printf ("Our time quantum is %.2lf milliseconds\n",
        (tp.tv_sec * 1000.0f) + (tp.tv_nsec / 1000000.0f));</p>
<p>If the process is running in the FIFO class, tv_sec and tv_nsec are both 0, denoting infinity.</p>
<empty-line/>
<p><strong>Error codes</strong></p>
<p>On error, three errno
          values are possible:</p>
<p>EFAULT</p>
<p>The memory pointed at by the pointer tp is invalid or
                inaccessible.EINVAL</p>
<p>The value pid is
                invalid (for example, it is negative).ESRCH</p>
<p>The value pid is
                valid, but refers to a nonexistent process.</p>
<empty-line/>
<p><strong>Precautions with Real-Time Processes</strong></p>
<p>Because of the nature of real-time processes, developers should
        exercise caution when developing and debugging such programs. If a
        real-time program goes off the deep end, the system can become
        unresponsive. Any CPU-bound loop in a real-time program—that is, any
        chunk of code that does not block—will continue running ad infinitum,
        so long as no higher-priority real-time processes become
        runnable.</p>
<p>Consequently, designing real-time programs requires care and
        attention. Such programs reign supreme, and can easily bring down the
        entire system. Here are some tips and precautions:</p>
<p>Keep in mind that any CPU-bound loop will run until
            completion, without interruption, if there is no higher-priority
            real-time process on the system. If the loop is infinite, the
            system will become unresponsive.</p>
<p>Because real-time processes run at the expense of everything
            else on the system, special attention must be paid to their
            design. Take care not to starve the rest of the system of
            processor time.</p>
<p>Be very careful with busy waiting. If a real-time process
            busy-waits for a resource held by a lower-priority process, the
            real-time process will busy-wait forever.</p>
<p>While developing a real-time process, keep a terminal open,
            running as a real-time process with a higher priority than the
            process in development. In an emergency, the terminal will remain
            responsive, and allow you to kill the runaway real-time process.
            (As the terminal remains idle, waiting for keyboard input, it will
            not interfere with the other real-time process.)</p>
<p>The <emphasis>chrt</emphasis> utility, part of the
            <emphasis>util-linux</emphasis> package of tools, makes it easy to
            retrieve and set the real-time attributes of other processes. This
            tool makes it easy to launch arbitrary programs in a real-time
            scheduling class, such as the aforementioned terminal, or change
            the real-time priorities of existing applications.</p>
<empty-line/>
<p><strong>Determinism</strong></p>
<p>Real-time processes are big on determinism. In real-time
        computing, an action is <emphasis>deterministic</emphasis> if, given
        the same input, it always produces the same result in the same amount
        of time. Modern computers are the very definition of something that is
        not deterministic: multiple levels of caches (which incur hits or
        misses without predictability), multiple processors, paging, swapping,
        and multitasking wreak havoc on any estimate of how long a given
        action will take. Sure, we have reached a point where just about every
        action (modulo hard drive access) is "incredibly fast," but
        simultaneously, modern systems have also made it hard to pinpoint
        exactly how long a given operation will take.</p>
<p>Real-time applications often try to limit unpredictability in
        general, and worst-case delays specifically. The following sections
        discuss two methods that are used to this end.</p>
<empty-line/>
<p><strong>Prefaulting data and locking memory</strong></p>
<p>Picture this: the hardware interrupt from the custom incoming
          ICBM monitor hits, and the device's driver quickly copies data from
          the hardware into the kernel. The driver notes that a process is
          asleep, blocked on the hardware's device node, waiting for data. The
          driver tells the kernel to wake up the process. The kernel, noting
          that this process is running with a real-time scheduling policy and
          a high priority, immediately preempts the currently running process
          and shifts into overdrive, determined to schedule the real-time
          process immediately. The scheduler switches to running the real-time
          process, and context-switches into its address space. The process is
          now running. The whole ordeal took 0.3 ms, well within the 1 ms
          worst-case acceptable latency period.</p>
<p>Now, in user space, the real-time process notes the incoming
          ICBM, and begins processing its trajectory. With the ballistics
          calculated, the real-time process initiates the deployment of an
          anti-ballistic missile system. Only another 0.1 ms have passed—quick
          enough to deploy the ABM response and save lives. But—oh no!—the ABM
          code has been swapped to disk. A page fault occurs, the processor
          switches back to kernel mode, and the kernel initiates hard disk I/O
          to retrieve the swapped-out data. The scheduler puts the process to
          sleep until the page fault is serviced. Several seconds elapse. It
          is too late.</p>
<p>Clearly, paging and swapping introduce quite undeterministic
          behavior that can wreak havoc on a real-time process. To prevent
          this catastrophe, a real-time application will often "lock" or
          "hardwire" all of the pages in its address space into physical
          memory, prefaulting them into memory, and preventing them from being
          swapped out. Once the pages are locked into memory, the kernel will
          never swap them out to disk. Any accesses of the pages will not
          cause page faults. Most real-time applications lock some or all of
          their pages into physical memory.</p>
<p>Linux provides interfaces for both prefaulting and locking
          data. Chapter 4 discussed
          interfaces for prefaulting data into physical memory. Chapter 8 will discuss interfaces for locking
          data into physical memory.</p>
<empty-line/>
<p><strong>CPU affinity and real-time processes</strong></p>
<p>A second concern of real-time applications is multitasking.
          Although the Linux kernel is preemptive, its scheduler is not always
          able to immediately reschedule one process in favor of another.
          Sometimes, the currently running process is executing inside of a
          critical region in the kernel, and the scheduler cannot preempt it
          until it exits that region. If the process that is waiting to run is
          real-time, this delay may be unacceptable, quickly overrunning the
          operational deadline.</p>
<p>Ergo, multitasking introduces indeterminism similar in nature
          to the unpredictability associated with paging. The solution with
          respect to multitasking is the same: eliminate it. Of course,
          chances are you cannot simply abolish all other processes. If that
          were possible in your environment, you probably would not need Linux
          to begin with—a simple custom operating system would suffice. If,
          however, your system has multiple processors, you can dedicate one
          or more of those processors to your real-time process or processes.
          In effect, you can shield the real-time processes from
          multitasking.</p>
<p>We discussed system calls for manipulating a process' CPU
          affinity earlier in this chapter. A potential optimization for
          real-time applications is to reserve one processor for each
          real-time process, and let all other processes time-share on the
          remaining processor.</p>
<p>The simplest way to achieve this is to modify Linux's
          <emphasis>init</emphasis> program,
          <emphasis>SysVinit</emphasis>,<sup>[27]</sup> to do something similar to the following before it
          begins the boot process:cpu_set_t set;
int ret;

CPU_ZERO (&amp;set);        /* clear all CPUs */
ret = sched_getaffinity (0, sizeof (cpu_set_t), &amp;set);
if (ret == −1) {
        perror ("sched_getaffinity");
        return 1;
}

CPU_CLR (1, &amp;set);      /* forbid CPU #1 */
ret = sched_setaffinity (0, sizeof (cpu_set_t), &amp;set);
if (ret == −1) {
        perror ("sched_setaffinity");
        return 1;
}</p>
<p>This snippet grabs init's current set of allowed processors,
          which we expect is all of them. It then removes one processor, CPU
          #1, from the set and updates the list of allowed processors.</p>
<p>Because the set of allowed processors is inherited from parent
          to child, and init is the super-parent of all processes, all of the
          system's processes will run with this set of allowed processors.
          Consequently, no processes will ever run on CPU #1.</p>
<p>Next, modify your real-time process to run only on CPU
          #1:cpu_set_t set;
int ret;

CPU_ZERO (&amp;set);        /* clear all CPUs */
CPU_CLR (1, &amp;set);      /* forbid CPU #1 */
ret = sched_setaffinity (0, sizeof (cpu_set_t), &amp;set);
if (ret == −1) {
        perror ("sched_setaffinity");
        return 1;
}</p>
<p>The result is that your real-time process runs only on CPU #1
          and all other processes run on the other processors.</p>
<empty-line/>
<p><strong>Resource Limits</strong></p>
<p>The Linux kernel imposes several <emphasis>resource
      limits</emphasis> on processes. These resource limits place hard
      ceilings on the amount of kernel resources that a process can
      consume—that is, the number of open files, pages of memory, pending
      signals, and so on. The limits are strictly enforced; the kernel will
      not allow an action that places a process' resource consumption over a
      hard limit. For example, if opening a file would cause a process to have
      more open files than allowed by the applicable resource limit, the
      open( ) invocation will
      fail.<sup>[28]</sup></p>
<p>Linux provides two system calls for manipulating resource limits.
      POSIX standardized both interfaces, but Linux supports several limits in
      addition to those dictated by the standard. Limits can be checked with
      getrlimit( ) and set with setrlimit( ):<strong>#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;

struct rlimit {
        rlim_t rlim_cur;  /* soft limit */
        rlim_t rlim_max;  /* hard limit */
};

int getrlimit (int resource, struct rlimit *rlim);
int setrlimit (int resource, const struct rlimit *rlim);</strong></p>
<p>Integer constants, such as RLIMIT_CPU, represent the resources. The
      rlimit structure represents the
      actual limits. The structure defines two ceilings: a <emphasis>soft
      limit</emphasis>, and a <emphasis>hard limit</emphasis>. The kernel
      enforces soft resource limits on processes, but a process may freely
      change its soft limit to any value from 0 up to and including the hard limit. A
      process without the CAP_SYS_RESOURCE
      capability (i.e., any nonroot process) can only lower its hard limit. An
      unprivileged process can never raise its hard limit, not even to a
      previously higher value; lowering the hard limit is irreversible. A
      privileged process can set the hard limit to any valid value.</p>
<p>What the limits actually represent depends on the resource in
      question. If resource is RLIMIT_FSIZE, for example, the limit
      represents the maximum size of a file that a process can create, in
      bytes. In this case, if rlim_cur is
      1,024, a process cannot create or extend a file to a size greater than
      one kilobyte.</p>
<p>All of the resource limits have two special values: 0 and infinity. The former disables use of the
      resource altogether. For example, if RLIMIT_CORE is 0, the kernel will never create a core file.
      Conversely, the latter removes any limit on the resource. The kernel
      denotes infinity by the special value RLIM_INFINITY, which happens to be −1 (this can cause some confusion, as −1 is also the return value indicating error).
      If RLIMIT_CORE is infinity, the
      kernel will create core files of any size.</p>
<p>The function getrlimit( )
      places the current hard and soft limits on the resource denoted by
      resource in the structure pointed at
      by rlim. On success, the call returns
      0. On failure, the call returns
      −1, and sets errno as appropriate.</p>
<p>Correspondingly, the function setrlimit(
      ) sets the hard and soft limits associated with resource to the values pointed at by rlim. On success, the call returns 0, and the kernel updates the resource limits
      as requested. On failure, the call returns −1, and sets errno as appropriate.</p>
<empty-line/>
<p><strong>The Limits</strong></p>
<p>Linux currently provides 15 resource limits:</p>
<p>RLIMIT_AS</p>
<p>Limits the maximum size of a process' address space, in
              bytes. Attempts to increase the size of the address space past
              this limit—via calls such as mmap(
              ) and brk( )—will
              fail, and return ENOMEM. If
              the process' stack, which automatically grows as needed, expands
              beyond this limit, the kernel sends the process the SIGSEGV signal. This limit is usually
              RLIM_INFINITY.RLIMIT_CORE</p>
<p>Dictates the maximum size of core files, in bytes. If
              nonzero, core files larger than this limit are truncated to the
              maximum size. If 0, core
              files are never created.RLIMIT_CPU</p>
<p>Dictates the maximum CPU time that a process can consume,
              in seconds. If a process runs for longer than this limit, the
              kernel sends it a SIGXCPU
              signal, which processes may catch and handle. Portable programs
              should terminate on receipt of this signal, as POSIX leaves
              undefined what action the kernel may take next. Some systems may
              terminate the process if it continues to run. Linux, however,
              allows the process to continue executing, and continues sending
              SIGXCPU signals at one second
              intervals. Once the process reaches the hard limit, it is sent a
              SIGKILL and
              terminated.RLIMIT_DATA</p>
<p>Controls the maximum size of a process' data segment and
              heap, in bytes. Attempts to enlarge the data segment beyond this
              limit via brk( ) will fail
              and return ENOMEM.RLIMIT_FSIZE</p>
<p>Specifies the maximum file size that a process may create,
              in bytes. If a process expands a file beyond this size, the
              kernel sends the process a SIGXFSZ signal. By default, this
              signal terminates the process. A process may, however, elect to
              catch and handle this signal, in which case, the offending
              system call fails, and returns EFBIG.RLIMIT_LOCKS</p>
<p>Controls the maximum number of file locks that a process
              may hold (see Chapter 7
              for a discussion of file locks). Once this limit is reached,
              further attempts to acquire additional file locks should fail,
              and return ENOLCK. Linux
              kernel 2.4.25, however, removed this functionality. In current
              kernels, this limit is settable, but has no effect.RLIMIT_MEMLOCK</p>
<p>Specifies the maximum number of bytes of memory that a
              process without the CAP_SYS_IPC capability (effectively, a
              nonroot process) can lock into memory via mlock( ), mlockall( ), or shmctl( ). If this limit is exceeded,
              these calls fail, and return EPERM. In practice, the effective
              limit is rounded down to an integer multiple of pages. Processes
              possessing CAP_SYS_IPC can
              lock any number of pages into memory, and this limit has no
              effect. Before kernel 2.6.9, this limit was the maximum that a
              process with CAP_SYS_IPC
              could lock into memory, and unprivileged processes could not
              lock any pages whatsoever. This limit is not part of POSIX; BSD
              introduced it.RLIMIT_MSGQUEUE</p>
<p>Specifies the maximum number of bytes that a user may
              allocate for POSIX message queues. If a newly created message
              queue would exceed this limit, mq_open(
              ) fails, and returns ENOMEM. This limit is not part of
              POSIX; it was added in kernel 2.6.8 and is
              Linux-specific.RLIMIT_NICE</p>
<p>Specifies the maximum value to which a process can lower
              its nice value (raise its priority). As discussed earlier in
              this chapter, normally processes can only raise their nice
              values (lower their priorities). This limit allows the
              administrator to impose a maximum level (nice value floor) to
              which processes may legally raise their priorities. Because nice
              values may be negative, the kernel interprets the value as
              20 - rlim_cur. Thus, if this
              limit is set to 40, a process can lower its nice value to the
              minimum value of −20 (the highest priority). Kernel 2.6.12
              introduced this limit.RLIMIT_NOFILE</p>
<p>Specifies one greater than the maximum number of file
              descriptors that a process may hold open. Attempts to surpass
              this limit result in failure and the applicable system call
              returning EMFILE. This limit
              is also specifiable as RLIMIT_OFILE, which is BSD's name for
              it.RLIMIT_NPROC</p>
<p>Specifies the maximum number of processes that the user
              may have running on the system at any given moment. Attempts to
              surpass this limit result in failure, and fork( ), returning EAGAIN. This limit is not part of
              POSIX; BSD introduced it.RLIMIT_RSS</p>
<p>Specifies the maximum number of pages that a process may
              have resident in memory (known as the resident set size, or
              RSS). Only early 2.4 kernels enforced this limit. Current
              kernels allow the setting of this limit, but it is not enforced.
              This limit is not part of POSIX; BSD introduced it.RLIMIT_RTPRIO</p>
<p>Specifies the maximum real-time priority level a process
              without the CAP_SYS_NICE
              capability (effectively, nonroot processes) may request.
              Normally, unprivileged processes may not request any real-time
              scheduling class. This limit is not part of POSIX; it was added
              in kernel 2.6.12, and is Linux-specific.RLIMIT_SIGPENDING</p>
<p>Specifies the maximum number of signals (standard and
              real-time) that may be queued for this user. Attempts to queue
              additional signals fail, and system calls such as sigqueue( ) return EAGAIN. Note that it is always
              possible, regardless of this limit, to queue one instance of a
              not-yet-queued signal. Therefore, it is always possible to
              deliver to the process a SIGKILL or SIGTERM. This limit is not part of
              POSIX; it is Linux-specific.RLIMIT_STACK</p>
<p>Denotes the maximum size of a process' stack, in bytes.
              Surpassing this limit results in the delivery of a SIGSEGV.</p>
<p>The kernel manages the resource limits on a per-process basis. A
        child process inherits its limits from its parent during fork; limits
        are maintained across exec.</p>
<empty-line/>
<p><strong>Default limits</strong></p>
<p>The default limits available to your process depend on three
          variables: the initial soft limit, the initial hard limit, and your
          system administrator. The kernel dictates the initial hard and soft
          limits; Table 6-1
          lists them. The kernel sets these limits on the init process, and
          because children inherit the limits of their parents, all subsequent
          processes inherit the soft and hard limits of init.</p>
<p><emphasis>Table 6-1. Default soft and hard resource limits</emphasis></p>
<p><strong>Resource
                  limit</strong></p>
<p><strong>Soft
                  limit</strong></p>
<p><strong>Hard
                  limit</strong></p>
<p>RLIMIT_AS</p>
<p>RLIM_INFINITY</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_CORE</p>
<p>0</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_CPU</p>
<p>RLIM_INFINITY</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_DATA</p>
<p>RLIM_INFINITY</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_FSIZE</p>
<p>RLIM_INFINITY</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_LOCKS</p>
<p>RLIM_INFINITY</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_MEMLOCK</p>
<p>8
                  pages</p>
<p>8
                  pages</p>
<p>RLIMIT_MSGQUEUE</p>
<p>800 KB</p>
<p>800 KB</p>
<p>RLIMIT_NICE</p>
<p>0</p>
<p>0</p>
<p>RLIMIT_NOFILE</p>
<p>1024</p>
<p>1024</p>
<p>RLIMIT_NPROC</p>
<p>0(implies no limit)</p>
<p>0(implies no limit)</p>
<p>RLIMIT_RSS</p>
<p>RLIM_INFINITY</p>
<p>RLIM_INFINITY</p>
<p>RLIMIT_RTPRIO</p>
<p>0</p>
<p>0</p>
<p>RLIMIT_SIGPENDING</p>
<p>0</p>
<p>0</p>
<p>RLIMIT_STACK</p>
<p>8 MB</p>
<p>RLIM_INFINITY</p>
<p>Two things can change these default limits:</p>
<p>Any process is free to increase a soft limit to any value
              from 0 to the hard limit, or
              to decrease a hard limit. Children will inherit these updated
              limits during a fork.</p>
<p>A privileged process is free to set a hard limit to any
              value. Children will inherit these updated limits during a
              fork.</p>
<p>It is unlikely that a root process in a regular process'
          lineage will change any hard limits. Consequently, the first item is
          a much more likely source of limit changes than the second. Indeed,
          the actual limits presented to a process are generally set by the
          user's shell, which the system administrator can set up to provide
          various limits. In the Bourne-again shell
          (<emphasis>bash</emphasis>), for example, the administrator
          accomplishes this via the <emphasis>ulimit</emphasis> command. Note
          that the administrator need not lower values; he can also raise soft
          limits to the hard limits, providing users with saner defaults. This
          is often done with RLIMIT_STACK,
          which is set to RLIM_INFINITY on
          many systems.</p>
<empty-line/>
<p><strong>Setting and Retrieving Limits</strong></p>
<p>With the explanations of the various resource limits behind us,
        let's look at retrieving and setting limits. Retrieving a resource
        limit is quite simple:struct rlimit rlim;
int ret;

/* get the limit on core sizes */
ret = getrlimit (RLIMIT_CORE, &amp;rlim);
if (ret == −1) {
        perror ("getrlimit");
        return 1;
}

printf ("RLIMIT_CORE limits: soft=%ld hard=%ld\n",
        rlim.rlim_cur, rlim.rlim_max);</p>
<p>Compiling this snippet in a larger program and running it yields
        the following:RLIMIT_CORE limits: soft=0 hard=−1</p>
<p>We have a soft limit of 0,
        and a hard limit of infinity (−1
        denotes RLIM_INFINITY). Therefore,
        we can set a new soft limit of any size. This example sets the maximum
        core size to 32 MB:struct rlimit rlim;
int ret;

rlim.rlim_cur = 32 * 1024 * 1024; /* 32 MB */
rlim.rlim_max = RLIM_INFINITY;    /* leave it alone */
ret = setrlimit (RLIMIT_CORE, &amp;rlim);
if (ret == −1) {
        perror ("setrlimit");
        return 1;
}</p>
<empty-line/>
<p><strong>Error codes</strong></p>
<p>On error, three errno codes
          are possible:</p>
<p>EFAULT</p>
<p>The memory pointed at by rlim is invalid or
                inaccessible.EINVAL</p>
<p>The value denoted by resource is invalid, or rlim.rlim_cur is greater than
                rlim.rlim_max (setrlimit( ) only).EPERM</p>
<p>The caller did not possess CAP_SYS_RESOURCE, but tried to raise
                the hard limit.</p>
<empty-line/><empty-line/>
<p><sup>[25] </sup><sup>*</sup> For the curious reader, the
          process scheduler is self-contained, and defined in
          <emphasis>kernel/sched.c</emphasis> in the kernel source
          tree.</p>
<p><sup>[26] </sup><sup>*</sup> The
            <emphasis>util-linux</emphasis> package is located at <a l:href="http://www.kernel.org/pub/linux/utils/util-linux">http://www.kernel.org/pub/linux/utils/util-linux</a>.
            It is licensed under the GNU General Public License v2.</p>
<p><sup>[27] </sup><sup>*</sup> The
              <emphasis>SysVinit</emphasis> source is located at <a l:href="ftp://ftp.cistron.nl/pub/people/miquels/sysvinit/">ftp://ftp.cistron.nl/pub/people/miquels/sysvinit/</a>.
              It is licensed under the GNU General Public License v2.</p>
<p><sup>[28] </sup><sup>*</sup> In which case the call will set
          errno to EMFILE, indicating that the process hit
          the resource limit on the maximum number of open files. Chapter 2 discusses the open( ) system call.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 7. File and Directory Management</strong></p>
<p>In Chapter 2, Chapter 3, and Chapter 4, we covered an abundance of
    approaches to file I/O. In this chapter, we'll revisit files, this time
    focusing not on reading from or writing to them, but rather on
    manipulating and managing them and their metadata.</p>
<empty-line/>
<p><strong>Files and Their Metadata</strong></p>
<p>As discussed in Chapter 1, each file is
      referenced by an <emphasis>inode</emphasis>, which is addressed by a
      filesystem-unique numerical value known as an <emphasis>inode
      number</emphasis>. An inode is both a physical object located on the
      disk of a Unix-style filesystem, and a conceptual entity represented by
      a data structure in the Linux kernel. The inode stores the
      <emphasis>metadata</emphasis> associated with a file, such as the file's
      access permissions, last access timestamp, owner, group, and size, as
      well as the location of the file's data.</p>
<p>You can obtain the inode number for a file using the
      <emphasis>-i</emphasis> flag to the <emphasis>ls</emphasis>
      command:$ ls -i
1689459 Kconfig    1689461 main.c     1680144 process.c  1689464 swsusp.c
1680137 Makefile   1680141 pm.c       1680145 smp.c      1680149 user.c
1680138 console.c  1689462 power.h    1689463 snapshot.c
1689460 disk.c     1680143 poweroff.c 1680147 swap.c</p>
<p>This output shows that, for example, <emphasis>disk.c</emphasis>
      has an inode number of 1689460. On this particular filesystem, no other
      file will have this inode number. On a different filesystem, however, we
      can make no such guarantees.</p>
<empty-line/>
<p><strong>The Stat Family</strong></p>
<p>Unix provides a family of functions for obtaining the metadata
        of a file:<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int stat (const char *path, struct stat *buf);
int fstat (int fd, struct stat *buf);
int lstat (const char *path, struct stat *buf);</strong></p>
<p>Each of these functions returns information about a file.
        stat( ) returns information about
        the file denoted by the path, <emphasis>path</emphasis>, while
        fstat( ) returns information about
        the file represented by the file descriptor fd. lstat(
        ) is identical to stat(
        ), except that in the case of a symbolic link, lstat( ) returns information about the link
        itself and not the target file.</p>
<p>Each of these functions stores information in a stat structure, which is provided by the
        user. The stat structure is defined
        in &lt;bits/stat.h&gt;, which is
        included from &lt;sys/stat.h&gt;:<strong>struct stat {
        dev_t st_dev;         /* ID of device containing file */
        ino_t st_ino;         /* inode number */
        mode_t st_mode;       /* permissions */
        nlink_t st_nlink;     /* number of hard links */
        uid_t st_uid;         /* user ID of owner */
        gid_t st_gid;         /* group ID of owner */
        dev_t st_rdev;        /* device ID (if special file) */
        off_t st_size;        /* total size in bytes */
        blksize_t st_blksize; /* blocksize for filesystem I/O */
        blkcnt_t st_blocks;   /* number of blocks allocated */
        time_t st_atime;      /* last access time */
        time_t st_mtime;      /* last modification time */
        time_t st_ctime;      /* last status change time */
};</strong></p>
<p>In more detail, the fields are as follows:</p>
<p>The st_dev field
            describes the device node on which the file resides (we will cover
            device nodes later in this chapter). If the file is not backed by
            a device—for example, if it resides on an NFS mount—this value is
            0.</p>
<p>The st_ino field provides
            the file's inode number.</p>
<p>The st_mode field
            provides the file's mode bytes. Chapter 1 and Chapter 2 covered mode bytes and
            permissions.</p>
<p>The st_nlink field
            provides the number of hard links pointing at the file. Every file
            has at least one hard link.</p>
<p>The st_uid field provides
            the user ID of the user who owns the file.</p>
<p>The st_gid field provides
            the group ID of the group who owns the file.</p>
<p>If the file is a device node, the st_rdev field describes the device that
            this file represents.</p>
<p>The st_size field
            provides the size of the file, in bytes.</p>
<p>The st_blksize field
            describes the preferred block size for efficient file I/O. This
            value (or an integer multiple) is the optimal block size for
            user-buffered I/O (see Chapter 3).</p>
<p>The st_blocks field
            provides the number of filesystem blocks allocated to the file.
            This value will be smaller than the value provided by st_size if the file has holes (that is,
            if the file is a sparse file).</p>
<p>The st_atime field
            contains the last <emphasis>file access time</emphasis>. This is
            the most recent time at which the file was accessed (for example,
            by read( ) or execle( )).</p>
<p>The st_mtime field
            contains the last <emphasis>file modification time</emphasis>—that
            is, the last time the file was written to.</p>
<p>The st_ctime field
            contains the last <emphasis>file change time</emphasis>. This is
            often misunderstood to be the file creation time, which is not
            preserved on Linux, or other Unix-style systems. The field
            actually describes the last time that the file's metadata (for
            example, its owner or permissions) was changed.</p>
<p>On success, all three calls return 0, and store the file's metadata in the
        provided stat structure. On error,
        they return −1, and set errno to one of the following:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for one of
              the directory components of path (stat(
              ) and lstat( )
              only).EBADF</p>
<p>fd is invalid (fstat( ) only).EFAULT</p>
<p>path or buf is an invalid pointer.ELOOP</p>
<p>path contains too many
              symbolic links (stat( ) and
              lstat( ) only).ENAMETOOLONG</p>
<p>path is too long
              (stat( ) and lstat( ) only).ENOENT</p>
<p>A component in path
              does not exist (stat( ) and
              lstat( ) only).ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.ENOTDIR</p>
<p>A component in path is
              not a directory (stat( ) and
              lstat( ) only).</p>
<p>The following program uses stat(
        ) to retrieve the size of a file provided on the command
        line:#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char *argv[])
{
        struct stat sb;
        int ret;

        if (argc &lt; 2) {
                fprintf (stderr,
                         "usage: %s &lt;file&gt;\n", argv[0]);
                return 1;
        }

        ret = stat (argv[1], &amp;sb);
        if (ret) {
                perror ("stat");
                return 1;
        }

        printf ("%s is %ld bytes\n",
                argv[1], sb.st_size);

        return 0;
}</p>
<p>Here is the result of running the program on its own source
        file:$ ./stat stat.c
stat.c is 392 bytes</p>
<p>This snippet, in turn, uses fstat(
        ) to check whether an already opened file is on a physical
        (as opposed to a network) device:/*
 * is_on_physical_device - returns a positive
 * integer if 'fd' resides on a physical device,
 * 0 if the file resides on a nonphysical or
 * virtual device (e.g., on an NFS mount), and
 * −1 on error.
 */
int is_on_physical_device (int fd)
{
        struct stat sb;
        int ret;

        ret = fstat (fd, &amp;sb);
        if (ret) {
                perror ("fstat");
                return −1;
        }

        return gnu_dev_major (sb.st_dev);
}</p>
<empty-line/>
<p><strong>Permissions</strong></p>
<p>While the stat calls can be used to obtain the permission values
        for a given file, two other system calls set those values:<strong>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int chmod (const char *path, mode_t mode);
int fchmod (int fd, mode_t mode);</strong></p>
<p>Both chmod( ) and fchmod( ) set a file's permissions to
        mode. With chmod( ), path denotes the relative or absolute
        pathname of the file to modify. For fchmod(
        ), the file is given by the file descriptor fd.</p>
<p>The legal values for mode,
        represented by the opaque mode_t
        integer type, are the same as those returned by the st_mode field in the stat structure. Although the values are
        simple integers, their meanings are specific to each Unix
        implementation. Consequently, POSIX defines a set of constants that
        represent the various permissions (see "Permissions of New Files" in Chapter 2 for full details).
        These constants can be binary-ORed together to form the legal values
        for mode. For example, (S_IRUSR | S_IRGRP) sets the file's
        permissions as both owner- and group-readable.</p>
<p>To change a file's permissions, the effective ID of the process
        calling chmod( ) or fchmod( ) must match the owner of the file,
        or the process must have the CAP_FOWNER capability.</p>
<p>On success, both calls return 0. On failure, both calls return −1, and set errno to one of the following error
        values:</p>
<p>EACCESS</p>
<p>The invoking process lacked search permission for a
              component in path (chmod( ) only).EBADF</p>
<p>The file descriptor fd
              is invalid (fchmod( )
              only).EFAULT</p>
<p>path is an invalid
              pointer (chmod( )
              only).EIO</p>
<p>An internal I/O error occurred on the filesystem. This is
              a very bad error to encounter; it could indicate a corrupt disk
              or filesystem.ELOOP</p>
<p>The kernel encountered too many symbolic links while
              resolving path (chmod( ) only).ENAMETOOLONG</p>
<p>path is too long
              (chmod( ) only).ENOENT</p>
<p>path does not exist
              (chmod( ) only).ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.ENOTDIR</p>
<p>A component in path is
              not a directory (chmod( )
              only).EPERM</p>
<p>The effective ID of the invoking process does not match
              the owner of the file, and the process lacks the CAP_FOWNER capability.EROFS</p>
<p>The file resides on a read-only filesystem.</p>
<p>This code snippet sets the file <emphasis>map.png</emphasis> to
        owner-readable and -writable:int ret;

/*
 * Set 'map.png' in the current directory to
 * owner-readable and -writable. This is the
 * same as 'chmod 600 ./map.png'.
 */
ret = chmod ("./map.png", S_IRUSR | S_IWUSR);
if (ret)
        perror ("chmod");</p>
<p>This code snippet does the same thing, assuming that fd represents the open file
        <emphasis>map.png</emphasis>:int ret;

/*
 * Set the file behind 'fd' to owner-readable
 * and -writable.
 */
ret = fchmod (fd, S_IRUSR | S_IWUSR);
if (ret)
        perror ("fchmod");</p>
<p>Both chmod( ) and fchmod( ) are available on all modern Unix
        systems. POSIX requires the former, and makes the latter
        optional.</p>
<empty-line/>
<p><strong>Ownership</strong></p>
<p>In the stat structure, the
        st_uid and st_gid fields provide the file's owner and
        group, respectively. Three system calls allow a user to change those
        two values:<strong>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int chown (const char *path, uid_t owner, gid_t group);
int lchown (const char *path, uid_t owner, gid_t group);
int fchown (int fd, uid_t owner, gid_t group);</strong></p>
<p>chown( ) and lchown( ) set the ownership of the file
        specified by the path path. They
        have the same effect, unless the file is a symbolic link: the former
        follows symbolic links and changes the ownership of the link target
        rather than the link itself, while lchown(
        ) does not follow symbolic links and therefore changes the
        ownership of the symbolic link file instead. fchown( ) sets the ownership of the file
        represented by the file descriptor fd.</p>
<p>On success, all three calls set the file's owner to owner, set the file's group to group, and return 0. If either the owner or the group field is −1, that value is not set. Only a process
        with the CAP_CHOWN capability
        (usually a root process) may change the owner of a file. The owner of
        a file can change the file's group to any group to which the user is a
        member; processes with CAP_CHOWN
        can change the file's group to any value.</p>
<p>On failure, the calls return −1, and set errno to one of the following values:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for a
              component in path (chown( ) and lchown( ) only).EBADF</p>
<p>fd is invalid (fchown( ) only).EFAULT</p>
<p>path is invalid
              (chown( ) and lchown( ) only).EIO</p>
<p>There was an internal I/O error (this is bad).ELOOP</p>
<p>The kernel encountered too many symbolic links in
              resolving path (chown( ) and lchown( ) only).ENAMETOOLONG</p>
<p>path is too long
              (chown( ) and lchown( ) only).ENOENT</p>
<p>The file does not exist.ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.ENOTDIR</p>
<p>A component in path is
              not a directory (chown( ) and
              lchown( ) only).EPERM</p>
<p>The invoking process lacked the necessary rights to change
              the owner or the group as requested.EROFS</p>
<p>The filesystem is read-only.</p>
<p>This code snippet changes the group of the file
        <emphasis>manifest.txt</emphasis> in the current working directory to
        <emphasis>officers</emphasis>. For this to succeed, the invoking user
        either must possess the CAP_CHOWN
        capability or must be <emphasis>kidd</emphasis> and in the
        <emphasis>officers</emphasis> group:struct group *gr;
int ret;
/*
 * getgrnam(  ) returns information on a group
 * given its name.
 */
gr = getgrnam ("officers");
if (!gr) {
        /* likely an invalid group */
        perror ("getgrnam");
        return 1;
}

/* set manifest.txt's group to 'officers' */
ret = chown("manifest.txt", -1, gr-&gt;gr_gid);
if (ret)
        perror ("chown");</p>
<p>Before invocation, the file's group is
        <emphasis>crew</emphasis>:$ ls -l
-rw-r--r--  1 kidd  crew  13274 May 23 09:20 manifest.txt</p>
<p>After invocation, the file is for the sole privilege of the
        officers:$ ls -l
-rw-r--r--  1 kidd  officers 13274 May 23 09:20 manifest.txt</p>
<p>The file's owner, <emphasis>kidd</emphasis>, is not changed
        because the code snippet passed −1
        for uid.</p>
<p>This function sets the file represented by fd to root ownership and group:/*
 * make_root_owner - changes the owner and group of the file
 * given by 'fd' to root. Returns 0 on success and −1 on
 * failure.
 */
int make_root_owner (int fd)
{
        int ret;

        /* 0 is both the gid and the uid for root */
        ret = fchown (fd, 0, 0);
        if (ret)
                perror ("fchown");

        return ret;
}</p>
<p>The invoking process must have the CAP_CHOWN capability. As is par for the
        course with capabilities, this generally means that it must be owned
        by root.</p>
<empty-line/>
<p><strong>Extended Attributes</strong></p>
<p><emphasis>Extended attributes</emphasis>, also called
        <emphasis>xattrs</emphasis>, provide a mechanism for permanently
        associating key/value pairs with files. In this chapter, we have
        already discussed all sorts of key/value metadata associated with
        files: the file's size, owner, last modification timestamp, and so on.
        Extended attributes allow existing filesystems to support new features
        that weren't anticipated in their original designs, such as mandatory
        access controls for security. What makes extended attributes
        interesting is that user-space applications may arbitrarily create,
        read from, and write to the key/value pairs.</p>
<p>Extended attributes are
        <emphasis>filesystem-agnostic</emphasis>, in the sense that
        applications use a standard interface for manipulating them; the
        interface is not specific to any filesystem. Applications can thus use
        extended attributes without concern for what filesystem the files
        reside on, or how the filesystem internally stores the keys and
        values. Still, the implementation of extended attributes is very
        filesystem-specific. Different filesystems store extended attributes
        in quite different ways, but the kernel hides these differences,
        abstracting them away behind the extended attribute
        interface.</p>
<p>The <emphasis>ext3</emphasis> filesystem, for example, stores a
        file's extended attributes in empty space in the file's
        inode.<sup>[29]</sup> This feature makes reading extended attributes very
        fast. Because the filesystem block containing the inode is read off
        the disk and into memory whenever an application accesses a file, the
        extended attributes are "automatically" read into memory, and can be
        accessed without any additional overhead.</p>
<p>Other filesystems, such as <emphasis>FAT</emphasis> and
        <emphasis>minixfs</emphasis>, do not support extended attributes at
        all. These filesystems return ENOTSUP when extended attribute operations
        are invoked on their files.</p>
<empty-line/>
<p><strong>Keys and values</strong></p>
<p>A unique <emphasis>key</emphasis> identifies each extended
          attribute. Keys must be valid UTF-8. They take the form
          <emphasis>namespace.attribute</emphasis>. Every key must be fully
          qualified; that is, it must begin with a valid namespace, followed
          by a period. An example of a valid key name is
          <emphasis>user.mime_type</emphasis>; this key is in the
          <emphasis>user</emphasis> namespace with the attribute name
          <emphasis>mime_type</emphasis>.</p>
<p><strong>A Better Way to Store MIME Types</strong></p>
<p>GUI file managers, such as GNOME's Nautilus, behave
            differently for files of varying types: they offer unique icons,
            different default click behavior, special lists of operations to
            perform, and so on. To accomplish this, the file manager has to
            know the format of each file. To determine the format, filesystems
            such as Windows simply look at the file's extension. For reasons
            of both tradition and security, however, Unix systems tend to
            inspect the file and interpret its type. This process is called
            <emphasis>MIME type sniffing</emphasis>.</p>
<p>Some file managers generate this information on the fly;
            others generate the information once and then cache it. Those that
            cache the information tend to put it in a custom database. The
            file manager must work to keep this database in sync with the
            files, which can change without the file manager's knowledge. A
            better approach is to jettison the custom database and store such
            metadata in extended attributes: these are easier to maintain,
            faster to access, and readily accessible by any
            application.</p>
<p>A key may be <emphasis>defined</emphasis> or
          <emphasis>undefined</emphasis>. If a key is defined, its value may
          be empty or nonempty. That is, there is a difference between an
          undefined key, and a defined key with no assigned value. As we shall
          see, this means a special interface is required for removing keys
          (assigning them an empty value is not sufficient).</p>
<p>The value associated with a key, if nonempty, may be any
          arbitrary array of bytes. Because the value is not necessarily a
          string, it need not be null-terminated, although null-termination
          certainly makes sense if you choose to store a C string as a key's
          value. Since the values are not guaranteed to be null-terminated,
          all operations on extended attributes require the size of the value.
          When reading an attribute, the kernel provides the size; when
          writing an attribute, you must provide the size.</p>
<p>Linux does not enforce any limits on the number of keys, the
          length of a key, the size of a value, or the total space that can be
          consumed by all of the keys and values associated with a file.
          Filesystems, however, have practical limits. These limits are
          usually manifested as constraints on the total size of all of the
          keys, and values associated with a given file.</p>
<p>With <emphasis>ext3</emphasis>, for example, all extended
          attributes for a given file must fit within the slack space in the
          file's inode, and up to one additional filesystem block. (Older
          versions of <emphasis>ext3</emphasis> were limited to the one
          filesystem block, without the in-inode storage.) This equates to a
          practical limit of about 1 KB to 8 KB per file, depending on the
          size of the filesystem's blocks. <emphasis>XFS</emphasis>, in
          contrast, has no practical limits. Even with
          <emphasis>ext3</emphasis>, however, these limits are usually not an
          issue, as most keys and values are short text strings. Nonetheless,
          keep them in mind—think twice before storing the entire revision
          control history of a project in a file's extended attributes!</p>
<empty-line/>
<p><strong>Extended attribute namespaces</strong></p>
<p>The namespaces associated with extended attributes are more
          than just organizational tools. The kernel enforces different access
          policies depending on the namespace.</p>
<p>Linux currently defines four extended attribute namespaces,
          and may define more in the future. The current four are as
          follows:</p>
<p><emphasis>system</emphasis></p>
<p>The <emphasis>system</emphasis> namespace is used to
                implement kernel features that utilize extended attributes,
                such as access control lists (ACLs). An example of an extended
                attribute in this namespace is
                <emphasis>system.posix_acl_access</emphasis>. Whether users
                can read from or write to these attributes depends on the
                security module in place. Assume at worst that no user
                (including root) can even read these attributes.<emphasis>security</emphasis></p>
<p>The <emphasis>security</emphasis> namespace is used to
                implement security modules, such as SELinux. Whether
                user-space applications can access these attributes depends,
                again, on the security module in place. By default, all
                processes can read these attributes, but only processes with
                the CAP_SYS_ADMIN
                capability can write to them.<emphasis>trusted</emphasis></p>
<p>The <emphasis>trusted</emphasis> namespace stores
                restricted information in user space. Only processes with the
                CAP_SYS_ADMIN capability
                can read from or write to these attributes.<emphasis>user</emphasis></p>
<p>The <emphasis>user</emphasis> namespace is the standard
                namespace for use by regular processes. The kernel controls
                access to this namespace via the normal file permission bits.
                To read the value from an existing key, a process must have
                read access to the given file. To create a new key, or to
                write a value to an existing key, a process must have write
                access to the given file. You can assign extended attributes
                in the user namespace only to regular files, not to symbolic
                links or device files. When designing a user-space application
                that uses extended attributes, this is likely the namespace
                you want.</p>
<empty-line/>
<p><strong>Extended attribute operations</strong></p>
<p>POSIX defines four operations that applications may perform on
          a given file's extended attributes:</p>
<p>Given a file and a key, return the corresponding
              value.</p>
<p>Given a file, a key, and a value, assign that value to the
              key.</p>
<p>Given a file, return a list of all of the file's assigned
              extended attribute keys.</p>
<p>Given a file and a key, remove that extended attribute
              from the file.</p>
<p>For each operation, POSIX provides three system calls:</p>
<p>A version that operates on a given pathname; if the path
              refers to a symbolic link, the target of the link is operated
              upon (the usual behavior).</p>
<p>A version that operates on a given pathname; if the path
              refers to a symbolic link, the link itself is operated upon (the
              standard l variant of a
              system call).</p>
<p>A version that operates on a file descriptor (the standard
              f variant).</p>
<p>In the following subsections, we will cover all 12
          permutations.</p>
<empty-line/>
<p>Retrieving an extended attribute</p>
<p>The simplest operation is returning the value of an extended
            attribute from a file, given the key:<strong>#include &lt;sys/types.h&gt;
#include &lt;attr/xattr.h&gt;

ssize_t getxattr (const char *path, const char *key,
                  void *value, size_t size);
ssize_t lgetxattr (const char *path, const char *key,
                   void *value, size_t size);
ssize_t fgetxattr (int fd, const char *key,
                   void *value, size_t size);</strong></p>
<p>A successful call to getxattr(
            ) stores the extended attribute with name key from the file path in the provided buffer value, which is size bytes in length. It returns the
            actual size of the value.</p>
<p>If size is 0, the call returns the size of the
            value without storing it in value. Thus, passing 0 allows applications to determine the
            correct size for the buffer in which to store the key's value.
            Given this size, applications can then allocate or resize the
            buffer as needed.</p>
<p>lgetxattr( ) behaves the
            same as getxattr( ), unless
            path is a symbolic link, in
            which case it returns extended attributes from the link itself
            rather than the target of the link. Recall from the previous
            section that attributes in the user namespace cannot be applied to
            symbolic links—thus, this call is rarely used.</p>
<p>fgetxattr( ) operates on
            the file descriptor fd;
            otherwise, it behaves the same as getxattr( ).</p>
<p>On error, all three calls return −1, and set errno to one of the following
            values:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for one
                  of the directory components of path (getxattr( ) and lgetxattr( ) only).EBADF</p>
<p>fd is invalid
                  (fgetxattr( )
                  only).EFAULT</p>
<p>path, key, or value is an invalid
                  pointer.ELOOP</p>
<p>path contains too
                  many symbolic links (getxattr(
                  ) and lgetxattr(
                  ) only).ENAMETOOLONG</p>
<p>path is too long
                  (getxattr( ) and lgetxattr( ) only).ENOATTR</p>
<p>The attribute key
                  does not exist, or the process does not have access to the
                  attribute.ENOENT</p>
<p>A component in path
                  does not exist (getxattr(
                  ) and lgetxattr(
                  ) only).ENOMEM</p>
<p>There is insufficient memory available to complete the
                  request.ENOTDIR</p>
<p>A component in path
                  is not a directory (getxattr(
                  ) and lgetxattr(
                  ) only).ENOTSUP</p>
<p>The filesystem on which path or fd resides does not support
                  extended attributes.ERANGE</p>
<p>size is too small
                  to hold the value of key.
                  As previously discussed, the call may be reissued with
                  size set to 0; the return value will indicate
                  the required buffer size, and value may be resized
                  appropriately.</p>
<empty-line/>
<p>Setting an extended attribute</p>
<p>The following three system calls set a given extended
            attribute:<strong>#include &lt;sys/types.h&gt;
#include &lt;attr/xattr.h&gt;

int setxattr (const char *path, const char *key,
              const void *value, size_t size, int flags);
int lsetxattr (const char *path, const char *key,
               const void *value, size_t size, int flags);
int fsetxattr (int fd, const char *key,
               const void *value, size_t size, int flags);</strong></p>
<p>A successful call to setxattr(
            ) sets the extended attribute key on the file path to value, which is size bytes in length. The flags field modifies the behavior of the
            call. If flags is XATTR_CREATE, the call will fail if the
            extended attribute already exists. If flags is XATTR_REPLACE, the call will fail if the
            extended attribute does not exist. The default behavior—performed
            if flags is 0—allows both creations and
            replacements. Regardless of the value of flags, keys other than key are unaffected.</p>
<p>lsetxattr( ) behaves the
            same as setxattr( ), unless
            path is a symbolic link, in
            which case it sets the extended attributes on the link itself,
            rather than on the target of the link. Recall that attributes in
            the user namespace cannot be applied to symbolic links—thus, this
            call is also rarely used.</p>
<p>fsetxattr( ) operates on
            the file descriptor fd;
            otherwise, it behaves the same as setxattr( ).</p>
<p>On success, all three system calls return 0; on failure, the calls return −1, and set errno to one of the following:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for one
                  of the directory components of path (setxattr( ) and lsetxattr( ) only).EBADF</p>
<p>fd is invalid
                  (fsetxattr( )
                  only).EDQUOT</p>
<p>A quota limit prevents the space consumption required
                  by the requested operation.EEXIST</p>
<p>XATTR_CREATE was
                  set in flags, and
                  key already exists on the
                  given file.EFAULT</p>
<p>path, key, or value is an invalid
                  pointer.EINVAL</p>
<p>flags is
                  invalid.ELOOP</p>
<p>path contains too
                  many symbolic links (setxattr(
                  ) and lsetxattr(
                  ) only).ENAMETOOLONG</p>
<p>path is too long
                  (setxattr( ) and lsetxattr( ) only).ENOATTR</p>
<p>XATTR_REPLACE was
                  set in flags, and
                  key does not exist on the
                  given file.ENOENT</p>
<p>A component in path
                  does not exist (setxattr(
                  ) and lsetxattr(
                  ) only).ENOMEM</p>
<p>There is insufficient memory available to complete the
                  request.ENOSPC</p>
<p>There is insufficient space on the filesystem to store
                  the extended attribute.ENOTDIR</p>
<p>A component in path
                  is not a directory (setxattr(
                  ) and lsetxattr(
                  ) only).ENOTSUP</p>
<p>The filesystem on which path or fd resides does not support
                  extended attributes.</p>
<empty-line/>
<p>Listing the extended attributes on a file</p>
<p>The following three system calls enumerate the set of
            extended attribute keys assigned to a given file:<strong>#include &lt;sys/types.h&gt;
#include &lt;attr/xattr.h&gt;

ssize_t listxattr (const char *path,
                   char *list, size_t size);
ssize_t llistxattr (const char *path,
                    char *list, size_t size);
ssize_t flistxattr (int fd,
                    char *list, size_t size);</strong></p>
<p>A successful call to listxattr(
            ) returns a list of the extended attribute keys
            associated with the file denoted by path. The list is stored in the buffer
            provided by list, which is
            size bytes in length. The
            system call returns the actual size of the list, in bytes.</p>
<p>Each extended attribute key returned in list is terminated by a null character,
            so a list might look like this:"user.md5_sum\0user.mime_type\0system.posix_acl_default\0"</p>
<p>Thus, although each key is a traditional, null-terminated C
            string, you need the length of the entire list (which you can
            retrieve from the call's return value) to walk the list of keys.
            To find out how large a buffer you need to allocate, call one of
            the list functions with a size
            of 0; this causes the function
            to return the actual length of the full list of keys. As with
            getxattr( ), applications may
            use this functionality to allocate or resize the buffer to pass
            for value.</p>
<p>llistxattr( ) behaves the
            same as listxattr( ), unless
            path is a symbolic link, in
            which case the call enumerates the extended attribute keys
            associated with the link itself rather than with the target of the
            link. Recall that attributes in the user namespace cannot be
            applied to symbolic links—thus, this call is rarely used.</p>
<p>flistxattr( ) operates on
            the file descriptor fd;
            otherwise, it behaves the same as listxattr( ).</p>
<p>On failure, all three calls return −1, and set errno to one of the following error
            codes:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for one
                  of the directory components of path (listxattr( ) and llistxattr( ) only).EBADF</p>
<p>fd is invalid
                  (flistxattr( )
                  only).EFAULT</p>
<p>path or list is an invalid pointer.ELOOP</p>
<p>path contains too
                  many symbolic links (listxattr(
                  ) and llistxattr(
                  ) only).ENAMETOOLONG</p>
<p>path is too long
                  (listxattr( ) and
                  llistxattr( )
                  only).ENOENT</p>
<p>A component in path
                  does not exist (listxattr(
                  ) and llistxattr(
                  ) only).ENOMEM</p>
<p>There is insufficient memory available to complete the
                  request.ENOTDIR</p>
<p>A component in path
                  is not a directory (listxattr(
                  ) and llistxattr(
                  ) only).ENOTSUPP</p>
<p>The filesystem on which path or fd resides does not support
                  extended attributes.ERANGE</p>
<p>size is nonzero,
                  and is insufficiently large to hold the complete list of
                  keys. The application may reissue the call with size set to 0 to discover the actual size of
                  the list. The program may then resize value and reissue the system
                  call.</p>
<empty-line/>
<p>Removing an extended attribute</p>
<p>Finally, these three system calls remove a given key from a
            given file:<strong>#include &lt;sys/types.h&gt;
#include &lt;attr/xattr.h&gt;

int removexattr (const char *path, const char *key);
int lremovexattr (const char *path, const char *key);
int fremovexattr (int fd, const char *key);</strong></p>
<p>A successful call to removexattr(
            ) removes the extended attribute key from the file path. Recall that there is a difference
            between an undefined key and a defined key with an empty
            (zero-length) value.</p>
<p>lremovexattr( ) behaves
            the same as removexattr( ),
            unless path is a symbolic link,
            in which case the call removes the extended attribute key
            associated with the link itself rather than with the target of the
            link. Recall that attributes in the user namespace cannot be
            applied to symbolic links—thus, this call is also rarely
            used.</p>
<p>fremovexattr( ) operates
            on the file descriptor fd;
            otherwise, it behaves the same as removexattr( ).</p>
<p>On success, all three system calls return 0. On failure, all three calls return
            −1, and set errno to one of the following:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for one
                  of the directory components of path (removexattr( ) and lremovexattr( ) only).EBADF</p>
<p>fd is invalid
                  (fremovexattr( )
                  only).EFAULT</p>
<p>path or key is an invalid pointer.ELOOP</p>
<p>path contains too
                  many symbolic links (removexattr(
                  ) and lremovexattr(
                  ) only).ENAMETOOLONG</p>
<p>path is too long
                  (removexattr( ) and
                  lremovexattr( )
                  only).ENOATTR</p>
<p>key does not exist
                  on the given file.ENOENT</p>
<p>A component in path
                  does not exist (removexattr(
                  ) and lremovexattr(
                  ) only).ENOMEM</p>
<p>There is insufficient memory available to complete the
                  request.ENOTDIR</p>
<p>A component in path
                  is not a directory (removexattr(
                  ) and lremovexattr(
                  ) only).ENOTSUPP</p>
<p>The filesystem on which path or fd resides does not support
                  extended attributes.</p>
<empty-line/>
<p><strong>Directories</strong></p>
<p>In Unix, a <emphasis>directory</emphasis> is a simple concept: it
      contains a list of filenames, each of which maps to an inode number.
      Each name is called a <emphasis>directory entry</emphasis>, and each
      name-to-inode mapping is called a <emphasis>link</emphasis>. A
      directory's contents—what the user sees as the result of an
      <emphasis>ls</emphasis>—are a listing of all the filenames in that
      directory. When the user opens a file in a given directory, the kernel
      looks up the filename in that directory's list to find the corresponding
      inode number. The kernel then passes that inode number to the
      filesystem, which uses it to find the physical location of the file on
      the device.</p>
<p>Directories can also contain other directories. A
      <emphasis>subdirectory</emphasis> is a directory inside of another
      directory. Given this definition, all directories are subdirectories of
      some <emphasis>parent directory</emphasis>, with the exception of the
      directory at the very root of the filesystem tree,
      <emphasis>/</emphasis>. Not surprisingly, this directory is called the
      <emphasis>root directory</emphasis> (not to be confused with root's home
      directory, <emphasis>/root</emphasis>).</p>
<p>A <emphasis>pathname</emphasis> consists of a filename along with
      one or more of its parent directories. An <emphasis>absolute
      pathname</emphasis> is a pathname that begins with the root
      directory—for example, <emphasis>/usr/bin/sextant</emphasis>. A
      <emphasis>relative pathname</emphasis> is a pathname that does not begin
      with the root directory, such as <emphasis>bin/sextant</emphasis>. For
      such a pathname to be useful, the operating system must know the
      directory to which the path is relative. The current working directory
      (discussed in the next section) is used as the starting point.</p>
<p>File and directory names can contain any character except
      <emphasis>/</emphasis>, which delineates directories in a pathname, and
      <emphasis>null</emphasis>, which terminates the pathname. That said, it
      is standard practice to constrain the characters in pathnames to valid
      printable characters under the current locale, or even just ASCII. Since
      neither the kernel nor the C library enforces this practice, however, it
      is up to applications to enforce the use of only valid printable
      characters.</p>
<p>Older Unix systems limited filenames to 14 characters. Today, all
      modern Unix filesystems allow at least 255 bytes for each
      filename.<sup>[30]</sup> Many filesystems under Linux allow even longer
      filenames.<sup>[31]</sup></p>
<p>Every directory contains two special directories,
      <emphasis>.</emphasis> and <emphasis>..</emphasis> (called
      <emphasis>dot</emphasis> and <emphasis>dot-dot</emphasis>). The dot
      directory is a reference to the directory itself. The dot-dot directory
      is a reference to the directory's parent directory. For example,
      <emphasis>/home/kidd/gold/..</emphasis> is the same directory as
      <emphasis>/home/kidd</emphasis>. The root directory's dot and dot-dot
      directories point to itself—that is, <emphasis>/</emphasis>,
      <emphasis>/.</emphasis>, and <emphasis>/..</emphasis> are all the same
      directory. Technically speaking, therefore, one could say that even the
      root directory is a subdirectory—in this case, of itself.</p>
<empty-line/>
<p><strong>The Current Working Directory</strong></p>
<p>Every process has a current directory, which it initially
        inherits from its parent process. That directory is known as the
        process' <emphasis>current working directory</emphasis> (cwd). The
        current working directory is the starting point from which the kernel
        resolves relative pathnames. For example, if a process' current
        working directory is <emphasis>/home/blackbeard</emphasis>, and that
        process tries to open <emphasis>parrot.jpg</emphasis>, the kernel will
        attempt to open <emphasis>/home/blackbeard/parrot.jpg</emphasis>.
        Conversely, if the process tries to open
        <emphasis>/usr/bin/mast</emphasis>, the kernel will indeed open
        <emphasis>/usr/bin/mast</emphasis>—the current working directory has
        no impact on absolute pathnames (that is, pathnames that start with a
        slash).</p>
<p>A process can both obtain and change its current working
        directory.</p>
<empty-line/>
<p><strong>Obtaining the current working directory</strong></p>
<p>The preferred method for obtaining the current working
          directory is the getcwd( ) system
          call, which POSIX standardized:<strong>#include &lt;unistd.h&gt;

char * getcwd (char *buf, size_t size);</strong></p>
<p>A successful call to getcwd(
          ) copies the current working directory as an absolute
          pathname into the buffer pointed at by buf, which is of length size bytes, and returns a pointer to
          buf. On failure, the call returns
          NULL, and sets errno to one of the following
          values:</p>
<p>EFAULT</p>
<p>buf is an invalid
                pointer.EINVAL</p>
<p>size is 0, but buf is not NULL.ENOENT</p>
<p>The current working directory is no longer valid. This
                can happen if the current working directory is removed.ERANGE</p>
<p>size is too small to
                hold the current working directory in buf. The application needs to
                allocate a larger buffer and try again.</p>
<p>Here's an example of using getcwd(
          ):char cwd[BUF_LEN];

if (!getcwd (cwd, BUF_LEN)) {
        perror ("getcwd");
        exit (EXIT_FAILURE);
}

printf ("cwd = %s\n", cwd);</p>
<p>POSIX dictates that the behavior of getcwd( ) is undefined if buf is NULL. Linux's C library, in this case,
          will allocate a buffer of length size bytes, and store the current working
          directory there. If size is
          0, the C library will allocate a
          buffer sufficiently large to store the current working directory. It
          is then the application's responsibility to free the buffer, via
          free( ), when it's done with it.
          Because this behavior is Linux-specific, applications that value
          portability or a strict adherence to POSIX should not rely on this
          functionality. This feature, however, does make usage very simple!
          Here's an example:char *cwd;

cwd = getcwd (NULL, 0);
if (!cwd) {
        perror ("getcwd");
        exit (EXIT_FAILURE);
}

printf ("cwd = %s\n", cwd);

free (cwd);</p>
<p>Linux's C library also provides a get_current_dir_name( ) function, which
          has the same behavior as getcwd(
          ) when passed a NULL
          buf and a size of
          0:<strong>#define _GNU_SOURCE
#include &lt;unistd.h&gt;

char * get_current_dir_name (void);</strong></p>
<p>Thus, this snippet behaves the same as the previous
          one:char *cwd;

cwd = get_current_dir_name (  );
if (!cwd) {
        perror ("get_current_dir_name");
        exit (EXIT_FAILURE);
}

printf ("cwd = %s\n", cwd);

free (cwd);</p>
<p>Older BSD systems favored the getwd(
          ) call, which Linux provides for backward
          compatibility:<strong>#define _XOPEN_SOURCE_EXTENDED /* or _BSD_SOURCE */
#include &lt;unistd.h&gt;

char * getwd (char *buf);</strong></p>
<p>A call to getwd( ) copies
          the current working directory into buf, which must be at least PATH_MAX bytes in length. The call returns
          buf on success and NULL on failure. For example:char cwd[PATH_MAX];

if (!getwd (cwd)) {
        perror ("getwd");
        exit (EXIT_FAILURE);
}

printf ("cwd = %s\n", cwd);</p>
<p>For reasons of both portability and security, applications
          should not use getwd( ); getcwd( ) is preferred.</p>
<empty-line/>
<p><strong>Changing the current working directory</strong></p>
<p>When a user first logs into her system, the login process sets
          her current working directory to her home directory, as specified in
          <emphasis>/etc/passwd</emphasis>. Sometimes, however, a process
          wants to change its current working directory. For example, a shell
          may want to do this when the user types
          <emphasis>cd</emphasis>.</p>
<p>Linux provides two system calls for changing the current
          working directory, one that accepts the pathname of a directory, and
          another that accepts a file descriptor representing an open
          directory:<strong>#include &lt;unistd.h&gt;

int chdir (const char *path);
int fchdir (int fd);</strong></p>
<p>A call to chdir( ) changes
          the current working directory to the pathname specified by path, which can be an absolute or a
          relative pathname. Similarly, a call to fchdir( ) changes the current working
          directory to the pathname represented by the file descriptor
          fd, which must be opened against
          a directory. On success, both calls return 0. On failure, both calls return −1.</p>
<p>On failure, chdir( ) also
          sets errno to one of the
          following values:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for one of
                the directory components of path.EFAULT</p>
<p>path is not a valid
                pointer.EIO</p>
<p>An internal I/O error occurred.ELOOP</p>
<p>The kernel encountered too many symbolic links while
                resolving path.ENAMETOOLONG</p>
<p>path is too
                long.ENOENT</p>
<p>The directory pointed at by path does not exist.ENOMEM</p>
<p>There is insufficient memory available to complete the
                request.ENOTDIR</p>
<p>One or more of the components in path is not a directory.</p>
<p>fchdir( ) sets errno to one of the following
          values:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for the
                directory referenced by fd
                (i.e., the execute bit is not set). This happens if the
                top-level directory is readable, but not executable; open( ) succeeds, but fchdir( ) will not.EBADF</p>
<p>fd is not an open
                file descriptor.</p>
<p>Depending on the filesystem, other error values are valid for
          either call.</p>
<p>These system calls affect only the currently running process.
          There is no mechanism in Unix for changing the current working
          directory of a different process. Therefore, the
          <emphasis>cd</emphasis> command found in shells cannot be a separate
          process (like most commands) that simply executes chdir( ) on the first command-line
          argument and then exits. Instead, <emphasis>cd</emphasis> must be a
          special built-in command that causes the shell itself to call
          chdir( ), changing its own
          current working directory.</p>
<p>The most common use of getcwd(
          ) is to save the current working directory so that the
          process can return to it later. For example:char *swd;
int ret;

/* save the current working directory */
swd = getcwd (NULL, 0);
if (!swd) {
        perror ("getcwd");
        exit (EXIT_FAILURE);
}

/* change to a different directory */
ret = chdir (some_other_dir);
if (ret) {
        perror ("chdir");
        exit (EXIT_FAILURE);
}

/* do some other work in the new directory... */

/* return to the saved directory */
ret = chdir (swd);
if (ret) {
        perror ("chdir");
        exit (EXIT_FAILURE);
}

free (swd);</p>
<p>It's better, however, to open(
          ) the current directory, and then fchdir( ) to it later. This approach is
          faster because the kernel does not store the pathname of the current
          working directory in memory; it stores only the inode. Consequently,
          whenever the user calls getcwd(
          ), the kernel must generate the pathname by walking the
          directory structure. Conversely, opening the current working
          directory is cheaper because the kernel already has its inode
          available and the human-readable pathname is not needed to open a
          file. The following snippet uses this approach:int swd_fd;

swd_fd = open (".", O_RDONLY);
if (swd_fd == −1) {
        perror ("open");
        exit (EXIT_FAILURE);
}

/* change to a different directory */
ret = chdir (some_other_dir);
if (ret) {
        perror ("chdir");
        exit (EXIT_FAILURE);
}

/* do some other work in the new directory... */

/* return to the saved directory */
ret = fchdir (swd_fd);
if (ret) {
        perror ("fchdir");
        exit (EXIT_FAILURE);
}

/* close the directory's fd */
ret = close (swd_fd);
if (ret) {
        perror ("close");
        exit (EXIT_FAILURE);
}</p>
<p>This is how shells implement the caching of the previous
          directory (for example, with <emphasis>cd -</emphasis> in
          <emphasis>bash</emphasis>).</p>
<p>A process that does not care about its current working
          directory—such as a daemon—generally sets it to
          <emphasis>/</emphasis> with the call chdir("/"). An application that interfaces
          with a user and his data, such as a word processor, generally sets
          its current working directory to the user's home directory, or to a
          special documents directory. Because current working directories are
          relevant only in the context of relative pathnames, the current
          working directory is of most utility to command-line utilities that
          the user invokes from the shell.</p>
<empty-line/>
<p><strong>Creating Directories</strong></p>
<p>Linux provides a single system call, standardized by POSIX, for
        creating new directories:<strong>#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

int mkdir (const char *path, mode_t mode);</strong></p>
<p>A successful call to mkdir( )
        creates the directory path, which
        may be relative or absolute, with the permission bits mode (as modified by the current umask), and
        returns 0.</p>
<p>The current umask modifies the mode argument in the usual way, plus any
        operating-system-specific mode bits: in Linux, the permission bits of
        the newly created directory are (mode &amp;
        ˜umask &amp; 01777). In other words, in effect, the umask
        for the process imposes restrictions that the mkdir( ) call cannot override. If the new
        directory's parent directory has the set group ID
        (<emphasis>sgid</emphasis>) bit set, or if the filesystem is mounted
        with BSD group semantics, the new directory will inherit the group
        affiliation from its parent. Otherwise, the effective group ID of the
        process will apply to the new directory.</p>
<p>On failure, mkdir( ) returns
        −1, and sets errno to one of the following values:</p>
<p>EACCESS</p>
<p>The parent directory is not writable by the current
              process, or one or more components of path are not searchable.EEXIST</p>
<p>path already exists
              (and not necessarily as a directory).EFAULT</p>
<p>path is an invalid
              pointer.ELOOP</p>
<p>The kernel encountered too many symbolic links while
              resolving path.ENAMETOOLONG</p>
<p>path is too
              long.ENOENT</p>
<p>A component in path
              does not exist or is a dangling symbolic link.ENOMEM</p>
<p>There is insufficient kernel memory to complete the
              request.ENOSPC</p>
<p>The device containing path is out of space, or the user's
              disk quota is over the limit.ENOTDIR</p>
<p>One or more of the components in path is not a directory.EPERM</p>
<p>The filesystem containing path does not support the creation of
              directories.EROFS</p>
<p>The filesystem containing path is mounted read-only.</p>
<empty-line/>
<p><strong>Removing Directories</strong></p>
<p>As the counterpart to mkdir(
        ), the POSIX-standardized rmdir(
        ) removes a directory from the filesystem
        hierarchy:<strong>#include &lt;unistd.h&gt;

int rmdir (const char *path);</strong></p>
<p>On success, rmdir( ) removes
        path from the filesystem, and
        returns 0. The directory specified
        by path must be empty, aside from
        the dot and dot-dot directories. There is no system call that
        implements the equivalent of a recursive delete, as with <emphasis>rm
        -r</emphasis>. Such a tool must manually perform a depth-first
        traversal of the filesystem, removing all files and directories
        starting with the leaves, and moving back up the filesystem; rmdir( ) can be used at each stage to remove
        a directory once its files have been removed.</p>
<p>On failure, rmdir( ) returns
        −1, and sets errno to one of the following values:</p>
<p>EACCESS</p>
<p>Write access to the parent directory of path is not allowed, or one of the
              component directories of path
              is not searchable.EBUSY</p>
<p>path is currently in
              use by the system, and cannot be removed. In Linux, this can
              happen only if path is a
              mount point or a root directory (root directories need not be
              mount points, thanks to chroot(
              )!).EFAULT</p>
<p>path is not a valid
              pointer.EINVAL</p>
<p>path has the dot
              directory as its final component.ELOOP</p>
<p>The kernel encountered too many symbolic links while
              resolving path.ENAMETOOLONG</p>
<p>path is too
              long.ENOENT</p>
<p>A component in path
              does not exist, or is a dangling symbolic link.ENOMEM</p>
<p>There is insufficient kernel memory to complete the
              request.ENOTDIR</p>
<p>One or more of the components in path is not a directory.ENOTEMPTY</p>
<p>path contains entries
              other than the special dot and dot-dot directories.EPERM</p>
<p>The parent directory of path has the sticky bit (S_ISVTX) set, but the process'
              effective user ID is neither the user ID of said parent nor of
              path itself, and the process
              does not have the CAP_FOWNER
              capability. Alternatively, the filesystem containing path does not allow the removal of
              directories.EROFS</p>
<p>The filesystem containing path is mounted read-only.</p>
<p>Usage is simple:int ret;

/* remove the directory /home/barbary/maps */
ret = rmdir ("/home/barbary/maps");
if (ret)
        perror ("rmdir");</p>
<empty-line/>
<p><strong>Reading a Directory's Contents</strong></p>
<p>POSIX defines a family of functions for reading the contents of
        directories—that is, obtaining a list of the files that reside in a
        given directory. These functions are useful if you are implementing
        <emphasis>ls</emphasis> or a graphical file save dialog, if you need
        to operate on every file in a given directory, or if you want to
        search for files in a directory that match a given pattern.</p>
<p>To begin reading a directory's contents you need to create a
        <emphasis>directory stream</emphasis>, which is represented by a
        DIR object:<strong>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

DIR * opendir (const char *name);</strong></p>
<p>A successful call to opendir(
        ) creates a directory stream representing the directory
        given by name.</p>
<p>A directory stream is little more than a file descriptor
        representing the open directory, some metadata, and a buffer to hold
        the directory's contents. Consequently, it is possible to obtain the
        file descriptor behind a given directory stream:<strong>#define _BSD_SOURCE /* or _SVID_SOURCE */
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

int dirfd (DIR *dir);</strong></p>
<p>A successful call to dirfd( )
        returns the file descriptor backing the directory stream dir. On error, the call returns −1. As the directory stream functions use
        this file descriptor internally, programs should only invoke calls
        that do not manipulate the file position. dirfd( ) is a BSD extension, and is not
        standardized by POSIX; programmers wishing to proclaim their POSIX
        compliance should avoid it.</p>
<empty-line/>
<p><strong>Reading from a directory stream</strong></p>
<p>Once you have created a directory stream with opendir( ), your program can begin reading
          entries from the directory. To do this, use readdir( ), which returns entries one by
          one from a given DIR
          object:<strong>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

struct dirent * readdir (DIR *dir);</strong></p>
<p>A successful call to readdir(
          ) returns the next entry in the directory represented by
          dir. The dirent structure represents a directory
          entry. Defined in &lt;dirent.h&gt;, on Linux, its definition
          is:<strong>struct dirent {
        ino_t d_ino; /* inode number */
        off_t d_off; /* offset to the next dirent */
        unsigned short d_reclen; /* length of this record */
        unsigned char d_type; /* type of file */
        char d_name[256]; /* filename */
};</strong></p>
<p>POSIX requires only the d_name field, which is the name of a
          single file within the directory. The other fields are optional, or
          Linux-specific. Applications desiring portability to other systems,
          or conformance to POSIX should access only d_name.</p>
<p>Applications successively invoke readdir( ), obtaining each file in the
          directory, until they find the file they are searching for, or until
          the entire directory is read, at which time readdir( ) returns NULL.</p>
<p>On failure, readdir( ) also
          returns NULL. To differentiate
          between an error and having read all of the files, applications must
          set errno to 0 before each readdir( ) invocation, and then check both
          the return value and errno. The
          only errno value set by readdir( ) is EBADF, signifying that dir is invalid. Thus, many applications do
          not bother to check for errors, and assume that NULL means that no more files
          remain.</p>
<empty-line/>
<p><strong>Closing the directory stream</strong></p>
<p>To close a directory stream opened with opendir( ), use closedir( ):<strong>#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

int closedir (DIR *dir);</strong></p>
<p>A successful call to closedir(
          ) closes the directory stream represented by dir, including the backing file
          descriptor, and returns 0. On
          failure, the function returns −1,
          and sets errno to EBADF, the only possible error code,
          signifying that dir is not an
          open directory stream.</p>
<p>The following snippet implements a function, find_file_in_dir( ), that uses readdir( ) to search a given directory for
          a given filename. If the file exists in the directory, the function
          returns 0. Otherwise, it returns
          a nonzero value:/*
 * find_file_in_dir - searches the directory 'path' for a
 * file named 'file'.
 *
 * Returns 0 if 'file' exists in 'path' and a nonzero
 * value otherwise.
 */
int find_file_in_dir (const char *path, const char *file)
{
        struct dirent *entry;
        int ret = 1;
        DIR *dir;

        dir = opendir (path);

        errno = 0;
        while ((entry = readdir (dir)) != NULL) {
                if (!strcmp(entry-&gt;d_name, file)) {
                        ret = 0;
                        break;
                }
        }

        if (errno &amp;&amp; !entry)
                perror ("readdir");

        closedir (dir);
        return ret;
}</p>
<empty-line/>
<p><strong>System calls for reading directory contents</strong></p>
<p>The previously discussed functions for reading the contents of
          directories are standardized by POSIX, and provided by the C
          library. Internally, these functions use one of two system calls,
          readdir( ) and getdents( ), which are provided here for
          completeness:<strong>#include &lt;unistd.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/dirent.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;errno.h&gt;

/*
 * Not defined for user space: need to
 * use the _syscall3(  ) macro to access.
 */
int readdir (unsigned int fd,
             struct dirent *dirp,
             unsigned int count);

int getdents (unsigned int fd,
              struct dirent *dirp,
              unsigned int count);</strong></p>
<p>You do not want to use these system calls! They are obtuse,
          and not portable. Instead, user-space applications should use the C
          library's opendir( ), readdir( ), and closedir( ) system calls.</p>
<empty-line/>
<p><strong>Links</strong></p>
<p>Recall from our discussion of directories that each name-to-inode
      mapping in a directory is called a <emphasis>link</emphasis>. Given this
      simple definition—that a link is essentially just a name in a list (a
      directory) that points at an inode—there would appear to be no reason
      why multiple links to the same inode could not exist. That is, a single
      inode (and thus a single file) could be referenced from, say, both
      <emphasis>/etc/customs</emphasis> and
      <emphasis>/var/run/ledger</emphasis>.</p>
<p>Indeed, this is the case, with one catch: because links map to
      inodes, and inode numbers are specific to a particular filesystem,
      <emphasis>/etc/customs</emphasis> and
      <emphasis>/var/run/ledger</emphasis> must both reside on the same
      filesystem. Within a single filesystem, there can be a large number of
      links to any given file. The only limit is in the size of the integer
      data type used to hold the number of links. Among various links, no one
      link is the "original" or the "primary" link. All of the links enjoy the
      same status, pointing at the same file.</p>
<p>We call these types of links <emphasis>hard links</emphasis>.
      Files can have no, one, or many links. Most files have a link count of
      1—that is, they are pointed at by a single directory entry—but some
      files have two or even more links. Files with a link count of 0 have no
      corresponding directory entries on the filesystem. When a file's link
      count reaches 0, the file is marked as free, and its disk blocks are
      made available for reuse.<sup>[32]</sup> Such a file, however, remains on the filesystem if a
      process has the file open. Once no process has the file open, the file
      is removed.</p>
<p>The Linux kernel implements this behavior by using a link count
      and a usage count. The <emphasis>usage count</emphasis> is a tally of
      the number of instances where the file is open. A file is not removed
      from the filesystem until both the link and the usage counts hit
      0.</p>
<p>Another type of link, the <emphasis>symbolic link</emphasis>, is
      not a filesystem mapping, but a higher-level pointer that is interpreted
      at runtime. Such links may span filesystems—we'll look at them
      shortly.</p>
<empty-line/>
<p><strong>Hard Links</strong></p>
<p>The link( ) system call, one
        of the original Unix system calls, and now standardized by POSIX,
        creates a new link for an existing file:<strong>#include &lt;unistd.h&gt;

int link (const char *oldpath, const char *newpath);</strong></p>
<p>A successful call to link( )
        creates a new link under the path newpath for the existing file oldpath, and then returns 0. Upon completion, both oldpath and newpath refer to the same file—there is, in
        fact, no way to even tell which was the "original" link.</p>
<p>On failure, the call returns −1, and sets errno to one of the following:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for a
              component in oldpath, or the
              invoking process does not have write permission for the
              directory containing newpath.EEXIST</p>
<p>newpath already
              exists—link( ) will not
              overwrite an existing directory entry.EFAULT</p>
<p>oldpath or newpath is an invalid pointer.EIO</p>
<p>An internal I/O error occurred (this is bad!).ELOOP</p>
<p>Too many symbolic links were encountered in resolving
              oldpath or newpath.EMLINK</p>
<p>The inode pointed at by oldpath already has the maximum number
              of links pointing at it.ENAMETOOLONG</p>
<p>oldpath or newpath is too long.ENOENT</p>
<p>A component in oldpath
              or newpath does not
              exist.ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.ENOSPC</p>
<p>The device containing newpath has no room for the new
              directory entry.ENOTDIR</p>
<p>A component in oldpath
              or newpath is not a
              directory.EPERM</p>
<p>The filesystem containing newpath does not allow the creation of
              new hard links, or oldpath is
              a directory.EROFS</p>
<p>newpath resides on a
              read-only filesystem.EXDEV</p>
<p>newpath and oldpath are not on the same mounted
              filesystem. (Linux allows a single filesystem to be mounted in
              multiple places, but even in this case, hard links cannot be
              created across the mount points.)</p>
<p>This example creates a new directory entry,
        <emphasis>pirate</emphasis>, that maps to the same inode (and thus the
        same file) as the existing file <emphasis>privateer</emphasis>, both
        of which are in <emphasis>/home/kidd</emphasis>:int ret;

/*
 * create a new directory entry,
 * '/home/kidd/privateer', that points at
 * the same inode as '/home/kidd/pirate'
 */
ret = link ("/home/kidd/privateer", /home/kidd/pirate");
if (ret)
        perror ("link");</p>
<empty-line/>
<p><strong>Symbolic Links</strong></p>
<p>Symbolic links, also known as <emphasis>symlinks</emphasis> or
        <emphasis>soft links</emphasis>, are similar to hard links in that
        both point at files in the filesystem. The symbolic link differs,
        however, in that it is not merely an additional directory entry, but a
        special type of file altogether. This special file contains the
        pathname for a <emphasis>different</emphasis> file, called the
        symbolic link's <emphasis>target</emphasis>. At runtime, on the fly,
        the kernel substitutes this pathname for the symbolic link's pathname
        (unless using the various l
        versions of system calls, such as lstat(
        ), which operate on the link itself, and not the target).
        Thus, whereas one hard link is indistinguishable from another hard
        link to the same file, it is easy to tell the difference between a
        symbolic link and its target file.</p>
<p>A symbolic link may be relative or absolute. It may also contain
        the special dot directory discussed earlier, referring to the
        directory in which it is located, or the dot-dot directory, referring
        to the parent of this directory.</p>
<p>Soft links, unlike hard links, can span filesystems. They can
        point anywhere, in fact! Symbolic links can point at files that exist
        (the common practice), or at nonexistent files. The latter type of
        link is called a <emphasis>dangling symlink</emphasis>. Sometimes,
        dangling symlinks are unwanted—such as when the target of the link was
        deleted, but not the symlink—but at other times, they are
        intentional.</p>
<p>The system call for creating a symbolic link is very similar to
        its hard link cousin:<strong>#include &lt;unistd.h&gt;

int symlink (const char *oldpath, const char *newpath);</strong></p>
<p>A successful call to symlink(
        ) creates the symbolic link newpath pointing at the target oldpath, and then returns 0.</p>
<p>On error, symlink( ) returns
        −1, and sets errno to one of the following:</p>
<p>EACCESS</p>
<p>The invoking process lacks search permission for a
              component in oldpath, or the
              invoking process does not have write permission for the
              directory containing newpath.EEXIST</p>
<p>newpath already
              exists—symink( ) will not
              overwrite an existing directory entry.EFAULT</p>
<p>oldpath or newpath is an invalid pointer.EIO</p>
<p>An internal I/O error occurred (this is bad!).ELOOP</p>
<p>Too many symbolic links were encountered in resolving
              oldpath or newpath.EMLINK</p>
<p>The inode pointed at by oldpath already has the maximum number
              of links pointing at it.ENAMETOOLONG</p>
<p>oldpath or newpath is too long.ENOENT</p>
<p>A component in oldpath
              or newpath does not
              exist.ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.ENOSPC</p>
<p>The device containing newpath has no room for the new
              directory entry.ENOTDIR</p>
<p>A component in oldpath
              or newpath is not a
              directory.EPERM</p>
<p>The filesystem containing newpath does not allow the creation of
              new symbolic links.EROFS</p>
<p>newpath resides on a
              read-only filesystem.</p>
<p>This snippet is the same as our previous example, but it creates
        <emphasis>/home/kidd/pirate</emphasis> as a symbolic link (as opposed
        to a hard link) to <emphasis>/home/kidd/privateer</emphasis>:int ret;

/*
 * create a symbolic link,
 * '/home/kidd/privateer', that
 * points at '/home/kidd/pirate'
 */
ret = symlink ("/home/kidd/privateer", "/home/kidd/pirate");
if (ret)
        perror ("symlink");</p>
<empty-line/>
<p><strong>Unlinking</strong></p>
<p>The converse to linking is unlinking, the removal of pathnames
        from the filesystem. A single system call, unlink( ), handles this task:<strong>#include &lt;unistd.h&gt;

int unlink (const char *pathname);</strong></p>
<p>A successful call to unlink(
        ) deletes pathname from
        the filesystem, and returns 0. If
        that name was the last reference to the file, the file is deleted from
        the filesystem. If, however, a process has the file open, the kernel
        will not delete the file from the filesystem until that process closes
        the file. Once no process has the file open, it is deleted.</p>
<p>If pathname refers to a
        symbolic link, the link, not the target, is destroyed.</p>
<p>If pathname refers to another
        type of special file, such as a device, FIFO, or socket, the special
        file is removed from the filesystem, but processes that have the file
        open may continue to utilize it.</p>
<p>On error, unlink( ) returns
        −1, and sets errno to one of the following error
        codes:</p>
<p>EACCESS</p>
<p>The invoking process does not have write permission for
              the parent directory of pathname, or the invoking process does
              not have search permission for a component in pathname.EFAULT</p>
<p>pathname is an invalid
              pointer.EIO</p>
<p>An I/O error occurred (this is bad!).EISDIR</p>
<p>pathname refers to a
              directory.ELOOP</p>
<p>Too many symbolic links were encountered in traversing
              pathname.ENAMETOOLONG</p>
<p>pathname is too
              long.ENOENT</p>
<p>A component in pathname
              does not exist.ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.ENOTDIR</p>
<p>A component in pathname
              is not a directory.EPERM</p>
<p>The system does not allow the unlinking of files.EROFS</p>
<p>pathname resides on a
              read-only filesystem.</p>
<p>unlink( ) does not remove
        directories. For that, applications should use rmdir( ), which we discussed earlier (see
        "Removing Directories").</p>
<p>To ease the wanton destruction of any type of file, the C
        language provides the remove( )
        function:<strong>#include &lt;stdio.h&gt;

int remove (const char *path);</strong></p>
<p>A successful call to remove(
        ) deletes path from the
        filesystem, and returns 0. If
        path is a file, remove( ) invokes unlink( ); if path is a directory, remove( ) calls rmdir( ).</p>
<p>On error, remove( ) returns
        −1, and sets errno to any of the valid error codes set by
        unlink( ) and rmdir( ), as applicable.</p>
<empty-line/>
<p><strong>Copying and Moving Files</strong></p>
<p>Two of the most basic file manipulation tasks are copying and
      moving files, commonly carried out via the <emphasis>cp</emphasis> and
      <emphasis>mv</emphasis> commands. At the filesystem level,
      <emphasis>copying</emphasis> is the act of duplicating a given file's
      contents under a new pathname. This differs from creating a new hard
      link to the file in that changes to one file will not affect the
      other—that is, there now exist two distinct copies of the file, under
      (at least) two different directory entries. <emphasis>Moving</emphasis>,
      conversely, is the act of renaming the directory entry under which a
      file is located. This action does not result in the creation of a second
      copy.</p>
<empty-line/>
<p><strong>Copying</strong></p>
<p>Although it is surprising to some, Unix does not include a
        system or library call to facilitate the copying of files and
        directories. Instead, utilities such as <emphasis>cp</emphasis> or
        GNOME's Nautilus file manager perform these tasks manually.</p>
<p>In copying a file src to a
        file named dst, the steps are as
        follows:</p>
<p>Open src.</p>
<p>Open dst, creating it if
            it does not exist, and truncating it to zero length if it does
            exist.</p>
<p>Read a chunk of src into
            memory.</p>
<p>Write the chunk to dst.</p>
<p>Continue until all of src
            has been read and written to dst.</p>
<p>Close dst.</p>
<p>Close src.</p>
<p>If copying a directory, the individual directory and any
        subdirectories are created via mkdir(
        ); each file therein is then copied individually.</p>
<empty-line/>
<p><strong>Moving</strong></p>
<p>Unlike for copying, Unix does provide a system call for moving
        files. The ANSI C standard introduced the call for files, and POSIX
        standardized it for both files and directories:<strong>#include &lt;stdio.h&gt;

int rename (const char *oldpath, const char *newpath);</strong></p>
<p>A successful call to rename(
        ) renames the pathname oldpath to newpath. The file's contents and inode
        remain the same. Both oldpath and
        newpath must reside on the same
        filesystem<sup>[33]</sup>; if they do not, the call will fail. Utilities such as
        <emphasis>mv</emphasis> must handle this case by resorting to a copy
        and unlink.</p>
<p>On success, rename( ) returns
        0, and the file once referenced by
        oldpath is now referenced by
        newpath. On failure, the call
        returns −1, does not touch oldpath or newpath, and sets errno to one of the following values:</p>
<p>EACCESS</p>
<p>The invoking process lacks write permission for the parent
              of oldpath or newpath, search permission for a
              component of oldpath or
              newpath, or write permission
              for oldpath in the case that
              oldpath is a directory. The
              last case is an issue because rename(
              ) must update <emphasis>..</emphasis> in oldpath if it is a directory.EBUSY</p>
<p>oldpath or newpath is a mount point.EFAULT</p>
<p>oldpath or newpath is an invalid pointer.EINVAL</p>
<p>newpath is contained
              within oldpath, and thus,
              renaming one to the other would make oldpath a subdirectory of
              itself.EISDIR</p>
<p>newpath exists, and is
              a directory, but oldpath is
              not a directory.ELOOP</p>
<p>In resolving oldpath or
              newpath, too many symbolic
              links were encountered.EMLINK</p>
<p>oldpath already has the
              maximum number of links to itself, or oldpath is a directory, and newpath already has the maximum number
              of links to itself.ENAMETOOLONG</p>
<p>oldpath or newpath is too long.ENOENT</p>
<p>A component in oldpath
              or newpath does not exist, or
              is a dangling symbolic link.ENOMEM</p>
<p>There is insufficient kernel memory to complete the
              request.ENOSPC</p>
<p>There is insufficient space on the device to complete the
              request.ENOTDIR</p>
<p>A component (aside from potentially the final component)
              in oldpath or newpath is not a directory, or
              oldpath is a directory, and
              newpath exists but is not a
              directory.ENOTEMPTY</p>
<p>newpath is a directory
              and is not empty.EPERM</p>
<p>At least one of the paths specified in the arguments
              exists, the parent directory has the sticky bit set, the
              invoking process' effective user ID is neither the user ID of
              the file, nor that of the parent, and the process is not
              privileged.EROFS</p>
<p>The filesystem is marked read-only.EXDEV</p>
<p>oldpath and newpath are not on the same
              filesystem.</p>
<p>Table 7-1
        reviews the results of moving to and from different types of
        files.</p>
<p><emphasis>Table 7-1. Effects of moving to and from different types of
          files</emphasis></p>
<p> </p>
<p><strong>Destination is a
                file</strong></p>
<p><strong>Destination is a
                directory</strong></p>
<p><strong>Destination is a
                link</strong></p>
<p><strong>Destination does not
                exist</strong></p>
<p><strong>Source is a file</strong></p>
<p>The destination is
                overwritten by the source.</p>
<p>Failure with EISDIR.</p>
<p>The file is renamed and
                the destination is overwritten.</p>
<p>The file is
                renamed.</p>
<p><strong>Source is a directory</strong></p>
<p>Failure with ENOTDIR.</p>
<p>The source is renamed
                as the destination if the destination is empty; failure with
                ENOTEMPTY
                otherwise.</p>
<p>The directory is
                renamed, and the destination is overwritten.</p>
<p>The directory is
                renamed.</p>
<p><strong>Source is a link</strong></p>
<p>The link is renamed and
                the destination is overwritten.</p>
<p>Failure with EISDIR.</p>
<p>The link is renamed and
                the destination is overwritten.</p>
<p>The link is
                renamed.</p>
<p><strong>Source does not exist</strong></p>
<p>Failure with ENOENT.</p>
<p>Failure with ENOENT.</p>
<p>Failure with ENOENT.</p>
<p>Failure with ENOENT.</p>
<p>For all of these cases, regardless of their type, if the source
        and destination reside on different filesystems, the call fails and
        returns EXDEV.</p>
<empty-line/>
<p><strong>Device Nodes</strong></p>
<p><emphasis>Device nodes</emphasis> are special files that allow
      applications to interface with device drivers. When an application
      performs the usual Unix I/O—opening, closing, reading, writing, and so
      on—on a device node, the kernel does not handle those requests as normal
      file I/O. Instead, the kernel passes such requests to a device driver.
      The device driver handles the I/O operation, and returns the results to
      the user. Device nodes provide device abstraction so that applications
      do not need to be familiar with device specifics, or even master special
      interfaces. Indeed, device nodes are the standard mechanism for
      accessing hardware on Unix systems. Network devices are the rare
      exception, and over the course of Unix's history, some have argued that
      this exception is a mistake. There is, indeed, an elegant beauty in
      manipulating all of a machine's hardware using read( ), write(
      ), and mmap( )
      calls.</p>
<p>How does the kernel identify the device driver to which it should
      hand off the request? Each device node is assigned two numerical values,
      called a <emphasis>major number</emphasis>, and a <emphasis>minor
      number</emphasis>. These major and minor numbers map to a specific
      device driver loaded into the kernel. If a device node has a major and
      minor number that do not correspond to a device driver in the
      kernel—which occasionally happens, for a variety of reasons—an open( ) request on the device node returns
      −1 with errno set to ENODEV. We say that such device nodes front
      nonexistent devices.</p>
<empty-line/>
<p><strong>Special Device Nodes</strong></p>
<p>Several device nodes are present on all Linux systems. These
        device nodes are part of the Linux development environment, and their
        presence is considered part of the Linux ABI.</p>
<p>The <emphasis>null device</emphasis> has a major number of 1,
        and a minor number of 3. It lives at <emphasis>/dev/null</emphasis>.
        The device file should be owned by root and be readable and writable
        by all users. The kernel silently discards all write requests to the
        device. All read requests to the file return end-of-file
        (EOF).</p>
<p>The <emphasis>zero device</emphasis> lives at
        <emphasis>/dev/zero</emphasis>, and has a major of 1 and a minor of 5.
        Like the null device, the kernel silently discards writes to the zero
        device. Reading from the device returns an infinite stream of null
        bytes.</p>
<p>The <emphasis>full device</emphasis>, with a major of 1, and a
        minor of 7, lives at <emphasis>/dev/full</emphasis>. As with the zero
        device, read requests return null characters (\0). Write requests, however, always trigger
        the ENOSPC error, signifying that
        the underlying device is full.</p>
<p>These devices have varied purposes. They are useful for testing
        how an application handles corner and problem cases—a full filesystem,
        for example. Because the null and zero devices ignore writes, they
        also provide a no-overhead way to throw away unwanted I/O.</p>
<empty-line/>
<p><strong>The Random Number Generator</strong></p>
<p>The kernel's random number generator devices live at
        <emphasis>/dev/random</emphasis> and
        <emphasis>/dev/urandom</emphasis>. They have a major number of 1, and
        minor numbers of 8 and 9, respectively.</p>
<p>The kernel's random number generator gathers noise from device
        drivers and other sources, and the kernel concatenates together and
        one-way hashes the gathered noise. The result is then stored in an
        <emphasis>entropy pool</emphasis>. The kernel keeps an estimate of the
        number of bits of entropy in the pool.</p>
<p>Reads from <emphasis>/dev/random</emphasis> return entropy from
        this pool. The results are suitable for seeding random number
        generators, performing key generation, and other tasks that require
        cryptographically strong entropy.</p>
<p>In theory, an adversary who was able to obtain enough data from
        the entropy pool <emphasis>and</emphasis> successfully break the
        one-way hash could gain knowledge about the state of the rest of the
        entropy pool. Although such an attack is currently only a theoretical
        possibility—no such attacks are publicly known to have occurred—the
        kernel reacts to this possibility by decrementing its estimate of the
        amount of entropy in the pool with each read request. If the estimate
        reaches zero, the read will block until the system generates more
        entropy, and the entropy estimate is large enough to satisfy the
        read.</p>
<p><emphasis>/dev/urandom</emphasis> does not have this property;
        reads from the device will succeed even if the kernel's entropy
        estimate is insufficient to complete the request. Since only the most
        secure of applications—such as the generation of keys for secure data
        exchange in GNU Privacy Guard—should care about cryptographically
        strong entropy, most applications should use
        <emphasis>/dev/urandom</emphasis> and not
        <emphasis>/dev/random</emphasis>. Reads to the latter can potentially
        block for a very long time if no I/O activity occurs that feeds the
        kernel's entropy pool. This is not uncommon on diskless, headless
        servers.</p>
<empty-line/>
<p><strong>Out-of-Band Communication</strong></p>
<p>The Unix file model is impressive. With only simple read and write
      operations, Unix abstracts nearly any conceivable act one could perform
      on an object. Sometimes, however, programmers need to communicate with a
      file outside of its primary data stream. For example, consider a serial
      port device. Reading from the device would read from the hardware on the
      far end of the serial port; writing to the device would send data to
      that hardware. How would a process read one of the serial port's special
      status pins, such as the data terminal ready (DTR) signal?
      Alternatively, how would a process set the parity of the serial
      port?</p>
<p>The answer is to use the ioctl(
      ) system call. ioctl( ),
      which stands for <emphasis>I/O control</emphasis>, allows for
      <emphasis>out-of-band communication</emphasis>:<strong>#include &lt;sys/ioctl.h&gt;

int ioctl (int fd, int request, ...);</strong></p>
<p>The system call requires two parameters:</p>
<p>fd</p>
<p>The file descriptor of a file.request</p>
<p>A special request code value, predefined and agreed upon by
            the kernel and the process, that denotes what operation to perform
            on the file referenced by fd.</p>
<p>It may also receive one or more untyped optional parameters
      (usually unsigned integers or pointers) to pass into the kernel.</p>
<p>The following program uses the CDROMEJECT request to eject the media tray
      from a CD-ROM device, which the user provides as the first argument on
      the program's command line. This program thus functions similarly to the
      standard <emphasis>eject</emphasis> command:#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;linux/cdrom.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char *argv[])
{
        int fd, ret;

        if (argc &lt; 2) {
                fprintf (stderr,
                         "usage: %s &lt;device to eject&gt;\n",
                         argv[0]);
                return 1;
        }
        /*
         * Opens the CD-ROM device, read-only. O_NONBLOCK
         * tells the kernel that we want to open the device
         * even if there is no media present in the drive.
         */
        fd = open (argv[1], O_RDONLY | O_NONBLOCK);
        if (fd &lt; 0) {
                perror ("open");
                return 1;
        }

        /* Send the eject command to the CD-ROM device. */
        ret = ioctl (fd, CDROMEJECT, 0);
        if (ret) {
                perror ("ioctl");
                return 1;
        }

        ret = close (fd);
        if (ret) {
                perror ("close");
                return 1;
        }

        return 0;
}</p>
<p>The CDROMEJECT request is a
      feature of Linux's CD-ROM device driver. When the kernel receives an
      ioctl( ) request, it finds the
      filesystem (in the case of real files) or device driver (in the case of
      devices nodes) responsible for the file descriptor provided, and passes
      on the request for handling. In this case, the CD-ROM device driver
      receives the request and physically ejects the drive.</p>
<p>Later in this chapter, we will look at an ioctl( ) example that uses an optional
      parameter to return information to the requesting process.</p>
<empty-line/>
<p><strong>Monitoring File Events</strong></p>
<p>Linux provides an interface, <emphasis>inotify</emphasis>, for
      monitoring files—for example, to see when they are moved, read from,
      written to, or deleted. Imagine that you are writing a graphical file
      manager, such as GNOME's Nautilus. If a file is copied into a directory
      while Nautilus is displaying its contents, the file manager's view of
      the directory becomes inconsistent.</p>
<p>One solution is to continually reread the contents of the
      directory, detecting changes and updating the display. This imposes a
      periodic overhead, and is far from a very clean solution. Worse, there
      is always a race between when a file is removed from or added to the
      directory, and when the file manager rereads the directory.</p>
<p>With inotify, the kernel can <emphasis>push</emphasis> the event
      to the application the moment it happens. As soon as a file is deleted,
      the kernel can notify Nautilus. Nautilus, in response, can immediately
      remove the deleted file from the graphical display of the
      directory.</p>
<p>Many other applications are also concerned with file events.
      Consider a backup utility or a data-indexing tool. inotify allows both
      of these programs to operate in real time: the moment a file is created,
      deleted, or written to, the tools can update the backup archive or data
      index.</p>
<p>inotify replaces <emphasis>dnotify</emphasis>, an earlier
      file-monitoring mechanism with a cumbersome signals-based interface.
      Applications should always favor inotify over dnotify. inotify,
      introduced with kernel 2.6.13, is flexible and easy to use because the
      same operations that programs perform on regular files—notably, select( ) and poll(
      )—work with inotify. We cover only inotify in this
      book.</p>
<empty-line/>
<p><strong>Initializing inotify</strong></p>
<p>Before a process can use inotify, the process must initialize
        it. The inotify_init( ) system call
        initializes inotify and returns a file descriptor representing the
        initialized instance:<strong>#include &lt;inotify.h&gt;

int inotify_init (void);</strong></p>
<p>On error, inotify_init( )
        returns −1, and sets errno to one of the following codes:</p>
<p>EMFILE</p>
<p>The per-user limit on the maximum number of inotify
              instances has been reached.ENFILE</p>
<p>The system-wide limit on the maximum number of file
              descriptors has been reached.ENOMEM</p>
<p>There is insufficient memory available to complete the
              request.</p>
<p>Let's initialize inotify so we can use it in subsequent
        steps:int fd;

fd = inotify_init (  );
if (fd == −1) {
        perror ("inotify_init");
        exit (EXIT_FAILURE);
}</p>
<empty-line/>
<p><strong>Watches</strong></p>
<p>After a process initializes inotify, it sets up
        <emphasis>watches</emphasis>. A watch, represented by a
        <emphasis>watch descriptor</emphasis>, is a standard Unix path, and an
        associated <emphasis>watch mask</emphasis>, which tells the kernel
        what events the process is interested in—for example, reads, writes,
        or both.</p>
<p>inotify can watch both files and directories. If watching a
        directory, inotify reports events that occur on the directory itself,
        and on any of the files residing in the directory (but not on files in
        subdirectories of the watched directory—the watch is not
        recursive).</p>
<empty-line/>
<p><strong>Adding a new watch</strong></p>
<p>The system call inotify_add_watch(
          ) adds a watch for the event or events described by
          mask on the file or directory
          path to the inotify instance
          represented by fd:<strong>#include &lt;inotify.h&gt;

int inotify_add_watch (int fd,
                       const char *path,
                       uint32_t mask);</strong></p>
<p>On success, the call returns a new watch descriptor. On
          failure, inotify_add_watch( )
          returns −1, and sets errno to one of the following:</p>
<p>EACCESS</p>
<p>Read access to the file specified by path is not permitted. The invoking
                process must be able to read the file to add a watch to
                it.EBADF</p>
<p>The file descriptor fd is not a valid inotify
                instance.EFAULT</p>
<p>The pointer path is
                not valid.EINVAL</p>
<p>The watch mask, mask,
                contains no valid events.ENOMEM</p>
<p>There is insufficient memory available to complete the
                request.ENOSPC</p>
<p>The per-user limit on the total number of inotify
                watches has been reached.</p>
<empty-line/>
<p><strong>Watch masks</strong></p>
<p>The watch mask is a binary OR of one or more inotify events,
          which &lt;inotify.h&gt;
          defines:</p>
<p>IN_ACCESS</p>
<p>The file was read from.IN_MODIFY</p>
<p>The file was written to.IN_ATTRIB</p>
<p>The file's metadata (for example, the owner,
                permissions, or extended attributes) was changed.IN_CLOSE_WRITE</p>
<p>The file was closed, and had been open for
                writing.IN_CLOSE_NOWRITE</p>
<p>The file was closed, and had not been open for
                writing.IN_OPEN</p>
<p>The file was opened.IN_MOVED_FROM</p>
<p>A file was moved away from the watched directory.IN_MOVED_TO</p>
<p>A file was moved into the watched directory.IN_CREATE</p>
<p>A file was created in the watched directory.IN_DELETE</p>
<p>A file was deleted from the watched directory.IN_DELETE_SELF</p>
<p>The watched object itself was deleted.IN_MOVE_SELF</p>
<p>The watched object itself was moved.</p>
<p>The following events are also defined, grouping two or more
          events into a single value:</p>
<p>IN_ALL_EVENTS</p>
<p>All legal events.IN_CLOSE</p>
<p>All events related to closing (currently, both IN_CLOSE_WRITE and IN_CLOSE_NOWRITE).IN_MOVE</p>
<p>All move-related events (currently, both IN_MOVED_FROM and IN_MOVED_TO).</p>
<p>Now, we can look at adding a new watch to an existing inotify
          instance:int wd;

wd = inotify_add_watch (fd, "/etc", IN_ACCESS | IN_MODIFY);
if (wd == −1) {
        perror ("inotify_add_watch");
        exit (EXIT_FAILURE);
}</p>
<p>This example adds a watch for all reads or writes on the
          directory <emphasis>/etc</emphasis>. If any file in
          <emphasis>/etc</emphasis> is written to or read from, inotify sends
          an event to the inotify file descriptor, fd, providing the watch descriptor
          wd. Let's look at how inotify
          represents these events.</p>
<empty-line/>
<p><strong>inotify Events</strong></p>
<p>The inotify_event structure,
        defined in &lt;inotify.h&gt;,
        represents inotify events:<strong>#include &lt;inotify.h&gt;

struct inotify_event {
        int wd;          /* watch descriptor */
        uint32_t mask;   /* mask of events */
        uint32_t cookie; /* unique cookie */
        uint32_t len;    /* size of 'name' field */
        char name[];     /* null-terminated name */
};</strong></p>
<p>wd identifies the watch
        descriptor, as obtained by inotify_add_watch(
        ), and mask represents
        the events. If wd identifies a
        directory and one of the watched-for events occurred on a file within
        that directory, name provides the
        filename relative to the directory. In this case, len is nonzero. Note that len is <emphasis>not</emphasis> the same as
        the string length of name; name can have more than one trailing null
        character that acts as padding to ensure that a subsequent inotify_event is properly aligned.
        Consequently, you must use len, and
        not strlen( ), to calculate the
        offset of the next inotify_event
        structure in an array.</p>
<p>For example, if wd represents
        <emphasis>/home/rlove</emphasis>, and has a mask of IN_ACCESS, and the file
        <emphasis>/home/rlove/canon</emphasis> is read from, name will equal canon, and len will be at least 6. Conversely, if we were watching
        <emphasis>/home/rlove/canon</emphasis> directly with the same mask,
        len would be 0, and name would be zero-length—you must not touch
        it.</p>
<p>cookie is used to link
        together two related but disjoint events. We will address it in a
        subsequent section.</p>
<empty-line/>
<p><strong>Reading inotify events</strong></p>
<p>Obtaining inotify events is easy: you just read from the file
          descriptor associated with the inotify instance. inotify provides a
          feature known as <emphasis>slurping</emphasis>, which allows you to
          read multiple events—as many as fit in the buffer provided to
          read( )—with a single read
          request. Because of the variable-length name field, this is the most common way to
          read inotify events.</p>
<p>Our previous example instantiated an inotify instance, and
          added a watch to that instance. Now, let's read pending
          events:char buf[BUF_LEN] __attribute__((aligned(4)));
ssize_t len, i = 0;

/* read BUF_LEN bytes' worth of events */
len = read (fd, buf, BUF_LEN);

/* loop over every read event until none remain */
while (i &lt; len) {
        struct inotify_event *event =
                (struct inotify_event *) &amp;buf[i];
        printf ("wd=%d mask=%d cookie=%d len=%d dir=%s\n",
                event-&gt;wd, event-&gt;mask,
                event-&gt;cookie, event-&gt;len,
                (event-&gt;mask &amp; IN_ISDIR) ? "yes" : "no");

        /* if there is a name, print it */
        if (event-&gt;len)
                printf ("name=%s\n", event-&gt;name);

        /* update the index to the start of the next event */
        i += sizeof (struct inotify_event) + event-&gt;len;
}</p>
<p>Because the inotify file descriptor acts like a regular file,
          programs can monitor it via select(
          ), poll( ), and
          epoll( ). This allows processes
          to multiplex inotify events with other file I/O from a single
          thread.</p>
<empty-line/>
<p>Advanced inotify events</p>
<p>In addition to the standard events, inotify can generate
            other events:</p>
<p>IN_IGNORED</p>
<p>The watch represented by wd has been removed. This can
                  occur because the user manually removed the watch, or
                  because the watched object no longer exists. We will discuss
                  this event in a subsequent section.IN_ISDIR</p>
<p>The affected object is a directory. (If not set, the
                  affected object is a file.)IN_Q_OVERFLOW</p>
<p>The inotify queue overflowed. The kernel limits the
                  size of the event queue to prevent unbounded consumption of
                  kernel memory. Once the number of pending events reaches one
                  less than the maximum, the kernel generates this event, and
                  appends it to the tail of the queue. No further events are
                  generated until the queue is read from, reducing its size
                  below the limit.IN_UNMOUNT</p>
<p>The device backing the watched object was unmounted.
                  Thus, the object is no longer available; the kernel will
                  remove the watch, and generate the IN_IGNORED event.</p>
<p>Any watch can generate these events; the user need not set
            them explicitly.</p>
<p>Programmers must treat mask as a bitmask of pending events.
            Consequently, do <emphasis>not</emphasis> check for events using
            direct tests of equivalence:/* Do NOT do this! */

if (event-&gt;mask == IN_MODIFY)
        printf ("File was written to!\n");
else if (event-&gt;mask == IN_Q_OVERFLOW)
        printf ("Oops, queue overflowed!\n);</p>
<p>Instead, perform bitwise tests:if (event-&gt;mask &amp; IN_ACCESS)
        printf ("The file was read from!\n");
if (event-&gt;mask &amp; IN_UNMOUNTED)
        printf ("The file's backing device was unmounted!\n);
if (event-&gt;mask &amp; IN_ISDIR)
        printf ("The file is a directory!\n");</p>
<empty-line/>
<p><strong>Linking together move events</strong></p>
<p>The IN_MOVED_FROM and
          IN_MOVED_TO events each represent
          only half of a move: the former represents the removal from a given
          location, while the latter represents the arrival at a new location.
          Therefore, to be truly useful to a program that is attempting to
          intelligently track files as they move around the filesystem
          (consider an indexer with the intention that it not reindex moved
          files), processes need to be able to link the two move events
          together.</p>
<p>Enter the cookie field in
          the inotify_event
          structure.</p>
<p>The cookie field, if
          nonzero, contains a unique value that links two events together.
          Consider a process that is watching <emphasis>/bin</emphasis> and
          <emphasis>/sbin</emphasis>. Assume that <emphasis>/bin</emphasis>
          has a watch descriptor of 7, and that <emphasis>/sbin</emphasis> has
          a watch descriptor of 8. If the file
          <emphasis>/bin/compass</emphasis> is moved to
          <emphasis>/sbin/compass</emphasis>, the kernel will generate two
          inotify events.</p>
<p>The first event will have wd equal to 7, mask
          equal to IN_MOVED_FROM, and a
          name of compass. The second event will have
          wd equal to 8, mask
          equal to IN_MOVED_TO, and a name
          of compass. In both events,
          cookie will be the same—say,
          12.</p>
<p>If a file is renamed, the kernel still generates two events.
          wd is the same for both.</p>
<p>Note that if a file is moved from or to a directory that is
          not watched, the process will not receive one of the corresponding
          events. It is up to the program to notice that the second event with
          a matching cookie never
          arrives.</p>
<empty-line/>
<p><strong>Advanced Watch Options</strong></p>
<p>When creating a new watch, you can add one or more of the
        following values to mask to control
        the behavior of the watch:</p>
<p>IN_DONT_FOLLOW</p>
<p>If this value is set, and if the target of path or any of its components is a
              symbolic link, the link is not followed and inotify_add_watch( ) fails.IN_MASK_ADD</p>
<p>Normally, if you call inotify_add_watch( ) on a file on
              which you have an existing watch, the watch mask is updated to
              reflect the newly provided mask. If this flag is set in mask, the provided events are
              <emphasis>added</emphasis> to the existing mask.IN_ONESHOT</p>
<p>If this value is set, the kernel automatically removes the
              watch after generating the first event against the given object.
              The watch is, in effect, "one shot."IN_ONLYDIR</p>
<p>If this value is set, the watch is added only if the
              object provided is a directory. If path represents a file, not a
              directory, inotify_add_watch(
              ) fails.</p>
<p>For example, this snippet only adds the watch on
        <emphasis>/etc/init.d</emphasis> if <emphasis>init.d</emphasis> is a
        directory, and if neither <emphasis>/etc</emphasis> nor
        <emphasis>/etc/init.d</emphasis> is a symbolic link:int wd;

/*
 * Watch '/etc/init.d' to see if it moves, but only if it is a
 * directory and no part of its path is a symbolic link.
 */
wd = inotify_add_watch (fd,
                        "/etc/init.d",
                        IN_MOVE_SELF |
                        IN_ONLYDIR |
                        IN_DONT_FOLLOW);
if (wd == −1)
        perror ("inotify_add_watch");</p>
<empty-line/>
<p><strong>Removing an inotify Watch</strong></p>
<p>As shown in this instance, you can remove a watch from an
        inotify instance with the system call inotify_rm_watch( ):<strong>#include &lt;inotify.h&gt;

int inotify_rm_watch (int fd, uint32_t wd);</strong></p>
<p>A successful call to inotify_rm_watch(
        ) removes the watch represented by the watch descriptor
        wd from the inotify instance
        (represented by the file descriptor) fd and returns 0.</p>
<p>For example:int ret;

ret = inotify_rm_watch (fd, wd);
if (ret)
        perror ("inotify_rm_watch");</p>
<p>On failure, the system call returns −1, and sets errno to one of the following two
        options:</p>
<p>EBADF</p>
<p>fd is not a valid
              inotify instance.EINVAL</p>
<p>wd is not a valid watch
              descriptor on the given inotify instance.</p>
<p>When removing a watch, the kernel generates the IN_IGNORED event. The kernel sends this
        event not only during a manual removal, but when destroying the watch
        as a side effect of another operation. For example, when a watched
        file is deleted, any watches on the file are removed. In all such
        cases, the kernel sends IN_IGNORED.
        This behavior allows applications to consolidate their handling of
        watch removal in a single place: the event handler for IN_IGNORED. This is useful for advanced
        consumers of inotify that manage complex data structures backing each
        inotify watch, such as GNOME's Beagle search infrastructure.</p>
<empty-line/>
<p><strong>Obtaining the Size of the Event Queue</strong></p>
<p>The size of the pending event queue can be obtained via the
        FIONREAD ioctl on the inotify
        instance's file descriptor. The first argument to the request receives
        the size of the queue in bytes, as an unsigned integer:unsigned int queue_len;
int ret;

ret = ioctl (fd, FIONREAD, &amp;queue_len);
if (ret &lt; 0)
        perror ("ioctl");
else
        printf ("%u bytes pending in queue\n", queue_len);</p>
<p>Note that the request returns the size of the queue in bytes,
        and not the number of events in the queue. A program can estimate the
        number of events from the number of bytes, using the known size of the
        inotify_event structure (obtained
        via sizeof( )), and a guess at the
        average size of the name field.
        What's more useful, however, is that the number of bytes pending gives
        the process an ideal size to read.</p>
<p>The header &lt;sys/ioctl.h&gt; defines the FIONREAD constant.</p>
<empty-line/>
<p><strong>Destroying an inotify Instance</strong></p>
<p>Destroying an inotify instance, and any associated watches, is
        as simple as closing the instance's file descriptor:int ret;

/* 'fd' was obtained via inotify_init(  ) */
ret = close (fd);
if (fd == −1)
        perror ("close");</p>
<p>Of course, as with any file descriptor, the kernel automatically
        closes the file descriptor, and cleans up the resource when the
        process exits.</p>
<empty-line/><empty-line/>
<p><sup>[29] </sup><sup>*</sup> Until the inode runs out of
            space, of course. Then <emphasis>ext3</emphasis> stores extended
            attributes in additional filesystem blocks. Older versions of
            <emphasis>ext3</emphasis> lacked this in-inode extended attribute
            feature.</p>
<p><sup>[30] </sup><sup>*</sup> Note that this limit is 255
          <emphasis>bytes</emphasis>, not 255 <emphasis>characters</emphasis>.
          Multibyte characters obviously consume more than 1 of these 255
          bytes.</p>
<p><sup>[31] </sup><sup>†</sup> Of course, older filesystems that
          Linux provides for backward compatibility, such as FAT, still carry
          their own limitations. In the case of FAT, this limitation is eight
          characters, followed by a dot, followed by three characters. Yes,
          enforcing the dot as a special character inside of the filesystem is
          silly.</p>
<p><sup>[32] </sup><sup>*</sup> Finding files with a link count
          of 0, but whose blocks are marked as allocated is a primary job of
          <emphasis>fsck</emphasis>, the filesystem checker. Such a condition
          can occur when a file is deleted, but remains open, and the system
          crashes before the file is closed. The kernel is never able to mark
          the filesystem blocks as free, and thus the discrepancy arises.
          Journaling filesystems eliminate this type of error.</p>
<p><sup>[33] </sup><sup>*</sup> Although Linux allows you to
            mount a device at multiple points in the directory structure, you
            still cannot rename from one of these mount points to another,
            even though they are backed by the same device.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 8. Memory Management</strong></p>
<p>Memory is among the most basic, but also most essential, resources
    available to a process. This chapter covers the management of this
    resource: the allocation, manipulation, and eventual release of
    memory.</p>
<p>The verb <emphasis>allocate</emphasis>—the common term for obtaining
    memory—is a bit misleading, as it conjures up images of rationing a scarce
    resource for which demand outstrips supply. To be sure, many users would
    love more memory. On modern systems, however, the problem is not really
    one of sharing too little among too many, but of properly using and
    keeping track of the bounty.</p>
<p>In this chapter, you will learn about all of the approaches to
    allocating memory in various regions of a program, including each method's
    advantages and disadvantages. We'll also go over some ways to set and
    manipulate the contents of arbitrary memory regions, and look at how to
    lock memory so it remains in RAM and your program runs no risk of having
    to wait for the kernel to page in data from swap space.</p>
<empty-line/>
<p><strong>The Process Address Space</strong></p>
<p>Linux, like any modern operating system, virtualizes its physical
      resource of memory. Processes do not directly address physical memory.
      Instead, the kernel associates each process with a unique
      <emphasis>virtual address space</emphasis>. This address space is
      linear, with addresses starting at zero, and increasing to some maximum
      value.</p>
<empty-line/>
<p><strong>Pages and Paging</strong></p>
<p>The virtual address space is composed of
        <emphasis>pages</emphasis>. The system architecture and machine type
        determine the size of a page, which is fixed; typical sizes include 4
        KB (for 32-bit systems), and 8 KB (for 64-bit systems).<sup>[34]</sup> Pages are either valid or invalid. A <emphasis>valid
        page</emphasis> is associated with a page in physical memory, or some
        secondary backing storage, such as a swap partition or a file on disk.
        An <emphasis>invalid page</emphasis> is not associated with anything
        and represents an unused, unallocated piece of the address space.
        Accessing such a page causes a segmentation violation. The address
        space is not necessarily contiguous. While linearly addressed, it
        contains plenty of unaddressable gaps.</p>
<p>A program cannot use a page that is present in secondary storage
        rather than in physical memory until it is associated with a page in
        physical memory. When a process tries to access an address on such a
        page, the memory management unit (MMU) generates a <emphasis>page
        fault</emphasis>. The kernel then intervenes, transparently
        <emphasis>paging in</emphasis> the desired page from secondary storage
        to physical memory. Because significantly more virtual than physical
        memory exists (even, on many systems, in a single virtual address
        space!), the kernel is constantly also <emphasis>paging out</emphasis>
        physical memory to secondary storage to make room for more page-ins.
        The kernel attempts to page out data that is the least likely to be
        used in the near future, thereby optimizing performance.</p>
<empty-line/>
<p><strong>Sharing and copy-on-write</strong></p>
<p>Multiple pages of virtual memory, even in different virtual
          address spaces owned by different processes, may map to a single
          physical page. This allows different virtual address spaces to
          <emphasis>share</emphasis> the data in physical memory. The shared
          data may be read-only, or readable and writable.</p>
<p>When a process writes to a shared writable page, one of two
          things can happen. The simplest is that the kernel allows the write
          to occur, in which case all processes sharing the page can see the
          results of the write operation. Usually, allowing multiple processes
          to read from or write to a shared page requires some level of
          coordination and synchronization.</p>
<p>Alternatively, however, the MMU may intercept the write
          operation, and raise an exception; the kernel, in response, will
          transparently create a new copy of the page for the writing process,
          and allow the write to continue against the new page. We call this
          approach <emphasis>copy-on-write</emphasis> (COW).<sup>[35]</sup> Effectively, processes are allowed read access to
          shared data, which saves space. When a process wants to write to a
          shared page, it receives a unique copy of that page on the fly,
          thereby allowing the kernel to act as if the process had always had
          its own private copy. As copy-on-write occurs on a page-by-page
          basis, with this approach, a huge file may be efficiently shared
          among many processes, and the individual processes will receive
          unique physical pages only for those pages to which they themselves
          write.</p>
<empty-line/>
<p><strong>Memory Regions</strong></p>
<p>The kernel arranges pages into blocks that share certain
        properties, such as access permissions. These blocks are called
        <emphasis>memory regions</emphasis>, <emphasis>segments</emphasis>, or
        <emphasis>mappings</emphasis>. Certain types of memory regions can be
        found in every process:</p>
<p>The <emphasis>text segment</emphasis> contains a process'
            program code, string literals, constant variables, and other
            read-only data. In Linux, this segment is marked read-only and is
            mapped in directly from the object file (the program executable or
            a library).</p>
<p>The <emphasis>stack</emphasis> contains the process'
            execution stack, which grows and shrinks dynamically as the stack
            depth increases and decreases. The execution stack contains local
            variables and function return data.</p>
<p>The <emphasis>data segment</emphasis>, or
            <emphasis>heap</emphasis>, contains a process' dynamic memory.
            This segment is writable and can grow or shrink in size. This is
            the memory returned by malloc(
            ) (discussed in the next section).</p>
<p>The <emphasis>bss segment</emphasis><sup>[36]</sup> contains uninitialized global variables. These
            variables contain special values (essentially, all zeros), per the
            C standard.</p>
<p>Linux optimizes these variables in two ways. First, because
            the bss segment is dedicated to uninitialized data, the linker
            (<emphasis>ld</emphasis>) does not actually store the special
            values in the object file. This reduces the binary's size. Second,
            when this segment is loaded into memory, the kernel simply maps it
            on a copy-on-write basis to a page of zeros, efficiently setting
            the variables to their default values.</p>
<p>Most address spaces contain a handful of <emphasis>mapped
            files</emphasis>, such as the program executable itself, the C and
            other linked libraries, and data files. Take a look at
            <emphasis>/proc/self/maps</emphasis>, or the output from the
            <emphasis>pmap</emphasis> program for a great example of the
            mapped files in a process.</p>
<p>This chapter covers the interfaces that Linux provides to obtain
        and return memory, create and destroy new mappings, and everything in
        between.</p>
<empty-line/>
<p><strong>Allocating Dynamic Memory</strong></p>
<p>Memory also comes in the form of automatic and static variables,
      but the foundation of any memory management system is the allocation,
      use, and eventual return of <emphasis>dynamic memory</emphasis>. Dynamic
      memory is allocated at runtime, not compile time, in sizes that may be
      unknown until the moment of allocation. As a developer, you need dynamic
      memory when the amount of memory that you will need, or how long you
      might need it, varies, and is not known before the program runs. For
      example, you might want to store in memory the contents of a file or
      input read in from the keyboard. Because the size of the file is
      unknown, and the user may type any number of keystrokes, the size of the
      buffer will vary, and you may need to make it dynamically larger as you
      read more and more data.</p>
<p>There is no C variable that is backed by dynamic memory. For
      example, C does not provide a mechanism to obtain a struct pirate_ship that exists in dynamic
      memory. Instead, C provides a mechanism for allocating dynamic memory
      sufficient to hold a pirate_ship
      structure. The programmer then interacts with the memory via a
      pointer—in this case, a struct pirate_ship
      *.</p>
<p>The classic C interface for obtaining dynamic memory is malloc( ):<strong>#include &lt;stdlib.h&gt;

void * malloc (size_t size);</strong></p>
<p>A successful call to malloc( )
      allocates size bytes of memory, and
      returns a pointer to the start of the newly allocated region. The
      contents of the memory are undefined; do not expect the memory to be
      zeroed. Upon failure, malloc( )
      returns NULL, and errno is set to ENOMEM.</p>
<p>Usage of malloc( ) may be
      rather straightforward, as in this example used to allocate a fixed
      number of bytes:char *p;

/* give me 2 KB! */
p = malloc (2048);
if (!p)
        perror ("malloc");</p>
<p>or this example used to allocate a structure:struct treasure_map *map;

/*
 * allocate enough memory to hold a treasure_map stucture
 * and point 'map' at it
 */
map = malloc (sizeof (struct treasure_map));
if (!map)
        perror ("malloc");</p>
<p>C automatically promotes pointers to void to any type on assignment. Thus, these
      examples do not need to typecast the return value of malloc( ) to the lvalue's type used in the
      assignments. The C++ programming language, however, does not perform
      automatic void pointer promotion.
      Consequently, users of C++ need to typecast malloc( )'s return as follows:char *name;

/* allocate 512 bytes */
name = (char *) malloc (512);
if (!name)
        perror ("malloc");</p>
<p>Some C programmers like to typecast the result of any function
      that returns a pointer to void,
      malloc( ) included. I argue against
      this practice because it will hide an error if the return value of the
      function ever changes to something other than a void pointer. Moreover, such a typecast also
      hides a bug if a function is not properly declared.<sup>[37]</sup> While the former is not a risk with malloc( ), the latter certainly is.</p>
<p>Because malloc( ) can return
      NULL, it is vitally important that
      developers <emphasis>always</emphasis> check for and handle error
      conditions. Many programs define and use a malloc( ) wrapper that prints an error message
      and terminates the program if malloc(
      ) returns NULL. By
      convention, developers call this common wrapper xmalloc( ):/* like malloc(  ), but terminates on failure */
void * xmalloc (size_t size)
{
        void *p;

        p = malloc (size);
        if (!p) {
                perror ("xmalloc");
                exit (EXIT_FAILURE);
        }

        return p;
}</p>
<empty-line/>
<p><strong>Allocating Arrays</strong></p>
<p>Dynamic memory allocation may also be quite complex when the
        specified size is itself dynamic.
        One such example is the dynamic allocation of arrays, where the size
        of an array element may be fixed, but the number of elements to
        allocate is dynamic. To simplify this scenario, C provides the
        calloc( ) function:<strong>#include &lt;stdlib.h&gt;

void * calloc (size_t nr, size_t size);</strong></p>
<p>A successful call to calloc(
        ) returns a pointer to a block of memory suitable for
        holding an array of nr elements,
        each of size bytes. Consequently,
        the amount of memory requested in these two calls is identical (either
        may end up returning more memory than requested, but never
        less):int *x, *y;

x = malloc (50 * sizeof (int));
if (!x) {
        perror ("malloc");
        return −1;
}

y = calloc (50, sizeof (int));
if (!y) {
        perror ("calloc");
        return −1;
}</p>
<p>The behavior, however, is not identical. Unlike malloc( ), which makes no such guarantees
        about the contents of allocated memory, calloc( ) zeros all bytes in the returned
        chunk of memory. Thus, each of the 50 elements in the array of
        integers y holds the value of
        0, while the contents of the
        elements in x are undefined. Unless
        the program is going to immediately set all 50 values, programmers
        should use calloc( ) to ensure that
        the array elements are not filled with gibberish. Note that binary
        zero might not be the same as floating-point zero!</p>
<p>Users often want to "zero out" dynamic memory, even when not
        dealing with arrays. Later in this chapter, we will consider memset( ), which provides an interface for
        setting every byte in a chunk of memory to a given value. Letting
        calloc( ) perform the zeroing,
        however, is faster because the kernel can provide memory that is
        already zeroed.</p>
<p>On failure, like malloc( ),
        calloc( ) returns NULL, and sets errno to ENOMEM.</p>
<p>Why the standards bodies never defined an "allocate and zero"
        function separate from calloc( ) is
        a mystery. Developers can easily define their own interface,
        however:/* works identically to malloc(  ), but memory is zeroed */
void * malloc0 (size_t size)
{
        return calloc (1, size);
}</p>
<p>Conveniently, we can combine this malloc0( ) with our previous xmalloc( ):/* like malloc(  ), but zeros memory and terminates on failure */
void * xmalloc0 (size_t size)
{
        void *p;

        p = calloc (1, size);
        if (!p) {
                perror ("xmalloc0");
                exit (EXIT_FAILURE);
        }

        return p;
}</p>
<empty-line/>
<p><strong>Resizing Allocations</strong></p>
<p>The C language provides an interface for resizing (making larger
        or smaller) existing allocations:<strong>#include &lt;stdlib.h&gt;

void * realloc (void *ptr, size_t size);</strong></p>
<p>A successful call to realloc(
        ) resizes the region of memory pointed at by ptr to a new size of size bytes. It returns a pointer to the
        newly sized memory, which may or may not be the same as ptr—when enlarging a memory region, if
        realloc( ) is unable to enlarge the
        existing chunk of memory by growing the chunk <emphasis>in
        situ</emphasis>, the function may allocate a new region of memory
        size bytes in length, copy the old
        region into the new one, and free the old region. On any operation,
        the contents of the memory region are preserved up to the minimum of
        the old and the new sizes. Because of the potentiality of a copy
        operation, a realloc( ) operation
        to enlarge a memory region can be a relatively costly act.</p>
<p>If size is 0, the effect is the same as an invocation
        of free( ) on ptr.</p>
<p>If ptr is NULL, the result of the operation is the
        same as a fresh malloc( ). If
        ptr is non-NULL, it must have been returned via a
        previous call to malloc( ),
        calloc( ), or realloc( ).</p>
<p>On failure, realloc( )
        returns NULL, and sets errno to ENOMEM. The state of the memory pointed at
        by ptr is unchanged.</p>
<p>Let's consider an example of shrinking a memory region. First,
        we'll use calloc( ) to allocate
        enough memory to hold a two-element array of map structures:struct map *p;

/* allocate memory for two map structures */
p = calloc (2, sizeof (struct map));
if (!p) {
        perror ("calloc");
        return −1;
}

/* use p[0] and p[1]... */</p>
<p>Now, let's assume we've found one of the treasures, and no
        longer need the second map, so we decide to resize the memory, and
        give half of the region back to the system (this wouldn't generally be
        a worthwhile operation, but it might be if the map structure was very large, and we were
        going to hold the remaining map for a long time):struct map *r;

/* we now need memory for only one map */
r = realloc (p, sizeof (struct map));
if (!r) {
        /* note that 'p' is still valid! */
        perror ("realloc");
        return −1;
}

/* use 'r'... */

free (r);</p>
<p>In this example, p[0] is
        preserved after the realloc( )
        call. Whatever data was there before is still there. If the call
        returned failure, note that p is
        untouched, and thus still valid. We can continue using it, and will
        eventually need to free it. Conversely, if the call succeeded, we
        ignore p, and in lieu use r (which is likely the same as p, as the region was almost certainly
        resized in place). We now have the responsibility to free r when we're done.</p>
<empty-line/>
<p><strong>Freeing Dynamic Memory</strong></p>
<p>Unlike automatic allocations, which are automatically reaped
        when the stack unwinds, dynamic allocations are permanent parts of the
        process' address space until they are manually freed. The programmer
        thus bears the responsibility of returning dynamically allocated
        memory to the system. (Both static and dynamic allocations, of course,
        disappear when the entire process exits.)</p>
<p>Memory allocated with malloc(
        ), calloc( ), or realloc( ) must be returned to the system
        when no longer in use via free(
        ):<strong>#include &lt;stdlib.h&gt;

void free (void *ptr);</strong></p>
<p>A call to free( ) frees the
        memory at ptr. The parameter
        ptr must have been previously
        returned by malloc( ), calloc( ), or realloc( ). That is, you cannot use free( ) to free partial chunks of
        memory—say, half of a chunk of memory—by passing in a pointer halfway
        into an allocated block.</p>
<p>ptr may be NULL, in which case free( ) silently returns. Thus, the oft seen
        practice of checking ptr for
        NULL before calling free( ) is redundant.</p>
<p>Let's look at an example:void print_chars (int n, char c)
{
        int i;

        for (i = 0; i &lt; n; i++) {
                char *s;
                int j;

                /*
                 * Allocate and zero an i+2 element array
                 * of chars. Note that 'sizeof (char)'
                 * is always 1.
                 */
                s = calloc (i + 2, 1);
                if (!s) {
                        perror ("calloc");
                        break;
                }

                for (j = 0; j &lt; i + 1; j++)
                        s[j] = c;

                printf ("%s\n", s);

                /* Okay, all done. Hand back the memory. */
                free (s);
        }
}</p>
<p>This example allocates n
        arrays of chars containing
        successively larger numbers of elements, ranging from two elements (2
        bytes) up to n+ 1 elements
        (n+ 1 bytes). Then, for each array,
        the loop writes the character c
        into each byte except the last (leaving the 0 that is already in the
        last byte), prints the array as a string, and then frees the
        dynamically allocated memory.</p>
<p>Invoking print_chars( ) with
        n equal to 5, and c
        set to X, we get the
        following:X
XX
XXX
XXXX
XXXXX</p>
<p>There are, of course, significantly more efficient ways of
        implementing this function. The point, however, is that we can
        dynamically allocate and free memory even when the size and the number
        of said allocations are known only at runtime.</p>
<p><strong>Tip</strong></p>
<p>Unix systems such as SunOS and SCO provide a variant of
          free( ) named cfree( ), which, depending on the system,
          behaves the same as free( ), or
          receives three parameters, mirroring calloc( ). In Linux, free( ) can handle memory obtained from
          any of the allocation mechanisms we have discussed thus far.
          cfree( ) should never be used,
          except for backward compatibility. The Linux version is the same as
          free( ).</p>
<p>Note what the repercussions would be if this example did not
        invoke free( ). The program would
        never return the memory to the system, and, even worse, it would lose
        its only reference to the memory—the pointer s—thereby making it impossible to ever
        access the memory. We call this type of programming error a
        <emphasis>memory leak</emphasis>. Memory leaks and similar dynamic
        memory mistakes are among the most common, and, unfortunately, the
        most detrimental mishaps in C programming. Because the C language
        places full responsibility for managing memory on the programmer, C
        programmers must keep a fastidious eye on all memory
        allocations.</p>
<p>Another common C programming pitfall is
        <emphasis>use-after-free</emphasis>. This foible occurs when a block
        of memory is freed, and then subsequently accessed. Once free( ) is called on a block of memory, a
        program must never again access its contents. Programmers must be
        particularly careful to watch for <emphasis>dangling
        pointers</emphasis>, or non-NULL
        pointers that nevertheless point at invalid blocks of memory. Two
        common tools to aid you in this quest are <emphasis>Electric
        Fence</emphasis> and <emphasis>valgrind</emphasis>.<sup>[38]</sup></p>
<empty-line/>
<p><strong>Alignment</strong></p>
<p>The <emphasis>alignment</emphasis> of data refers to the
        relation between its address and memory chunks as measured by the
        hardware. A variable located at a memory address that is a multiple of
        its size is said to be <emphasis>naturally aligned</emphasis>. For
        example, a 32-bit variable is naturally aligned if it is located in
        memory at an address that is a multiple of 4—that is, if the address'
        lowest two bits are 0. Thus, a type that is
        2<sup>n</sup> bytes in size must have an address with
        the <emphasis>n</emphasis> least-significant bits set to 0.</p>
<p>Rules pertaining to alignment derive from hardware. Some machine
        architectures have very stringent requirements on the alignment of
        data. On some systems, a load of unaligned data results in a processor
        trap. On other systems, accessing unaligned data is safe, but results
        in a degradation of performance. When writing portable code, alignment
        issues must be avoided, and all types should be naturally
        aligned.</p>
<empty-line/>
<p><strong>Allocating aligned memory</strong></p>
<p>For the most part, the compiler and the C library
          transparently handle alignment concerns. POSIX decrees that the
          memory returned via malloc( ),
          calloc( ), and realloc( ) be properly aligned for use
          with any of the standard C types. On Linux, these functions always
          return memory that is aligned along an 8 byte boundary on 32-bit
          systems and a 16 byte boundary on 64-bit systems.</p>
<p>Occasionally, programmers require dynamic memory aligned along
          a larger boundary, such as a page. While motivations vary, the most
          common is a need to properly align buffers used in direct block I/O
          or other software-to-hardware communication. For this purpose, POSIX
          1003.1d provides a function named posix_memalign( ):<strong>/* one or the other -- either suffices */
#define _XOPEN_SOURCE 600
#define _GNU_SOURCE

#include &lt;stdlib.h&gt;

int posix_memalign (void **memptr,
                    size_t alignment,
                    size_t size);</strong></p>
<p>A successful call to posix_memalign(
          ) allocates size bytes
          of dynamic memory, ensuring it is aligned along a memory address
          that is a multiple of alignment.
          The parameter alignment must be a
          power of 2, and a multiple of the size of a void pointer. The address of the allocated
          memory is placed in memptr, and
          the call returns 0.</p>
<p>On failure, no memory is allocated, memptr is undefined, and the call returns
          one of the following error codes:</p>
<p>EINVAL</p>
<p>The parameter alignment is not a power of 2, or is
                not a multiple of the size of a void pointer.ENOMEM</p>
<p>There is insufficient memory available to satisfy the
                requested allocation.</p>
<p>Note that errno is not
          set—the function directly returns these errors.</p>
<p>Memory obtained via posix_memalign(
          ) is freed via free( ).
          Usage is simple:char *buf;
int ret;

/* allocate 1 KB along a 256-byte boundary */
ret = posix_memalign (&amp;buf, 256, 1024);
if (ret) {
        fprintf (stderr, "posix_memalign: %s\n",
                 strerror (ret));
        return −1;
}

/* use 'buf'... */

free (buf);</p>
<empty-line/>
<p>Older interfaces</p>
<p>Before POSIX defined posix_memalign( ), BSD and SunOS
            provided the following interfaces, respectively:<strong>#include &lt;malloc.h&gt;

void * valloc (size_t size);
void * memalign (size_t boundary, size_t size);</strong></p>
<p>The function valloc( )
            operates identically to malloc(
            ), except that the allocated memory is aligned along a
            page boundary. Recall from Chapter 4 that the system's page size
            is easily obtained via getpagesize(
            ).</p>
<p>The function memalign( )
            is similar, but it aligns the allocation along a boundary of
            boundary bytes, which must be a
            power of 2. In this example, both of these allocations return a
            block of memory sufficient to hold a ship structure, aligned along a page
            boundary:struct ship *pirate, *hms;

pirate = valloc (sizeof (struct ship));
if (!pirate) {
        perror ("valloc");
        return −1;
}

hms = memalign (getpagesize (  ), sizeof (struct ship));
if (!hms) {
        perror ("memalign");
        free (pirate);
        return −1;
}

/* use 'pirate' and 'hms'... */

free (hms);
free (pirate);</p>
<p>On Linux, memory obtained via both of these functions is
            freeable via free( ). This may
            not be the case on other Unix systems, some of which provide no
            mechanism for safely freeing memory allocated with these
            functions. Programs concerned with portability may have no choice
            but to not free memory allocated via these interfaces!</p>
<p>Linux programmers should use these two functions only for
            the purposes of portability with older systems; posix_memalign( ) is superior. All three
            of these interfaces are needed only if an alignment greater than
            that provided by malloc( ) is
            required.</p>
<empty-line/>
<p><strong>Other alignment concerns</strong></p>
<p>Alignment concerns extend beyond natural alignment of the
          standard types and dynamic memory allocations. For example,
          nonstandard and complex types have more complex requirements than
          the standard types. Further, alignment concerns are doubly important
          when assigning values between pointers of varying types and using
          typecasting.</p>
<empty-line/>
<p>Nonstandard types</p>
<p>Nonstandard and complex data types possess alignment
            requirements beyond the simple requirement of natural alignment.
            Four useful rules follow:</p>
<p>The alignment requirement of a structure is that of its
                largest constituent type. For example, if a structure's
                largest type is a 32-bit integer that is aligned along a 4
                byte boundary, the structure must be aligned along at least a
                4 byte boundary as well.</p>
<p>Structures also introduce the need for padding, which is
                used to ensure that each constituent type is properly aligned
                to that type's own requirement. Thus, if a char (with a probable alignment of
                one byte) finds itself followed by an int (with a probable alignment of
                four bytes), the compiler will insert three bytes of padding
                between the two types to ensure that the int lives on a four-byte boundary.
                Programmers sometimes order the members of a structure—for
                example, by descending size—to minimize the space "wasted" by
                padding. The GCC option -Wpadded can aid in this endeavor,
                as it generates a warning whenever the compiler inserts
                implicit padding.</p>
<p>The alignment requirement of a union is that of the
                largest unionized type.</p>
<p>The alignment requirement of an array is that of the
                base type. Thus, arrays carry no requirement beyond a single
                instance of their type. This behavior results in the natural
                alignment of all members of an array.</p>
<empty-line/>
<p>Playing with pointers</p>
<p>As the compiler transparently handles most alignment
            requirements, it takes a bit of effort to expose potential issues.
            It is not unheard of, however, to encounter alignment concerns
            when dealing with pointers and casting.</p>
<p>Accessing data via a pointer recast from a lesser-aligned to
            a larger-aligned block of data can result in the processor loading
            data that is not properly aligned for the larger type. For
            example, in the following code snippet, the assignment of c to badnews attempts to read c as an unsigned long:char greeting[] = "Ahoy Matey";
char *c = greeting[1];
unsigned long badnews = *(unsigned long *) c;</p>
<p>An unsigned long is
            likely aligned along a four or eight byte boundary; c almost certainly sits one byte off
            that same boundary. Consequently, the load of c, when typecast, causes an alignment
            violation. Depending on the architecture, this can cause results
            ranging from as minor as a performance hit to as major as a
            program crash. On machine architectures that can detect but not
            properly handle alignment violations, the kernel sends the
            offending process the SIGBUS
            signal, which terminates the process. We will discuss signals in
            Chapter 9.</p>
<p>Examples such as this are more common than one might think.
            Real-world examples will not be quite so silly in appearance, but
            they will likely be less obvious as well.</p>
<empty-line/>
<p><strong>Managing the Data Segment</strong></p>
<p>Unix systems historically have provided interfaces for directly
      managing the data segment. However, most programs have no direct use for
      these interfaces because malloc( )
      and other allocation schemes are easier to use and more powerful. I'll
      cover these interfaces here to satisfy the curious, and for the rare
      reader who wants to implement her own heap-based allocation
      mechanism:<strong>#include &lt;unistd.h&gt;

int brk (void *end);
void * sbrk (intptr_t increment);</strong></p>
<p>These functions derive their names from old-school Unix systems,
      where the heap and the stack lived in the same segment. Dynamic memory
      allocations in the heap grew upward from the bottom of the segment; the
      stack grew downward toward the heap from the top of the segment. The
      line of demarcation separating the two was called the
      <emphasis>break</emphasis> or the <emphasis>break point</emphasis>. On
      modern systems where the data segment lives in its own memory mapping,
      we continue to label the end address of the mapping the break
      point.</p>
<p>A call to brk( ) sets the break
      point (the end of the data segment) to the address specified by end. On success, it returns 0. On failure, it returns −1, and sets errno to ENOMEM.</p>
<p>A call to sbrk( ) increments
      the end of the data segment by increment, which may be a positive or negative
      delta. sbrk( ) returns the revised
      break point. Thus, an increment of
      0 prints out the current break
      point:printf ("The current break point is %p\n", sbrk (0));</p>
<p>Deliberately, both POSIX and the C standard define neither of
      these functions. Nearly all Unix systems, however, support one or both.
      Portable programs should stick to the standards-based interfaces.</p>
<empty-line/>
<p><strong>Anonymous Memory Mappings</strong></p>
<p>Memory allocation in <emphasis>glibc</emphasis> uses the data
      segment and memory mappings. The classic method of implementing malloc( ) is to divide the data segment into a
      series of power-of-2 partitions, and satisfy allocations by returning
      the partition that is the closest fit to the requested size. Freeing
      memory is as simple marking the partition as "free." If adjacent
      partitions are free, they can be coalesced into a single, larger
      partition. If the top of the heap is entirely free, the system can use
      brk( ) to lower the break point,
      shrinking the heap, and returning memory to the kernel.</p>
<p>This algorithm is called a <emphasis>buddy memory allocation
      scheme</emphasis>. It has the upside of speed and simplicity, but the
      downside of introducing two types of fragmentation. <emphasis>Internal
      fragmentation</emphasis> occurs when more memory than requested is used
      to satisfy an allocation. This results in inefficient use of the
      available memory. <emphasis>External fragmentation</emphasis> occurs
      when sufficient memory is free to satisfy a request, but it is split
      into two or more nonadjacent chunks. This can result in inefficient use
      of memory (because a larger, less suitable block may be used), or failed
      memory allocations (if no alternative block exists).</p>
<p>Moreover, this scheme allows one memory allocation to "pin"
      another, preventing <emphasis>glibc</emphasis> from returning freed
      memory to the kernel. Imagine that two blocks of memory, block
      <emphasis>A</emphasis> and block <emphasis>B</emphasis>, are allocated.
      Block <emphasis>A</emphasis> sits right on the break point, and block
      <emphasis>B</emphasis> sits right below <emphasis>A</emphasis>. Even if
      the program frees <emphasis>B</emphasis>, <emphasis>glibc</emphasis>
      cannot adjust the break point until <emphasis>A</emphasis> is likewise
      freed. In this manner, a long-living allocation can pin all other
      allocations in memory.</p>
<p>This is not always a concern because <emphasis>glibc</emphasis>
      does not routinely return memory to the system anyway.<sup>[39]</sup> Generally, the heap is not shrunk after each free.
      Instead, <emphasis>glibc</emphasis> keeps freed memory around for a
      subsequent allocation. Only when the size of the heap is significantly
      larger than the amount of allocated memory does
      <emphasis>glibc</emphasis> shrink the data segment. A large allocation,
      however, can prevent this shrinkage.</p>
<p>Consequently, for large allocations, <emphasis>glibc</emphasis>
      does not use the heap. Instead, <emphasis>glibc</emphasis> creates an
      <emphasis>anonymous memory mapping</emphasis> to satisfy the allocation
      request. Anonymous memory mappings are similar to the file-based
      mappings discussed in Chapter 4,
      except that they are not backed by any file—hence the "anonymous"
      moniker. Instead, an anonymous memory mapping is simply a large,
      zero-filled block of memory, ready for your use. Think of it as a brand
      new heap, solely for a single allocation. Because these mappings are
      located outside of the heap, they do not contribute to the data
      segment's fragmentation.</p>
<p>Allocating memory via anonymous mappings has several
      benefits:</p>
<p>No fragmentation concerns. When the program no longer needs an
          anonymous memory mapping, the mapping is unmapped, and the memory is
          immediately returned to the system.</p>
<p>Anonymous memory mappings are resizable, have adjustable
          permissions, and can receive advice just like normal mappings (see
          Chapter 4).</p>
<p>Each allocation exists in a separate memory mapping. There is
          no need to manage the global heap.</p>
<p>There are also two downsides to using anonymous memory mappings
      rather than the heap:</p>
<p>Each memory mapping is an integer multiple of the system page
          size in size. Ergo, allocations that are not integer multiples of
          pages in size result in wasted "slack" space. This slack space is
          more of a concern with small allocations, where the wasted space is
          large relative to the allocation size.</p>
<p>Creating a new memory mapping incurs more overhead than
          returning memory from the heap, which may not involve any kernel
          interaction whatsoever. The smaller the allocation, the more valid
          is this observation.</p>
<p>Juggling the pros against the cons, <emphasis>glibc</emphasis>'s
      malloc( ) uses the data segment to
      satisfy small allocations and anonymous memory mappings to satisfy large
      allocations. The threshold is configurable (see the section "Advanced Memory Allocation" later in this chapter), and may
      change from one <emphasis>glibc</emphasis> release to another.
      Currently, the threshold is 128 KB: allocations smaller than or equal to
      128 KB derive from the heap, whereas larger allocations derive from
      anonymous memory mappings.</p>
<empty-line/>
<p><strong>Creating Anonymous Memory Mappings</strong></p>
<p>Perhaps because you want to force the use of a memory mapping
        over the heap for a specific allocation, or perhaps because you are
        writing your own memory allocation system, you may want to manually
        create your own anonymous memory mapping—either way, Linux makes it
        easy. Recall from Chapter 4 that
        the system call mmap( ) creates and
        the system call munmap( ) destroys
        a memory mapping:<strong>#include &lt;sys/mman.h&gt;

void * mmap (void *start,
             size_t length,
             int prot,
             int flags,
             int fd,
             off_t offset);

int munmap (void *start, size_t length);</strong></p>
<p>Creating an anonymous memory mapping is actually easier than
        creating a file-backed mapping, as there is no file to open and
        manage. The primary difference between the two types of mappings is
        the presence of a special flag, signifying that the mapping is
        anonymous.</p>
<p>Let's look at an example:void *p;

p = mmap (NULL,                        /* do not care where */
          512 * 1024,                  /* 512 KB */
          PROT_READ | PROT_WRITE,      /* read/write */
          MAP_ANONYMOUS | MAP_PRIVATE, /* anonymous, private */
          −1,                          /* fd (ignored) */
          0);                          /* offset (ignored) */

if (p == MAP_FAILED)
        perror ("mmap");
else
        /* 'p' points at 512 KB of anonymous memory... */</p>
<p>For most anonymous mappings, the parameters to mmap( ) mirror this example, with the
        exception, of course, of passing in whatever size (in bytes) the
        programmer desires. The other parameters are generally as
        follows:</p>
<p>The first parameter, start, is set to NULL, signifying that the anonymous
            mapping may begin anywhere in memory that the kernel wishes.
            Specifying a non-NULL value
            here is possible, so long as it is page-aligned, but limits
            portability. Rarely does a program care where mappings exist in
            memory!</p>
<p>The prot parameter
            usually sets both the PROT_READ
            and PROT_WRITE bits, making the
            mapping readable and writable. An empty mapping is of no use if
            you cannot read from and write to it. On the other hand, executing
            code from an anonymous mapping is rarely desired, and allowing
            this would create a potential security hole.</p>
<p>The flags parameter sets
            the MAP_ANONYMOUS bit, making
            this mapping anonymous, and the MAP_PRIVATE bit, making this mapping
            private.</p>
<p>The fd and offset parameters are ignored when
            MAP_ANONYMOUS is set. Some
            older systems, however, expect a value of −1 for fd, so it is a good idea to pass that if
            portability is a concern.</p>
<p>Memory obtained via an anonymous mapping looks the same as
        memory obtained via the heap. One benefit to allocating from anonymous
        mappings is that the pages are already filled with zeros. This occurs
        at no cost, because the kernel maps the application's anonymous pages
        to a zero-filled page via copy-on-write. Thus, there is no need to
        memset( ) the returned memory.
        Indeed, this is one benefit to using calloc(
        ) as opposed to malloc( )
        followed by memset( ):
        <emphasis>glibc</emphasis> knows that anonymous mappings are already
        zeroed, and that a calloc( )
        satisfied from a mapping does not require explicit zeroing.</p>
<p>The system call munmap( )
        frees an anonymous mapping, returning the allocated memory to the
        kernel:int ret;

/* all done with 'p', so give back the 512 KB mapping */
ret = munmap (p, 512 * 1024);
if (ret)
        perror ("munmap");</p>
<p><strong>Tip</strong></p>
<p>For a review of mmap( ),
          munmap( ), and mappings in
          general, see Chapter 4.</p>
<empty-line/>
<p><strong>Mapping /dev/zero</strong></p>
<p>Other Unix systems, such as BSD, do not have a MAP_ANONYMOUS flag. Instead, they implement
        a similar solution by mapping a special device file,
        <emphasis>/dev/zero</emphasis>. This device file provides identical
        semantics to anonymous memory. A mapping contains copy-on-write pages
        of all zeros; the behavior is thus the same as with anonymous
        memory.</p>
<p>Linux has always had a <emphasis>/dev/zero</emphasis> device,
        and provided the ability to map this file and obtain zero-filled
        memory. Indeed, before the introduction of MAP_ANONYMOUS, Linux programmers used this
        approach. To provide backward compatibility with older versions of
        Linux, or portability to other Unix systems, developers can still map
        <emphasis>/dev/zero</emphasis> in lieu of creating an anonymous
        mapping. This is no different from mapping any other file:void *p;
int fd;

/* open /dev/zero for reading and writing */
fd = open ("/dev/zero", O_RDWR);
if (fd &lt; 0) {
        perror ("open");
        return −1;
}

/* map [0,page size) of /dev/zero */
p = mmap (NULL,                   /* do not care where */
          getpagesize (  ),         /* map one page */
          PROT_READ | PROT_WRITE, /* map read/write */
          MAP_PRIVATE,            /* private mapping */
          fd,                     /* map /dev/zero */
          0);                     /* no offset */

if (p == MAP_FAILED) {
        perror ("mmap");
        if (close (fd))
                perror ("close");
        return −1;
}

/* close /dev/zero, no longer needed */
if (close (fd))
        perror ("close");

/* 'p' points at one page of memory, use it... */</p>
<p>Memory mapped in this manner is, of course, unmapped using
        munmap( ).</p>
<p>This approach involves the additional system call overhead of
        opening and closing the device file. Thus, anonymous memory is a
        faster solution.</p>
<empty-line/>
<p><strong>Advanced Memory Allocation</strong></p>
<p>Many of the allocation operations discussed in this chapter are
      limited and controlled by kernel parameters that the programmer can
      change. To do so, use the mallopt( )
      call:<strong>#include &lt;malloc.h&gt;

int mallopt (int param, int value);</strong></p>
<p>A call to mallopt( ) sets the
      memory-management-related parameter specified by param to the value specified by value. On success, the call returns a nonzero
      value; on failure, it returns 0. Note
      that mallopt( ) does not set errno. It also tends to always return
      successfully, so avoid any optimism about getting useful information
      from the return value.</p>
<p>Linux currently supports six values for param, all defined in &lt;malloc.h&gt;:</p>
<p>M_CHECK_ACTION</p>
<p>The value of the MALLOC_CHECK_ environment variable
            (discussed in the next section).M_MMAP_MAX</p>
<p>The maximum number of mappings that the system will make to
            satisfy dynamic memory requests. When this limit is reached, the
            data segment will be used for all allocations, until one of these
            mappings is freed. A value of 0
            disables all use of anonymous mappings as a basis for dynamic
            memory allocations.M_MMAP_THRESHOLD</p>
<p>The size threshold (measured in bytes) over which an
            allocation request will be satisfied via an anonymous mapping
            instead of the data segment. Note that allocations smaller than
            this threshold may also be satisfied via anonymous mappings at the
            system's discretion. A value of 0 enables the use of anonymous mappings
            for all allocations, effectively disabling use of the data segment
            for dynamic memory allocations.M_MXFAST</p>
<p>The maximum size (in bytes) of a fast bin. <emphasis>Fast
            bins</emphasis> are special chunks of memory in the heap that are
            never coalesced with adjacent chunks, and never returned to the
            system, allowing for very quick allocations at the cost of
            increased fragmentation. A value of 0 disables all use of fast bins.M_TOP_PAD</p>
<p>The amount of padding (in bytes) used when adjusting the
            size of the data segment. Whenever <emphasis>glibc</emphasis> uses
            brk( ) to increase the size of
            the data segment, it can ask for more memory than needed, in the
            hopes of alleviating the need for an additional brk( ) call in the near future.
            Likewise, whenever <emphasis>glibc</emphasis> shrinks the size of
            the data segment, it can keep extra memory, giving back a little
            less than it would otherwise. These extra bytes are the
            <emphasis>padding</emphasis>. A value of 0 disables all use of padding.M_TRIM_THRESHOLD</p>
<p>The minimum amount of free memory (in bytes) allowed at the
            top of the data segment. If the amount falls below this threshold,
            <emphasis>glibc</emphasis> invokes brk(
            ) to give back memory to the kernel.</p>
<p>The XPG standard, which loosely defines mallopt( ), specifies three other parameters:
      M_GRAIN, M_KEEP, and M_NLBLKS. Linux defines these parameters, but
      setting their value has no effect. See Table 8-1 for a full listing of all
      valid parameters, their default values, and their ranges of accepted
      values.</p>
<p><emphasis>Table 8-1. mallopt( ) parameters</emphasis></p>
<p><strong>Parameter</strong></p>
<p><strong>Origin</strong></p>
<p><strong>Default
              value</strong></p>
<p><strong>Valid
              values</strong></p>
<p><strong>Special
              values</strong></p>
<p>M_CHECK_ACTION</p>
<p>Linux-specific</p>
<p>0</p>
<p>0 – 2 </p>
<p>M_GRAIN</p>
<p>XPG
              standard</p>
<p>Unsupported on
              Linux</p>
<p>&gt;= 0 </p>
<p>M_KEEP</p>
<p>XPG
              standard</p>
<p>Unsupported on
              Linux</p>
<p>&gt;= 0 </p>
<p>M_MMAP_MAX</p>
<p>Linux-specific</p>
<p>64 * 1024</p>
<p>&gt;= 0</p>
<p>0 disables use of mmap( )</p>
<p>M_MMAP_THRESHOLD</p>
<p>Linux-specific</p>
<p>128 * 1024</p>
<p>&gt;= 0</p>
<p>0 disables use of the
              heap</p>
<p>M_MXFAST</p>
<p>XPG
              standard</p>
<p>64</p>
<p>0 - 80</p>
<p>0 disables fast bins</p>
<p>M_NLBLKS</p>
<p>XPG
              standard</p>
<p>Unsupported on
              Linux</p>
<p>&gt;= 0 </p>
<p>M_TOP_PAD</p>
<p>Linux-specific</p>
<p>0</p>
<p>&gt;= 0</p>
<p>0 disables padding</p>
<p>Programs must make any invocations of mallopt( ) before their
      first call to malloc( ) or any other memory allocation interface. Usage
      is simple:int ret;

/* use mmap(  ) for all allocations over 64 KB */
ret = mallopt (M_MMAP_THRESHOLD, 64 * 1024);
if (!ret)
        fprintf (stderr, "mallopt failed!\n");</p>
<empty-line/>
<p><strong>Fine-Tuning with malloc_usable_size( ) and malloc_trim(
        )</strong></p>
<p>Linux provides a couple of functions that offer low-level
        control of <emphasis>glibc</emphasis>'s memory allocation system. The
        first such function allows a program to ask how many usable bytes a
        given memory allocation contains:<strong>#include &lt;malloc.h&gt;

size_t malloc_usable_size (void *ptr);</strong></p>
<p>A successful call to malloc_usable_size( ) returns the actual
        allocation size of the chunk of memory pointed to by ptr. Because <emphasis>glibc</emphasis> may
        round up allocations to fit within an existing chunk or anonymous
        mapping, the usable space in an allocation can be larger than
        requested. Of course, the allocation will never be smaller than
        requested. Here's an example of the function's use:size_t len = 21;
size_t size;
char *buf;

buf = malloc (len);
if (!buf) {
        perror ("malloc");
        return −1;
}

size = malloc_usable_size (buf);

/* we can actually use 'size' bytes of 'buf'... */</p>
<p>The second of the two functions allows a program to force
        <emphasis>glibc</emphasis> to return all immediately freeable memory
        to the kernel:<strong>#include &lt;malloc.h&gt;

int malloc_trim (size_t padding);</strong></p>
<p>A successful call to malloc_trim(
        ) shrinks the data segment as much as possible, minus
        padding bytes, which are reserved.
        It then returns 1. On failure, the
        call returns 0. Normally,
        <emphasis>glibc</emphasis> performs such shrinking automatically,
        whenever the freeable memory reaches M_TRIM_THRESHOLD bytes. It uses a padding of
        M_TOP_PAD.</p>
<p>You'll almost never want to use these two functions for anything
        other than debugging or educational purposes. They are not portable,
        and expose low-level details of <emphasis>glibc</emphasis>'s memory
        allocation system to your program.</p>
<empty-line/>
<p><strong>Debugging Memory Allocations</strong></p>
<p>Programs can set the environment variable MALLOC_CHECK_ to enable enhanced debugging in
      the memory subsystem. The additional debugging checks come at the
      expense of less efficient memory allocations, but the overhead is often
      worth it during the debugging stage of application
      development.</p>
<p>Because an environment variable controls the debugging, there is
      no need to recompile your program. For example, you can simply issue a
      command like the following:$ MALLOC_CHECK_=1 ./rudder</p>
<p>If MALLOC_CHECK_ is set to
      0, the memory subsystem silently
      ignores any errors. If it is set to 1, an informative message is printed to
      stderr. If it is set to 2, the program is immediately terminated via
      abort( ). Because MALLOC_CHECK_ changes the behavior of the
      running program, setuid programs ignore this variable.</p>
<empty-line/>
<p><strong>Obtaining Statistics</strong></p>
<p>Linux provides the mallinfo(
        ) function for obtaining statistics related to the memory
        allocation system:<strong>#include &lt;malloc.h&gt;

struct mallinfo mallinfo (void);</strong></p>
<p>A call to mallinfo( ) returns
        statistics in a mallinfo structure.
        The structure is returned by value, not via a pointer. Its contents
        are also defined in &lt;malloc.h&gt;:<strong>/* all sizes in bytes */
struct mallinfo {
        int arena;    /* size of data segment used by malloc */
        int ordblks;  /* number of free chunks */
        int smblks;   /* number of fast bins */
        int hblks;    /* number of anonymous mappings */
        int hblkhd;   /* size of anonymous mappings */
        int usmblks;  /* maximum total allocated size */
        int fsmblks;  /* size of available fast bins */
        int uordblks; /* size of total allocated space */
        int fordblks; /* size of available chunks */
        int keepcost; /* size of trimmable space */
};</strong></p>
<p>Usage is simple:struct mallinfo m;

m = mallinfo (  );

printf ("free chunks: %d\n", m.ordblks);</p>
<p>Linux also provides the malloc_stats(
        ) function, which prints memory-related statistics to
        stderr:<strong>#include &lt;malloc.h&gt;

void malloc_stats (void);</strong></p>
<p>Invoking malloc_stats( ) in a
        memory-intensive program yields some big numbers:Arena 0:
system bytes     =  865939456
in use bytes     =  851988200
Total (incl. mmap):
system bytes     = 3216519168
in use bytes     = 3202567912
max mmap regions =      65536
max mmap bytes   = 2350579712</p>
<empty-line/>
<p><strong>Stack-Based Allocations</strong></p>
<p>Thus far, all of the mechanisms for dynamic memory allocation that
      we have studied have used the heap or memory mappings to obtain dynamic
      memory. We should expect this because the heap and memory mappings are
      decidedly dynamic in nature. The other common construct in a program's
      address space, the stack, is where a program's <emphasis>automatic
      variables</emphasis> live.</p>
<p>There is no reason, however, that a programmer cannot use the
      stack for dynamic memory allocations. So long as the allocation does not
      overflow the stack, such an approach should be easy, and should perform
      quite well. To make a dynamic memory allocation from the stack, use the
      alloca( ) system call:<strong>#include &lt;alloca.h&gt;

void * alloca (size_t size);</strong></p>
<p>On success, a call to alloca( )
      returns a pointer to size bytes of
      memory. This memory lives on the stack, and is automatically freed when
      the invoking function returns. Some implementations return NULL on failure, but most alloca( ) implementations cannot fail, or are
      unable to report failure. Failure is manifested as a stack
      overflow.</p>
<p>Usage is identical to malloc(
      ), but you do not need to (indeed, must not) free the
      allocated memory. Here is an example of a function that opens a given
      file in the system's configuration directory, which is probably
      <emphasis>/etc</emphasis>, but is portably determined at compile time.
      The function has to allocate a new buffer, copy the system configuration
      directory into the buffer, and then concatenate this buffer with the
      provided filename:int open_sysconf (const char *file, int flags, int mode)
{
        const char *etc; = SYSCONF_DIR; /* "/etc/" */
        char *name;

        name = alloca (strlen (etc) + strlen (file) + 1);
        strcpy (name, etc);
        strcat (name, file);

        return open (name, flags, mode);
}</p>
<p>Upon return, the memory allocated with alloca( ) is automatically freed as the stack
      unwinds back to the invoking function. This means you cannot use this
      memory once the function that calls alloca(
      ) returns! However, because you don't have to do any cleanup
      by calling free( ), the resulting
      code is a bit cleaner. Here is the same function implemented using
      malloc( ):int open_sysconf (const char *file, int flags, int mode)
{
        const char *etc = SYSCONF_DIR; /* "/etc/" */
        char *name;
        int fd;

        name = malloc (strlen (etc) + strlen (file) + 1);
        if (!name) {
                perror ("malloc");
                return −1;
        }

        strcpy (name, etc);
        strcat (name, file);
        fd = open (name, flags, mode);
        free (name);

        return fd;
}</p>
<p>Note that you should not use alloca(
      )-allocated memory in the parameters to a function call,
      because the allocated memory will then exist in the middle of the stack
      space reserved for the function parameters. For example, the following
      is off-limits:/* DO NOT DO THIS! */
ret = foo (x, alloca (10));</p>
<p>The alloca( ) interface has a
      checkered history. On many systems, it behaved poorly, or gave way to
      undefined behavior. On systems with a small and fixed-sized stack, using
      alloca( ) was an easy way to overflow
      the stack, and kill your program. On still other systems, alloca( ) did not even exist. Over time, the
      buggy and inconsistent implementations earned alloca( ) a bad reputation.</p>
<p>So, if your program must remain portable, you should avoid
      alloca( ). On Linux, however,
      alloca( ) is a wonderfully useful and
      underutilized tool. It performs exceptionally well—on many
      architectures, an allocation via alloca(
      ) does as little as increment the stack pointer—and handily
      outperforms malloc( ). For small
      allocations in Linux-specific code, alloca(
      ) can yield excellent performance gains.</p>
<empty-line/>
<p><strong>Duplicating Strings on the Stack</strong></p>
<p>A very common use of alloca(
        ) is to temporarily duplicate a string. For
        example:/* we want to duplicate 'song' */
char *dup;

dup = alloca (strlen (song) + 1);
strcpy (dup, song);

/* manipulate 'dup'... */

return; /* 'dup' is automatically freed */</p>
<p>Because of the frequency of this need, and the speed benefit
        that alloca( ) offers, Linux
        systems provide variants of strdup(
        ) that duplicate the given string onto the stack:<strong>#define _GNU_SOURCE
#include &lt;string.h&gt;

char * strdupa (const char *s);
char * strndupa (const char *s, size_t n);</strong></p>
<p>A call to strdupa( ) returns
        a duplicate of s. A call to
        strndupa( ) duplicates up to
        n characters of s. If s
        is longer than n, the duplication
        stops at n, and the function
        appends a null byte. These functions offer the same benefits as
        alloca( ). The duplicated string is
        automatically freed when the invoking function returns.</p>
<p>POSIX does not define the alloca(
        ), strdupa( ), or
        strndupa( ) functions, and their
        record on other operating systems is spotty. If portability is a
        concern, use of these functions is highly discouraged. On Linux,
        however, alloca( ) and friends
        perform quite well, and can provide an excellent performance boost,
        replacing the complicated dance of dynamic memory allocation with a
        mere adjustment of the stack frame pointer.</p>
<empty-line/>
<p><strong>Variable-Length Arrays</strong></p>
<p>C99 introduced <emphasis>variable-length arrays</emphasis>
        (VLAs), which are arrays whose geometry is set at runtime, and not at
        compile time. GNU C has supported variable-length arrays for some
        time, but now that C99 has standardized them, there is greater
        incentive for their use. VLAs avoid the overhead of dynamic memory
        allocation in much the same way as alloca(
        ).</p>
<p>Their use is exactly what you would expect:for (i = 0; i &lt; n; ++i) {
        char foo[i + 1];

        /* use 'foo'... */
}</p>
<p>In this snippet, foo is an
        array of chars of variable size
        i + 1. On each iteration of the
        loop, foo is dynamically created
        and automatically cleaned up when it falls out of scope. If we used
        alloca( ) instead of a VLA, the
        memory would not be freed until the function returned. Using a VLA
        ensures that the memory is freed on every iteration of the loop. Thus,
        using a VLA consumes at worst n
        bytes, whereas alloca( ) would
        consume n*(n+1)/2 bytes.</p>
<p>Using a variable-length array, we can rewrite our open_sysconf( ) function as follows:int open_sysconf (const char *file, int flags, int mode)
{
        const char *etc; = SYSCONF_DIR; /* "/etc/" */
        char name[strlen (etc) + strlen (file) + 1];

        strcpy (name, etc);
        strcat (name, file);

        return open (name, flags, mode);
}</p>
<p>The main difference between alloca(
        ) and variable-length arrays is that memory obtained via the
        former exists for the duration of the function, whereas memory
        obtained via the latter exists until the holding variable falls out of
        scope, which can be before the current function returns. This could be
        welcome or unwelcome. In the for
        loop we just looked at, reclaiming the memory on each loop iteration
        reduces net memory consumption without any side effect (we did not
        need the extra memory hanging around). However, if for some reason we
        wanted the memory to persist longer than a single loop iteration,
        using alloca( ) would make more
        sense.</p>
<p><strong>Tip</strong></p>
<p>Mixing alloca( ) and
          variable-length arrays in a single function can invite peculiar
          behavior. Play it safe and use one or the other in a given
          function.</p>
<empty-line/>
<p><strong>Choosing a Memory Allocation Mechanism</strong></p>
<p>The myriad memory allocation options discussed in this chapter may
      leave programmers wondering exactly what solution is best for a given
      job. In the majority of situations, malloc(
      ) is your best bet. Sometimes, however, a different approach
      provides a better tool. Table 8-2 summarizes guidelines
      for choosing an allocation mechanism.</p>
<p><emphasis>Table 8-2. Approaches to memory allocation in Linux</emphasis></p>
<p><strong>Allocation
              approach</strong></p>
<p><strong>Pros</strong></p>
<p><strong>Cons</strong></p>
<p>malloc( )</p>
<p>Easy, simple,
              common.</p>
<p>Returned memory not
              necessarily zeroed.</p>
<p>calloc( )</p>
<p>Makes allocating arrays
              simple, zeros returned memory.</p>
<p>Convoluted interface if
              not allocating arrays.</p>
<p>realloc( )</p>
<p>Resizes existing
              allocations.</p>
<p>Useful only for resizing
              existing allocations.</p>
<p>brk( ) and sbrk( )</p>
<p>Allows intimate control
              of the heap.</p>
<p>Much too low-level for
              most users.</p>
<p>Anonymous memory
              mappings</p>
<p>Easy to work with,
              sharable, allow developer to adjust protection level and provide
              advice; optimal for large mappings.</p>
<p>Suboptimal for small
              allocations; malloc( )
              automatically uses anonymous memory mappings when
              optimal.</p>
<p>posix_memalign( )</p>
<p>Allocates memory aligned
              to any reasonable boundary.</p>
<p>Relatively new and thus
              portability is questionable; overkill unless alignment concerns
              are pressing.</p>
<p>memalign( ) and valloc( )</p>
<p>More common on other Unix
              systems than posix_memalign(
              ).</p>
<p>Not a POSIX standard,
              offers less alignment control than posix_memalign( ).</p>
<p>alloca( )</p>
<p>Very fast allocation, no
              need to explicitly free memory; great for small
              allocations.</p>
<p>Unable to return error,
              no good for large allocations, broken on some Unix
              systems.</p>
<p>Variable-length
              arrays</p>
<p>Same as alloca( ), but frees memory when array
              falls out of scope, not when function returns.</p>
<p>Useful only for arrays;
              alloca( ) freeing behavior
              may be preferable in some situations; less common on other Unix
              systems than alloca(
              ).</p>
<p>Finally, let us not forget the alternative to all of these
      options: automatic and static memory allocations. Allocating automatic
      variables on the stack, or global variables on the heap, is often
      easier, and does not require that the programmer manage pointers and
      worry about freeing the memory.</p>
<empty-line/>
<p><strong>Manipulating Memory</strong></p>
<p>The C language provides a family of functions for manipulating raw
      bytes of memory. These functions operate in many ways similarly to
      string-manipulation interfaces such as strcmp(
      ) and strcpy( ), but they
      rely on a user-provided buffer size instead of the assumption that
      strings are null-terminated. Note that none of these functions can
      return errors. Preventing errors is up to the programmer—pass in the
      wrong memory region, and there is no alternative, except the resulting
      segmentation violation!</p>
<empty-line/>
<p><strong>Setting Bytes</strong></p>
<p>Among the collection of memory-manipulating functions, the most
        common is easily memset( ):<strong>#include &lt;string.h&gt;

void * memset (void *s, int c, size_t n);</strong></p>
<p>A call to memset( ) sets the
        n bytes starting at s to the byte c and returns s. A frequent use is zeroing a block of
        memory:/* zero out [s,s+256) */
memset (s, '\0', 256);</p>
<p>bzero( ) is an older,
        deprecated interface introduced by BSD for performing the same task.
        New code should use memset( ), but
        Linux provides bzero( ) for
        backward compatibility and portability with other systems:<strong>#include &lt;strings.h&gt;

void bzero (void *s, size_t n);</strong></p>
<p>The following invocation is identical to the preceding memset( ) example:bzero (s, 256);</p>
<p>Note that bzero( )—along with
        the other b interfaces—requires the
        header &lt;strings.h&gt; and not
        &lt;string.h&gt;.</p>
<p><strong>Tip</strong></p>
<p>Do not use memset( ) if you
          can use calloc( )! Avoid
          allocating memory with malloc( ),
          and then immediately zeroing it with memset( ). While the result may be the
          same, dropping the two functions for a single calloc( ), which returns zeroed memory, is
          much better. Not only will you make one less function call, but
          calloc( ) may be able to obtain
          already zeroed memory from the kernel. In that case, you avoid
          manually setting each byte to 0, and improve performance.</p>
<empty-line/>
<p><strong>Comparing Bytes</strong></p>
<p>Similar to strcmp( ),
        memcmp( ) compares two chunks of
        memory for equivalence:<strong>#include &lt;string.h&gt;

int memcmp (const void *s1, const void *s2, size_t n);</strong></p>
<p>An invocation compares the first n bytes of s1 to s2,
        and returns 0 if the blocks of
        memory are equivalent, a value less than zero if s1 is less than s2, and a value greater than zero if s1 is greater than s2.</p>
<p>BSD again provides a now-deprecated interface that performs
        largely the same task:<strong>#include &lt;strings.h&gt;

int bcmp (const void *s1, const void *s2, size_t n);</strong></p>
<p>An invocation of bcmp( )
        compares the first n bytes of
        s1 to s2, returning 0 if the blocks of memory are equivalent,
        and a nonzero value if they are different.</p>
<p>Because of structure padding (see "Other alignment concerns" earlier in this chapter),
        comparing two structures for equivalence via memcmp( ) or bcmp(
        ) is unreliable. There can be uninitialized garbage in the
        padding that differs between two otherwise identical instances of a
        structure. Consequently, code such as the following is not
        safe:/* are two dinghies identical? (BROKEN) */
int compare_dinghies (struct dinghy *a, struct dinghy *b)
{
        return memcmp (a, b, sizeof (struct dinghy));
}</p>
<p>Instead, programmers who wish to compare structures should
        compare each element of the structures, one by one. This approach
        allows for some optimization, but it's definitely more work than the
        unsafe memcmp( ) approach. Here's
        the equivalent code:/* are two dinghies identical? */
int compare_dinghies (struct dinghy *a, struct dinghy *b)
{
        int ret;

        if (a-&gt;nr_oars &lt; b-&gt;nr_oars)
                return −1;
        if (a-&gt;nr_oars &gt; b-&gt;nr_oars)
                return 1;

        ret = strcmp (a-&gt;boat_name, b-&gt;boat_name);
        if (ret)
                return ret;

        /* and so on, for each member... */
}</p>
<empty-line/>
<p><strong>Moving Bytes</strong></p>
<p>memmove( ) copies the first
        n bytes of src to dst, returning dst:<strong>#include &lt;string.h&gt;

void * memmove (void *dst, const void *src, size_t n);</strong></p>
<p>Again, BSD provides a deprecated interface for performing the
        same task:<strong>#include &lt;strings.h&gt;

void bcopy (const void *src, void *dst, size_t n);</strong></p>
<p>Note that although both functions take the same parameters, the
        order of the first two is reversed in bcopy(
        ).</p>
<p>Both bcopy( ) and memmove( ) can safely handle overlapping
        memory regions (say, if part of dst
        is inside of src). This allows
        bytes of memory to shift up or down within a given region, for
        example. As this situation is rare, and a programmer would know if it
        were the case, the C standard defines a variant of memmove( ) that does not support overlapping
        memory regions. This variant is potentially faster:<strong>#include &lt;string.h&gt;

void * memcpy (void *dst, const void *src, size_t n);</strong></p>
<p>This function behaves identically to memmove( ), except dst and src may not overlap. If they do, the results
        are undefined.</p>
<p>Another safe copying function is memccpy( ):<strong>#include &lt;string.h&gt;

void * memccpy (void *dst, const void *src, int c, size_t n);</strong></p>
<p>The memccpy( ) function
        behaves the same as memcpy( ),
        except that it stops copying if the function finds the byte c within the first n bytes of src. The call returns a pointer to the next
        byte in dst after c, or NULL if c
        was not found.</p>
<p>Finally, you can use mempcpy(
        ) to step through memory:<strong>#define _GNU_SOURCE
#include &lt;string.h&gt;

void * mempcpy (void *dst, const void *src, size_t n);</strong></p>
<p>The mempcpy( ) function
        performs the same as memcpy( ),
        except that it returns a pointer to the next byte after the last byte
        copied. This is useful if a set of data is to be copied to consecutive
        memory locations—but it's not so much of an improvement because the
        return value is merely dst + n.
        This function is GNU-specific.</p>
<empty-line/>
<p><strong>Searching Bytes</strong></p>
<p>The functions memchr( ) and
        memrchr( ) locate a given byte in a
        block of memory:<strong>#include &lt;string.h&gt;

void * memchr (const void *s, int c, size_t n);</strong></p>
<p>The memchr( ) function scans
        the n bytes of memory pointed at by
        s for the character c, which is interpreted as an unsigned char:<strong>#define _GNU_SOURCE
#include &lt;string.h&gt;

void * memrchr (const void *s, int c, size_t n);</strong></p>
<p>The call returns a pointer to the first byte to match c, or NULL if c
        is not found.</p>
<p>The memrchr( ) function is
        the same as the memchr( ) function,
        except that it searches backward from the end of the n bytes pointed at by s instead of forward from the front. Unlike
        memchr( ), memrchr( ) is a GNU extension, and not part
        of the C language.</p>
<p>For more complicated search missions, the awfully named function
        memmem( ) searches a block of
        memory for an arbitrary array of bytes:<strong>#define _GNU_SOURCE
#include &lt;string.h&gt;

void * memmem (const void *haystack,
               size_t haystacklen,
               const void *needle,
               size_t needlelen);</strong></p>
<p>The memmem( ) function
        returns a pointer to the first occurrence of the subblock needle, of length needlelen bytes, within the block of memory
        haystack, of length haystacklen bytes. If the function does not
        find needle in haystack, it returns NULL. This function is also a GNU
        extension.</p>
<empty-line/>
<p><strong>Frobnicating Bytes</strong></p>
<p>The Linux C library provides an interface for trivially
        convoluting bytes of data:<strong>#define _GNU_SOURCE
#include &lt;string.h&gt;

void * memfrob (void *s, size_t n);</strong></p>
<p>A call to memfrob( ) obscures
        the first n bytes of memory
        starting at s by exclusive-ORing
        (XORing) each byte with the number 42. The call returns s.</p>
<p>The effect of a call to memfrob(
        ) can be reversed by calling memfrob( ) again on the same region of
        memory. Thus, the following snippet is a no-op with respect to
        secret:memfrob (memfrob (secret, len), len);</p>
<p>This function is in no way a proper (or even a poor) substitute
        for encryption; its use is limited to the trivial obfuscation of
        strings. It is GNU-specific.</p>
<empty-line/>
<p><strong>Locking Memory</strong></p>
<p>Linux implements <emphasis>demand paging</emphasis>, which means
      that pages are swapped in from disk as needed, and swapped out to disk
      when no longer needed. This allows the virtual address spaces of
      processes on the system to have no direct relationship to the total
      amount of physical memory, as the on-disk swap space can provide the
      illusion of a nearly infinite supply of physical memory.</p>
<p>This swapping occurs transparently, and applications generally
      need not be concerned with (or even know about) the Linux kernel's
      paging behavior. There are, however, two situations in which
      applications may wish to influence the system's paging behavior:</p>
<p><emphasis>Determinism</emphasis></p>
<p>Applications with timing constraints require deterministic
            behavior. If some memory accesses result in page faults—which
            incur costly disk I/O operations—applications can overrun their
            timing needs. By ensuring that the pages it needs are always in
            physical memory, and never paged to disk, an application can
            guarantee that memory accesses will not result in page faults,
            providing consistency, determinism, and improved
            performance.<emphasis>Security</emphasis></p>
<p>If private secrets are kept in memory, the secrets can end
            up being paged out and stored unencrypted on disk. For example, if
            a user's private key is normally stored encrypted on disk, an
            unencrypted copy of the key in memory can end up in the swap file.
            In a high-security environment, this behavior may be unacceptable.
            Applications for which this might be a problem can ask that the
            memory containing the key always remain in physical memory.</p>
<p>Of course, changing the kernel's behavior can result in a negative
      impact on overall system performance. One application's determinism or
      security may improve, but while its pages are locked into memory,
      another application's pages will be paged out instead. The kernel, if we
      trust its design, always chooses the optimal page to swap out—that is,
      the page least likely to be used in the future—so when you change its
      behavior, it has to swap out a suboptimal page.</p>
<empty-line/>
<p><strong>Locking Part of an Address Space</strong></p>
<p>POSIX 1003.1b-1993 defines two interfaces for "locking" one or
        more pages into physical memory, ensuring that they are never paged
        out to disk. The first locks a given interval of addresses:<strong>#include &lt;sys/mman.h&gt;

int mlock (const void *addr, size_t len);</strong></p>
<p>A call to mlock( ) locks the
        virtual memory starting at addr,
        and extending for len bytes into
        physical memory. On success, the call returns 0; on failure, the call returns −1, and sets errno as appropriate.</p>
<p>A successful call locks all physical pages that contain [addr,addr+len) in memory. For example, if a
        call specifies only a single byte, the entire page in which that byte
        resides is locked into memory. The POSIX standard dictates that
        addr should be aligned to a page
        boundary. Linux does not enforce this requirement, silently rounding
        addr down to the nearest page if
        needed. Programs requiring portability to other systems, however,
        should ensure that addr sits on a
        page boundary.</p>
<p>The valid errno codes
        include:</p>
<p>EINVAL</p>
<p>The parameter len is
              negative.ENOMEM</p>
<p>The caller attempted to lock more pages than the RLIMIT_MEMLOCK resource limit allows
              (see the later section "Locking Limits").EPERM</p>
<p>The RLIMIT_MEMLOCK
              resource limit was 0, but the
              process did not possess the CAP_IPC_LOCK capability (again, see
              "Locking Limits").</p>
<p><strong>Tip</strong></p>
<p>A child process does not inherit locked memory across a
          fork( ). Due to the copy-on-write
          behavior of address spaces in Linux, however, a child process' pages
          are effectively locked in memory until the child writes to
          them.</p>
<p>As an example, assume that a program holds a decrypted string in
        memory. A process can lock the page containing the string with code
        such as the following:int ret;

/* lock 'secret' in memory */
ret = mlock (secret, strlen (secret));
if (ret)
        perror ("mlock");</p>
<empty-line/>
<p><strong>Locking All of an Address Space</strong></p>
<p>If a process wants to lock its entire address space into
        physical memory, mlock( ) is a
        cumbersome interface. For such a purpose—common to real-time
        applications—POSIX defines a system call that locks an entire address
        space:<strong>#include &lt;sys/mman.h&gt;

int mlockall (int flags);</strong></p>
<p>A call to mlockall( ) locks
        all of the pages in the current process' address space into physical
        memory. The flags parameter, which
        is a bitwise OR of the following two values, controls the
        behavior:</p>
<p>MCL_CURRENT</p>
<p>If set, this value instructs mlockall( ) to lock all currently
              mapped pages—the stack, data segment, mapped files, and so
              on—into the process' address space.MCL_FUTURE</p>
<p>If set, this value instructs mlockall( ) to ensure that all pages
              mapped into the address space in the future are also locked into
              memory.</p>
<p>Most applications specify a bitwise OR of both values.</p>
<p>On success, the call returns 0; on failure, it returns −1, and sets errno to one of the following error
        codes:</p>
<p>EINVAL</p>
<p>The parameter flags is
              negative.ENOMEM</p>
<p>The caller attempted to lock more pages than the RLIMIT_MEMLOCK resource limit allows
              (see the later section "Locking Limits").EPERM</p>
<p>The RLIMIT_MEMLOCK
              resource limit was 0, but the
              process did not possess the CAP_IPC_LOCK capability (again, see
              "Locking Limits").</p>
<empty-line/>
<p><strong>Unlocking Memory</strong></p>
<p>To unlock pages from physical memory, again allowing the kernel
        to swap the pages out to disk as needed, POSIX standardizes two more
        interfaces:<strong>#include &lt;sys/mman.h&gt;

int munlock (const void *addr, size_t len);
int munlockall (void);</strong></p>
<p>The system call munlock( )
        unlocks the pages starting at addr
        and extending for len bytes. It
        undoes the effects of mlock( ). The
        system call munlockall( ) undoes
        the effects of mlockall( ). Both
        calls return 0 on success, and on
        error return −1, and set errno to one of the following:</p>
<p>EINVAL</p>
<p>The parameter len is
              invalid (munlock( )
              only).ENOMEM</p>
<p>Some of the specified pages are invalid.EPERM</p>
<p>The RLIMIT_MEMLOCK
              resource limit was 0, but the
              process did not possess the CAP_IPC_LOCK capability (see the next
              section, "Locking Limits").</p>
<p>Memory locks do not nest. Therefore, a single mlock( ) or munlock( ) will unlock a locked page,
        regardless of how many times the page was locked via mlock( ) or mlockall( ).</p>
<empty-line/>
<p><strong>Locking Limits</strong></p>
<p>Because locking memory can affect the overall performance of the
        system—indeed, if too many pages are locked, memory allocations can
        fail—Linux places limits on how many pages a process may
        lock.</p>
<p>Processes possessing the CAP_IPC_LOCK capability may lock any number
        of pages into memory. Processes without this capability may lock only
        RLIMIT_MEMLOCK bytes. By default,
        this resource limit is 32 KB—large enough to lock a secret or two in
        memory, but not large enough to adversely affect system performance.
        (Chapter 6 discusses resource
        limits, and how to retrieve and change this value.)</p>
<empty-line/>
<p><strong>Is a Page in Physical Memory?</strong></p>
<p>For debugging and diagnostic purposes, Linux provides the
        mincore( ) function, which can be
        used to determine whether a given range of memory is in physical
        memory, or swapped out to disk:<strong>#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

int mincore (void *start,
             size_t length,
             unsigned char *vec);</strong></p>
<p>A call to mincore( ) provides
        a vector delineating which pages of a mapping are in physical memory
        at the time of the system call. The call returns the vector via
        vec, and describes the pages
        starting at start (which must be
        page-aligned) and extending for length bytes (which need not be
        page-aligned). Each byte in vec
        corresponds to one page in the range provided, starting with the first
        byte describing the first page, and moving linearly forward.
        Consequently, vec must be at least
        large enough to contain (length − 1
        + <emphasis>page</emphasis>
        <emphasis>size</emphasis>) /
        <emphasis>page</emphasis> <emphasis>size</emphasis> bytes.
        The lowest-order bit in each byte is 1 if the page is resident in
        physical memory, and 0 if it is not. The other bits are currently
        undefined and reserved for future use.</p>
<p>On success, the call returns 0. On failure, it returns −1, and sets errno to one of the following:</p>
<p>EAGAIN</p>
<p>Insufficient kernel resources are available to carry out
              the request.EFAULT</p>
<p>The parameter vec
              points at an invalid address.EINVAL</p>
<p>The parameter start is
              not aligned to a page boundary.ENOMEM</p>
<p>[address,address+1)
              contains memory that is not part of a file-based mapping.</p>
<p>Currently, this system call works properly only for file-based
        mappings created with MAP_SHARED.
        This greatly limits the call's use.</p>
<empty-line/>
<p><strong>Opportunistic Allocation</strong></p>
<p>Linux employs an <emphasis>opportunistic allocation</emphasis>
      strategy. When a process requests additional memory from the kernel—say,
      by enlarging its data segment, or by creating a new memory mapping—the
      kernel <emphasis>commits</emphasis> to the memory without actually
      providing any physical storage. Only when the process writes to the
      newly allocated memory does the kernel <emphasis>satisfy</emphasis> the
      commitment by converting the commitment for memory to a physical
      allocation of memory. The kernel does this on a page-by-page basis,
      performing demand paging and copy-on-writes as needed.</p>
<p>This behavior has several advantages. First, lazily allocating
      memory allows the kernel to defer most of the work until the last
      possible moment—if indeed it ever has to satisfy the allocations.
      Second, because the requests are satisfied page-by-page and on demand,
      only physical memory in actual use need consume physical storage.
      Finally, the amount of committed memory can far exceed the amount of
      physical memory and even swap space available. This last feature is
      called <emphasis>overcommitment</emphasis>.</p>
<empty-line/>
<p><strong>Overcommitting and OOM</strong></p>
<p>Overcommitting allows systems to run many more, and much larger,
        applications than they could if every requested page of memory had to
        be backed by physical storage at the point of allocation instead of
        the point of use. Without overcommitment, mapping a 2 GB file
        copy-on-write would require the kernel to set aside 2 GB of storage.
        With overcommitment, mapping a 2 GB file requires storage only for
        each page of data to which the process actually writes. Likewise,
        without overcommitment, every fork(
        ) would require enough free storage to duplicate the address
        space, even though the vast majority of pages never undergo
        copy-on-writes.</p>
<p>What if, however, processes attempt to satisfy more outstanding
        commitments than the system has physical memory and swap space? In
        that case, one or more of the satisfactions must fail. Because the
        kernel has already committed to the memory—the system call requesting
        the commitment returned success—and a process is attempting to use
        that committed memory, the kernel's only recourse is to kill a
        process, freeing up available memory.</p>
<p>When overcommitment results in insufficient memory to satisfy a
        committed request, we say that an <emphasis>out of memory</emphasis>
        (OOM) condition has occurred. In response to an OOM condition, the
        kernel employs the <emphasis>OOM killer</emphasis> to pick a process
        "worthy" of termination. For this purpose, the kernel tries to find
        the least important process that is consuming the most memory.</p>
<p>OOM conditions are rare—hence the huge utility in allowing
        overcommitment in the first place. To be sure, however, these
        conditions are unwelcome, and the indeterministic termination of a
        process by the OOM killer is often unacceptable.</p>
<p>For systems where this is the case, the kernel allows the
        disabling of overcommitment via the file
        <emphasis>/proc/sys/vm/overcommit_memory</emphasis>, and the analogous
        <emphasis>sysctl</emphasis> parameter vm.overcommit_memory.</p>
<p>The default value for this parameter, 0, instructs the kernel to perform a
        heuristic overcommitment strategy, overcommitting memory within
        reason, but disallowing egregious overcommitments. A value of 1 allows all commitments to succeed,
        throwing caution to the wind. Certain memory-intensive applications,
        such as those in the scientific field, tend to request so much more
        memory than they ever need satisfied that such an option makes
        sense.</p>
<p>A value of 2 disables
        overcommitments altogether, and enables <emphasis>strict
        accounting</emphasis>. In this mode, memory commitments are restricted
        to the size of the swap area, plus a configurable percentage of
        physical memory. The configuration percentage is set via the file
        <emphasis>/proc/sys/vm/overcommit_ratio</emphasis>, or the analogous
        <emphasis>sysctl</emphasis> parameter, which is vm.overcommit_ratio. The default is 50, which restricts memory commits to the
        size of the swap area plus half of the physical memory. Because
        physical memory contains the kernel, page tables, system-reserved
        pages, locked pages, and so on, only a portion of it is actually
        swappable and guaranteed to be able to satisfy commitments.</p>
<p>Be careful with strict accounting! Many system designers,
        repulsed by the notion of the OOM killer, think strict accounting is a
        panacea. However, applications often perform many unnecessary
        allocations that reach far into overcommitment territory, and allowing
        this behavior was one of the main motivations behind virtual
        memory.</p>
<empty-line/><empty-line/>
<p><sup>[34] </sup><sup>*</sup> Some systems support a range of
            page sizes. For this reason, the page size is not part of the ABI.
            Applications must programmatically obtain the page size at
            runtime. We covered doing so in Chapter 4 and will review the topic
            in this chapter.</p>
<p><sup>[35] </sup>† Recall from Chapter 5 that
              fork( ) uses copy-on-write to
              duplicate and share the parent's address space with the
              child.</p>
<p><sup>[36] </sup><sup>*</sup> The name is historic; it
                comes from <emphasis>block started by
                symbol</emphasis>.</p>
<p><sup>[37] </sup><sup>*</sup> Undeclared functions default to
          returning an int.
          Integer-to-pointer casts are not automatic, and generate a warning.
          The typecast will suppress the resulting warning.</p>
<p><sup>[38] </sup><sup>*</sup> See <a l:href="http://perens.com/freesoftware/electricfence/">http://perens.com/freesoftware/electricfence/</a> and
            <a l:href="http://valgrind.org">http://valgrind.org</a>, respectively.</p>
<p><sup>[39] </sup><sup>*</sup> <emphasis>glibc</emphasis> also
          uses a significantly more advanced memory allocation algorithm than
          this simple buddy allocation scheme, called an <emphasis>arena
          algorithm</emphasis>.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 9. Signals</strong></p>
<p><emphasis>Signals</emphasis> are software interrupts that provide a
    mechanism for handling asynchronous events. These events can originate
    from outside the system—such as when the user generates the interrupt
    character (usually via Ctrl-C)—or from activities within the program or
    kernel, such as when the process executes code that divides by zero. As a
    primitive form of interprocess communication (IPC), one process can also
    send a signal to another process.</p>
<p>The key point is not just that the events occur asynchronously—the
    user, for example, can press Ctrl-C at any point in the program's
    execution—but also that the program handles the signals asynchronously.
    The signal-handling functions are registered with the kernel, which
    invokes the functions asynchronously from the rest of the program when the
    signals are delivered.</p>
<p>Signals have been part of Unix since the early days. Over time,
    however, they have evolved—most noticeably in terms of reliability, as
    signals could once get lost, and in terms of functionality, as signals may
    now carry user-defined payloads. At first, different Unix systems made
    incompatible changes to signals. Thankfully, POSIX came to the rescue and
    standardized signal handling. This standard is what Linux provides, and is
    what we'll discuss here.</p>
<p>In this chapter, we'll start with an overview of signals, and a
    discussion of their use and misuse. We'll then cover the various Linux
    interfaces that manage and manipulate signals.</p>
<p>Most nontrivial applications interact with signals. Even if you
    deliberately design your application to not rely on signals for its
    communication needs—often a good idea!—you'll still be forced to work with
    signals in certain cases, such as when handling program
    termination.</p>
<empty-line/>
<p><strong>Signal Concepts</strong></p>
<p>Signals have a very precise lifecycle. First, a signal is
      <emphasis>raised</emphasis> (we sometimes also say it is
      <emphasis>sent</emphasis> or <emphasis>generated</emphasis>). The kernel
      then <emphasis>stores</emphasis> the signal until it is able to deliver
      it. Finally, once it is free to do so, the kernel
      <emphasis>handles</emphasis> the signal as appropriate. The kernel can
      perform one of three actions, depending on what the process asked it to
      do:</p>
<p>Ignore <emphasis>the signal</emphasis></p>
<p>No action is taken. There are two signals that cannot be
            ignored: SIGKILL and SIGSTOP. The reason for this is that the
            system administrator needs to be able to kill or stop processes,
            and it would be a circumvention of that right if a process could
            elect to ignore a SIGKILL
            (making it unkillable), or a SIGSTOP (making it unstoppable).Catch <emphasis>and</emphasis> handle <emphasis>the
          signal</emphasis></p>
<p>The kernel will suspend execution of the process' current
            code path, and jump to a previously registered function. The
            process will then execute this function. Once the process returns
            from this function, it will jump back to wherever it was when it
            caught the signal.</p>
<p>SIGINT and SIGTERM are two commonly caught signals.
            Processes catch SIGINT to
            handle the user generating the interrupt character—for example, a
            terminal might catch this signal and return to the main prompt.
            Processes catch SIGTERM to
            perform necessarily cleanup, such as disconnecting from the
            network, or removing temporary files, before terminating. SIGKILL and SIGSTOP cannot be caught.<emphasis>Perform the default action</emphasis></p>
<p>This action depends on the signal being sent. The default
            action is often to terminate the process. This is the case with
            SIGKILL, for instance. However,
            many signals are provided for specific purposes that concern
            programmers in particular situations, and these signals are
            ignored by default because many programs are not interested in
            them. We will look at the various signals and their default
            actions shortly.</p>
<p>Traditionally, when a signal was delivered, the function that
      handled the signal had no information about what had happened except for
      the fact that a particular signal had occurred. Nowadays, the kernel can
      provide a lot of context to programmers who want to receive it, and
      signals can even pass user-defined data, like later and more advanced
      IPC mechanisms.</p>
<empty-line/>
<p><strong>Signal Identifiers</strong></p>
<p>Every signal has a symbolic name that starts with the prefix
        SIG. For example, SIGINT is the
        signal sent when the user presses Ctrl-C, SIGABRT is the signal sent when the process
        calls the abort( ) function, and
        SIGKILL is the signal sent when a
        process is forcefully terminated.</p>
<p>These signals are all defined in a header file included from
        &lt;signal.h&gt;. The signals are
        simply preprocessor definitions that represent positive integers—that
        is, every signal is also associated with an integer identifier. The
        name-to-integer mapping for the signals is implementation-dependent,
        and varies among Unix systems, although the first dozen or so signals
        are usually mapped the same way (SIGKILL is infamously <emphasis>signal
        9</emphasis>, for example). A good programmer will always use a
        signal's human-readable name, and never its integer value.</p>
<p>The signal numbers start at 1 (generally SIGHUP), and proceed linearly upward. There
        are about 31 signals in total, but most programs deal regularly with
        only a handful of them. There is no signal with the value 0, which is
        a special value known as the <emphasis>null signal</emphasis>. There's
        really nothing important about the null signal—it doesn't deserve a
        special name—but some system calls (such as kill( )) use a value of 0 as a special case.</p>
<p>You can generate a list of signals supported on your system with
        the command <emphasis>kill -l</emphasis>.</p>
<empty-line/>
<p><strong>Signals Supported by Linux</strong></p>
<p>Table 9-1 lists the signals that Linux
        supports.</p>
<p><emphasis>Table 9-1. Signals</emphasis></p>
<p><strong>Signal</strong></p>
<p><strong>Description</strong></p>
<p><strong>Default
                action</strong></p>
<p>SIGABRT</p>
<p>Sent by abort( )</p>
<p>Terminate with core
                dump</p>
<p>SIGALRM</p>
<p>Sent by alarm( )</p>
<p>Terminate</p>
<p>SIGBUS</p>
<p>Hardware or alignment
                error</p>
<p>Terminate with core
                dump</p>
<p>SIGCHLD</p>
<p>Child has
                terminated</p>
<p>Ignored</p>
<p>SIGCONT</p>
<p>Process has continued
                after being stopped</p>
<p>Ignored</p>
<p>SIGFPE</p>
<p>Arithmetic
                exception</p>
<p>Terminate with core
                dump</p>
<p>SIGHUP</p>
<p>Process's controlling
                terminal was closed (most frequently, the user logged
                out)</p>
<p>Terminate</p>
<p>SIGILL</p>
<p>Process tried to
                execute an illegal instruction</p>
<p>Terminate with core
                dump</p>
<p>SIGINT</p>
<p>User generated the
                interrupt character (Ctrl-C)</p>
<p>Terminate</p>
<p>SIGIO</p>
<p>Asynchronous I/O
                event</p>
<p>Terminate<sup>[a]</sup></p>
<p>SIGKILL</p>
<p>Uncatchable process
                termination</p>
<p>Terminate</p>
<p>SIGPIPE</p>
<p>Process wrote to a pipe
                but there are no readers</p>
<p>Terminate</p>
<p>SIGPROF</p>
<p>Profiling timer
                expired</p>
<p>Terminate</p>
<p>SIGPWR</p>
<p>Power
                failure</p>
<p>Terminate</p>
<p>SIGQUIT</p>
<p>User generated the quit
                character (Ctrl-\)</p>
<p>Terminate with core
                dump</p>
<p>SIGSEGV</p>
<p>Memory access
                violation</p>
<p>Terminate with core
                dump</p>
<p>SIGSTKFLT</p>
<p>Coprocessor stack
                fault</p>
<p>Terminate<sup>[b]</sup></p>
<p>SIGSTOP</p>
<p>Suspends execution of
                the process</p>
<p>Stop</p>
<p>SIGSYS</p>
<p>Process tried to
                execute an invalid system call</p>
<p>Terminate with core
                dump</p>
<p>SIGTERM</p>
<p>Catchable process
                termination</p>
<p>Terminate</p>
<p>SIGTRAP</p>
<p>Break point
                encountered</p>
<p>Terminate with core
                dump</p>
<p>SIGTSTP</p>
<p>User generated the
                suspend character (Ctrl-Z)</p>
<p>Stop</p>
<p>SIGTTIN</p>
<p>Background process read
                from controlling terminal</p>
<p>Stop</p>
<p>SIGTTOU</p>
<p>Background process
                wrote to controlling terminal</p>
<p>Stop</p>
<p>SIGURG</p>
<p>Urgent I/O
                pending</p>
<p>Ignored</p>
<p>SIGUSR1</p>
<p>Process-defined
                signal</p>
<p>Terminate</p>
<p>SIGUSR2</p>
<p>Process-defined
                signal</p>
<p>Terminate</p>
<p>SIGVTALRM</p>
<p>Generated by setitimer( ) when called with the
                ITIMER_VIRTUAL
                flag</p>
<p>Terminate</p>
<p>SIGWINCH</p>
<p>Size of controlling
                terminal window changed</p>
<p>Ignored</p>
<p>SIGXCPU</p>
<p>Processor resource
                limits were exceeded</p>
<p>Terminate with core
                dump</p>
<p>SIGXFSZ</p>
<p>File resource limits
                were exceeded</p>
<p>Terminate with core
                dump</p>
<p><sup>[a] </sup><sup>a</sup> The behavior on other
                    Unix systems, such as BSD, is to ignore this
                    signal.</p>
<p><sup>[b] </sup><sup>b</sup> The Linux kernel no
                    longer generates this signal; it remains only for backward
                    compatibility.</p>
<p>Several other signal values exist, but Linux defines them to be
        equivalent to other values: SIGINFO
        is defined as SIGPWR,<sup>[40]</sup> SIGIOT is defined as
        SIGABRT, and SIGPOLL and SIGLOST are defined as SIGIO.</p>
<p>Now that we have a table for quick reference, let's go over each
        of the signals in detail:</p>
<p>SIGABRT</p>
<p>The abort( ) function
              sends this signal to the process that invokes it. The process
              then terminates and generates a core file. In Linux, assertions
              such as assert( ) call
              abort( ) when the conditional
              fails.SIGALRM</p>
<p>The alarm( ) and
              setitimer( ) (with the
              ITIMER_REAL flag) functions
              send this signal to the process that invoked them when an alarm
              expires. Chapter 10 discusses these and related
              functions.SIGBUS</p>
<p>The kernel raises this signal when the process incurs a
              hardware fault other than memory protection, which generates a
              SIGSEGV. On traditional Unix
              systems, this signal represented various irrecoverable errors,
              such as unaligned memory access. The Linux kernel, however,
              fixes most of these errors automatically, without generating the
              signal. The kernel does raise this signal when a process
              improperly accesses a region of memory created via mmap( ) (see Chapter 8 for a discussion of memory
              mappings). Unless this signal is caught, the kernel will
              terminate the process, and generate a core dump.SIGCHLD</p>
<p>Whenever a process terminates or stops, the kernel sends
              this signal to the process' parent. Because SIGCHLD is ignored by default,
              processes must explicitly catch and handle it if they are
              interested in the lives of their children. A handler for this
              signal generally calls wait(
              ), discussed in Chapter 5,
              to determine the child's pid and exit code.SIGCONT</p>
<p>The kernel sends this signal to a process when the process
              is resumed after being stopped. By default, this signal is
              ignored, but processes can catch it if they want to perform an
              action after being continued. This signal is commonly used by
              terminals or editors, which wish to refresh the screen.SIGFPE</p>
<p>Despite its name, this signal represents any arithmetic
              exception, and not solely those related to floating-point
              operations. Exceptions include overflows, underflows, and
              division by zero. The default action is to terminate the process
              and generate a core file, but processes may catch and handle
              this signal if they want. Note that the behavior of a process
              and the result of the offending operation are undefined if the
              process elects to continue running.SIGHUP</p>
<p>The kernel sends this signal to the session leader
              whenever the session's terminal disconnects. The kernel also
              sends this signal to each process in the foreground process
              group when the session leader terminates. The default action is
              to terminate, which makes sense—the signal suggests that the
              user has logged out. Daemon processes "overload" this signal
              with a mechanism to instruct them to reload their configuration
              files. Sending SIGHUP to
              Apache, for example, instructs it to reread
              <emphasis>httpd.conf</emphasis>. Using SIGHUP for this purpose is a common
              convention, but not mandatory. The practice is safe because
              daemons do not have controlling terminals, and thus should never
              normally receive this signal.SIGILL</p>
<p>The kernel sends this signal when a process attempts to
              execute an illegal machine instruction. The default action is to
              terminate the process, and generate a core dump. Processes may
              elect to catch and handle SIGILL, but their behavior is
              undefined after its occurrence.SIGINT</p>
<p>This signal is sent to all processes in the foreground
              process group when the user enters the interrupt character
              (usually Ctrl-C). The default behavior is to terminate; however,
              processes can elect to catch and handle this signal, and
              generally do so to clean up before terminating.SIGIO</p>
<p>This signal is sent when a BSD-style asynchronous I/O
              event is generated. This style of I/O is rarely used on Linux.
              (See Chapter 4 for a
              discussion of advanced I/O techniques that are common to
              Linux.)SIGKILL</p>
<p>This signal is sent from the kill( ) system call; it exists to
              provide system administrators with a surefire way of
              unconditionally killing a process. This signal cannot be caught
              or ignored, and its result is always to terminate the
              process.SIGPIPE</p>
<p>If a process writes to a pipe, but the reader has
              terminated, the kernel raises this signal. The default action is
              to terminate the process, but this signal may be caught and
              handled.SIGPROF</p>
<p>The setitimer( )
              function, when used with the ITIMER_PROF flag, generates this
              signal when a profiling timer expires. The default action is to
              terminate the process.SIGPWR</p>
<p>This signal is system-dependent. On Linux, it represents a
              low-battery condition (such as in an uninterruptible power
              supply, or UPS). A UPS monitoring daemon sends this signal to
              <emphasis>init</emphasis>, which then responds by cleaning up
              and shutting down the system—hopefully before the power goes
              out!SIGQUIT</p>
<p>The kernel raises this signal for all processes in the
              foreground process group when the user provides the terminal
              quit character (usually Ctrl-\). The default action is to
              terminate the processes, and generate a core dump.SIGSEGV</p>
<p>This signal, whose name derives from
              <emphasis>segmentation violation</emphasis>, is sent to a
              process when it attempts an invalid memory access. This includes
              accessing unmapped memory, reading from memory that is not
              read-enabled, executing code in memory that is not
              execute-enabled, or writing to memory that is not write-enabled.
              Processes may catch and handle this signal, but the default
              action is to terminate the process and generate a core
              dump.SIGSTOP</p>
<p>This signal is sent only by kill(
              ). It unconditionally stops a process, and cannot be
              caught or ignored.SIGSYS</p>
<p>The kernel sends this signal to a process when it attempts
              to invoke an invalid system call. This can happen if a binary is
              built on a newer version of the operating system (with newer
              versions of system calls), but then runs on an older version.
              Properly built binaries that make their system calls through
              <emphasis>glibc</emphasis> should never receive this signal.
              Instead, invalid system calls should return −1, and set errno to ENOSYS.SIGTERM</p>
<p>This signal is sent only by kill(
              ); it allows a user to gracefully terminate a process
              (the default action). Processes may elect to catch this signal,
              and clean up before terminating, but it is considered rude to
              catch this signal and not terminate promptly.SIGTRAP</p>
<p>The kernel sends this signal to a process when it crosses
              a break point. Generally, debuggers catch this signal, and other
              processes ignore it.SIGTSTP</p>
<p>The kernel sends this signal to all processes in the
              foreground process group when the user provides the suspend
              character (usually Ctrl-Z).SIGTTIN</p>
<p>This signal is sent to a process that is in the background
              when it attempts to read from its controlling terminal. The
              default action is to stop the process.SIGTTOU</p>
<p>This signal is sent to a process that is in the background
              when it attempts to write to its controlling terminal. The
              default action is to stop the process.SIGURG</p>
<p>The kernel sends this signal to a process when out-of-band
              (OOB) data has arrived on a socket. Out-of-band data is beyond
              the scope of this book.SIGUSR1
            <emphasis>and</emphasis> SIGUSR2</p>
<p>These signals are available for user-defined purposes; the
              kernel never raises them. Processes may use SIGUSR1 and SIGUSR2 for whatever purpose they
              like. A common use is to instruct a daemon process to behave
              differently. The default action is to terminate the
              process.SIGVTALRM</p>
<p>The setitimer( )
              function sends this signal when a timer created with the
              ITIMER_VIRTUAL flag expires.
              Chapter 10 discusses timers.SIGWINCH</p>
<p>The kernel raises this signal for all processes in the
              foreground process group when the size of their terminal window
              changes. By default, processes ignore this signal, but they may
              elect to catch and handle it if they are aware of their
              terminal's window size. A good example of a program that catches
              this signal is <emphasis>top</emphasis>—try resizing its window
              while it is running and watch how it responds.SIGXCPU</p>
<p>The kernel raises this signal when a process exceeds its
              soft processor limit. The kernel will continue to raise this
              signal once per second until the process exits, or exceeds its
              hard processor limit. Once the hard limit is exceeded, the
              kernel sends the process a SIGKILL.SIGXFSZ</p>
<p>The kernel raises this signal when a process exceeds its
              file size limit. The default action is to terminate the process,
              but if this signal is caught or ignored, the system call that
              would have resulted in the file size limit being exceeded
              returns −1, and sets errno to EFBIG.</p>
<empty-line/>
<p><strong>Basic Signal Management</strong></p>
<p>The simplest and oldest interface for signal management is the
      signal( ) function. Defined by the
      ISO C89 standard, which standardizes only the lowest common denominator
      of signal support, this system call is very basic. Linux offers
      substantially more control over signals via other interfaces, which
      we'll cover later in this chapter. Because signal( ) is the most basic, and, thanks to
      its presence in ISO C, quite common, we'll cover it first:<strong>#include &lt;signal.h&gt;

typedef void (*sighandler_t)(int);

sighandler_t signal (int signo, sighandler_t handler);</strong></p>
<p>A successful call to signal( )
      removes the current action taken on receipt of the signal signo, and instead handles the signal with the
      signal handler specified by handler.
      signo is one of the signal names
      discussed in the previous section, such as SIGINT or SIGUSR1. Recall that a process can catch
      neither SIGKILL nor SIGSTOP, so setting up a handler for either of
      these two signals makes no sense.</p>
<p>The handler function must
      return void, which makes sense
      because (unlike with normal functions) there is no standard place in the
      program for this function to return. The function takes one argument, an
      integer, which is the signal identifier (for example, SIGUSR2) of the signal being handled. This
      allows a single function to handle multiple signals. A prototype has the
      form:void my_handler (int signo);</p>
<p>Linux uses a typedef, sighandler_t, to define this prototype. Other
      Unix systems directly use the function pointers; some systems have their
      own types, which may not be named sighandler_t. Programs seeking portability
      should not reference the type directly.</p>
<p>When it raises a signal to a process that has registered a signal
      handler, the kernel suspends execution of the program's regular
      instruction stream, and calls the signal handler. The handler is passed
      the value of the signal, which is the signo originally provided to signal( ).</p>
<p>You may also use signal( ) to
      instruct the kernel to ignore a given signal for the current process, or
      to reset the signal to the default behavior. This is done using special
      values for the handler
      parameter:</p>
<p>SIG_DFL</p>
<p>Set the behavior of the signal given by signo to its default. For example, in
            the case of SIGPIPE, the
            process will terminate.SIG_IGN</p>
<p>Ignore the signal given by signo.</p>
<p>The signal( ) function returns
      the previous behavior of the signal, which could be a pointer to a
      signal handler, SIG_DFL, or SIG_IGN. On error, the function returns
      SIG_ERR. It does not set errno.</p>
<empty-line/>
<p><strong>Waiting for a Signal, Any Signal</strong></p>
<p>Useful for debugging and writing demonstrative code snippets,
        the POSIX-defined pause( ) system
        call puts a process to sleep until it receives a signal that either is
        handled or terminates the process:<strong>#include &lt;unistd.h&gt;

int pause (void);</strong></p>
<p>pause( ) returns only if a
        caught signal is received, in which case the signal is handled, and
        pause( ) returns −1, and sets errno to EINTR. If the kernel raises an ignored
        signal, the process does not wake up.</p>
<p>In the Linux kernel, pause( )
        is one of the simplest system calls. It performs only two actions.
        First, it puts the process in the interruptible sleep state. Next, it
        calls schedule( ) to invoke the
        Linux process scheduler to find another process to run. As the process
        is not actually waiting for anything, the kernel will not wake it up
        unless it receives a signal. This whole ordeal consumes only two lines
        of C code.<sup>[41]</sup></p>
<empty-line/>
<p><strong>Examples</strong></p>
<p>Let's look at a couple of simple examples. This first one
        registers a signal handler for SIGINT that simply prints a message and then
        terminates the program (as SIGINT
        would do anyway):#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

/* handler for SIGINT */
static void sigint_handler (int signo)
{
        /*
         * Technically, you shouldn't use printf(  ) in a
         * signal handler, but it isn't the end of the
         * world. I'll discuss why in the section
         * "Reentrancy."
         */
        printf ("Caught SIGINT!\n");
        exit (EXIT_SUCCESS);
}

int main (void)
{
        /*
         * Register sigint_handler as our signal handler
         * for SIGINT.
         */
        if (signal (SIGINT, sigint_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGINT!\n");
                exit (EXIT_FAILURE);
        }

        for (;;)
                pause (  );

        return 0;
}</p>
<p>In the following example, we register the same handler for
        SIGTERM and SIGINT. We also reset the behavior for
        SIGPROF to the default (which is to
        terminate the process) and ignore SIGHUP (which would otherwise terminate the
        process):#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

/* handler for SIGINT */
static void signal_handler (int signo)
{
        if (signo == SIGINT)
                printf ("Caught SIGINT!\n");
        else if (signo == SIGTERM)
                printf ("Caught SIGTERM!\n");
        else {
                /* this should never happen */
                fprintf (stderr, "Unexpected signal!\n");
                exit (EXIT_FAILURE);
        }
        exit (EXIT_SUCCESS);
}

int main (void)
{
        /*
         * Register signal_handler as our signal handler
         * for SIGINT.
         */
        if (signal (SIGINT, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGINT!\n");
                exit (EXIT_FAILURE);
        }

        /*
         * Register signal_handler as our signal handler
         * for SIGTERM.
         */
        if (signal (SIGTERM, signal_handler) == SIG_ERR) {
                fprintf (stderr, "Cannot handle SIGTERM!\n");
                exit (EXIT_FAILURE);
        }

        /* Reset SIGPROF's behavior to the default. */
        if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
                fprintf (stderr, "Cannot reset SIGPROF!\n");
                exit (EXIT_FAILURE);
        }

        /* Ignore SIGHUP. */
        if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
                fprintf (stderr, "Cannot ignore SIGHUP!\n");
                exit (EXIT_FAILURE);
        }

        for (;;)
                pause (  );

        return 0;
}</p>
<empty-line/>
<p><strong>Execution and Inheritance</strong></p>
<p>When a process is first executed, all signals are set to their
        default actions, unless the parent process (the one executing the new
        process) is ignoring them; in this case, the newly created process
        will also ignore those signals. Put another way, any signal caught by
        the parent is reset to the default action in the new process, and all
        other signals remain the same. This makes sense because a freshly
        executed process does not share the address space of its parent, and
        thus any registered signal handlers may not exist.</p>
<p>This behavior on process execution has one notable use: when the
        shell executes a process "in the background" (or when another
        background process executes another process), the newly executed
        process should ignore the interrupt and quit characters. Thus, before
        a shell executes a background process, it should set SIGINT and SIGQUIT to SIG_IGN. It is therefore common for programs
        that handle these signals to first check to make sure they are not
        ignored. For example:/* handle SIGINT, but only if it isn't ignored */
if (signal (SIGINT, SIG_IGN) != SIG_IGN) {
        if (signal (SIGINT, sigint_handler) == SIG_ERR)
                fprintf (stderr, "Failed to handle SIGINT!\n");
}

/* handle SIGQUIT, but only if it isn't ignored */
if (signal (SIGQUIT, SIG_IGN) != SIG_IGN) {
        if (signal (SIGQUIT, sigquit_handler) == SIG_ERR)
                fprintf (stderr, "Failed to handle SIGQUIT!\n");
}</p>
<p>The need to set a signal behavior to check the signal behavior
        highlights a deficiency in the signal(
        ) interface. Later, we will study a function that does not
        have this flaw.</p>
<p>The behavior with fork( ) is,
        as you might expect, different. When a process calls fork( ), the child inherits the exact same
        signal semantics as the parent. This also makes sense, as the child
        and parent share an address space, and thus the parent's signal
        handlers exist in the child.</p>
<empty-line/>
<p><strong>Mapping Signal Numbers to Strings</strong></p>
<p>In our examples thus far, we have hardcoded the names of the
        signals. But sometimes it is more convenient (or even a requirement)
        that you be able to convert a signal number to a string representation
        of its name. There are several ways to do this. One is to retrieve the
        string from a statically defined list:<strong>extern const char * const sys_siglist[];</strong></p>
<p>sys_siglist is an array of
        strings holding the names of the signals supported by the system,
        indexed by signal number.</p>
<p>An alternative is the BSD-defined psignal( ) interface, which is common enough
        that Linux supports it, too:<strong>#include &lt;signal.h&gt;

void psignal (int signo, const char *msg);</strong></p>
<p>A call to psignal( ) prints
        to stderr the string you supply as
        the msg argument, followed by a
        colon, a space, and the name of the signal given by signo. If signo is invalid, the printed message will
        say so.</p>
<p>A better interface is strsignal(
        ). It is not standardized, but Linux and many non-Linux
        systems support it:<strong>#define _GNU_SOURCE
#include &lt;string.h&gt;

char *strsignal (int signo);</strong></p>
<p>A call to strsignal( )
        returns a pointer to a description of the signal given by signo. If signo is invalid, the returned description
        typically says so (some Unix systems that support this function return
        NULL instead). The returned string
        is valid only until the next invocation of strsignal( ), so this function is not
        thread-safe.</p>
<p>Going with sys_siglist is
        usually your best bet. Using this approach, we could rewrite our
        earlier signal handler as follows:static void signal_handler (int signo)
{
        printf ("Caught %s\n", sys_siglist[signo]);
}</p>
<empty-line/>
<p><strong>Sending a Signal</strong></p>
<p>The kill( ) system call, the
      basis of the common <emphasis>kill</emphasis> utility, sends a signal
      from one process to another:<strong>#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;

int kill (pid_t pid, int signo);</strong></p>
<p>In its normal use (i.e., if pid
      is greater than 0), kill( ) sends the signal signo to the process identified by pid.</p>
<p>If pid is 0, signo is
      sent to every process in the invoking process' process group.</p>
<p>If pid is −1, signo
      is sent to every process for which the invoking process has permission
      to send a signal, except itself and <emphasis>init</emphasis>. We will
      discuss the permissions regulating signal delivery in the next
      subsection.</p>
<p>If pid is less than −1, signo
      is sent to the process group -pid.</p>
<p>On success, kill( ) returns
      0. The call is considered a success
      so long as a single signal was sent. On failure (no signals sent), the
      call returns −1, and sets errno to one of the following:</p>
<p>EINVAL</p>
<p>The signal specified by signo is invalid.EPERM</p>
<p>The invoking process lacks sufficient permissions to send a
            signal to any of the requested processes.ESRCH</p>
<p>The process or process group denoted by pid does not exist, or, in the case of a
            process, is a zombie.</p>
<empty-line/>
<p><strong>Permissions</strong></p>
<p>In order to send a signal to another process, the sending
        process needs proper permissions. A process with the CAP_KILL capability (usually one owned by
        root) can send a signal to any process. Without this capability, the
        sending process' effective or real user ID must be equal to the real
        or saved user ID of the receiving process. Put more simply, a user can
        send a signal only to a process that he or she owns.</p>
<p><strong>Tip</strong></p>
<p>Unix systems define an exception for SIGCONT: a process can send this signal to
          any other process in the same session. The user ID need not
          match.</p>
<p>If signo is 0—the aforementioned null signal—the call
        does not send a signal, but it still performs error checking. This is
        useful to test whether a process has suitable permissions to send the
        provided process or processes a signal.</p>
<empty-line/>
<p><strong>Examples</strong></p>
<p>Here's how to send SIGHUP to
        the process with process ID 1722:int ret;

ret = kill (1722, SIGHUP);
if (ret)
        perror ("kill");</p>
<p>This snippet is effectively the same as the following invocation
        of the <emphasis>kill</emphasis> utility:$ kill -HUP 1722</p>
<p>To check that we have permission to send a signal to 1722
        without actually sending any signal, we could do the following:int ret;

ret = kill (1722, 0);
if (ret)
        ; /* we lack permission */
else
        ; /* we have permission */</p>
<empty-line/>
<p><strong>Sending a Signal to Yourself</strong></p>
<p>The raise( ) function is a
        simple way for a process to send a signal to itself:<strong>#include &lt;signal.h&gt;

int raise (int signo);</strong></p>
<p>This call:raise (signo);</p>
<p>is equivalent to the following call:kill (getpid (  ), signo);</p>
<p>The call returns 0 on
        success, and a nonzero value on failure. It does not set errno.</p>
<empty-line/>
<p><strong>Sending a Signal to an Entire Process Group</strong></p>
<p>Another convenience function makes it easy to send a signal to
        all processes in a given process group, in the event that negating the
        process group ID and using kill( )
        is deemed too taxing:<strong>#include &lt;signal.h&gt;

int killpg (int pgrp, int signo);</strong></p>
<p>This call:killpg (pgrp, signo);</p>
<p>is equivalent to the following call:kill (-pgrp, signo);</p>
<p>This holds true even if pgrp
        is 0, in which case killpg( ) sends the signal signo to every process in the invoking
        process' group.</p>
<p>On success, killpg( ) returns
        0. On failure, it returns −1, and sets errno to one of the following values:</p>
<p>EINVAL</p>
<p>The signal specified by signo is invalid.EPERM</p>
<p>The invoking process lacks sufficient permissions to send
              a signal to any of the requested processes.ESRCH</p>
<p>The process group denoted by pgrp does not exist.</p>
<empty-line/>
<p><strong>Reentrancy</strong></p>
<p>When the kernel raises a signal, a process can be executing code
      anywhere. For example, it might be in the middle of an important
      operation that, if interrupted, would leave the process is an
      inconsistent state—say, with a data structure only half updated, or a
      calculation only partially performed. The process might even be handling
      another signal.</p>
<p>Signal handlers cannot tell what code the process is executing
      when a signal hits; the handler can run in the middle of anything. It is
      thus very important that any signal handler your process installs be
      very careful about the actions it performs and the data it touches.
      Signal handlers must take care not to make assumptions about what the
      process was doing when it was interrupted. In particular, they must
      practice caution when modifying global (that is, shared) data. In
      general, it is a good idea for a signal handler never to touch global
      data; in an upcoming section, however, we will look at a way to
      temporarily block the delivery of signals, as a way to allow safe
      manipulation of data shared by a signal handler and the rest of a
      process.</p>
<p>What about system calls and other library functions? What if your
      process is in the middle of writing to a file or allocating memory, and
      a signal handler writes to the same file or also invokes malloc( )? Or what if a process is in the
      middle of a call to a function that uses a static buffer, such as
      strsignal( ), when a signal is
      delivered?</p>
<p>Some functions are clearly not reentrant. If a program is in the
      middle of executing a nonreentrant function, a signal occurs, and the
      signal handler then invokes that same nonreentrant function, chaos can
      ensue. A <emphasis>reentrant function</emphasis> is a function that is
      safe to call from within itself (or concurrently, from another thread in
      the same process). In order to qualify as reentrant, a function must not
      manipulate static data, must manipulate only stack-allocated data or
      data provided to it by the caller, and must not invoke any nonreentrant
      function.</p>
<empty-line/>
<p><strong>Guaranteed-Reentrant Functions</strong></p>
<p>When writing a signal handler, you have to assume that the
        interrupted process could be in the middle of a nonreentrant function
        (or anything else, for that matter). Thus, signal handlers must make
        use only of functions that are reentrant.</p>
<p>Various standards have decreed lists of functions that are
        <emphasis>signal-safe</emphasis>—that is, reentrant, and thus safe to
        use from within a signal handler. Most notably, POSIX.1-2003 and the
        Single UNIX Specification dictate a list of functions that are
        guaranteed to be reentrant and signal-safe on all compliant platforms.
        Table 9-2 lists the
        functions.</p>
<p><emphasis>Table 9-2. Functions guaranteed to be safely reentrant for use in
          signals</emphasis></p>
<p>abort( )</p>
<p>accept( )</p>
<p>access( )</p>
<p>aio_error( )</p>
<p>aio_return( )</p>
<p>aio_suspend( )</p>
<p>alarm( )</p>
<p>bind( )</p>
<p>cfgetispeed( )</p>
<p>cfgetospeed( )</p>
<p>cfsetispeed( )</p>
<p>cfsetospeed( )</p>
<p>chdir( )</p>
<p>chmod( )</p>
<p>chown( )</p>
<p>clock_gettime( )</p>
<p>close( )</p>
<p>connect( )</p>
<p>creat( )</p>
<p>dup( )</p>
<p>dup2( )</p>
<p>execle( )</p>
<p>execve( )</p>
<p>Exit( )</p>
<p>_exit( )</p>
<p>fchmod( )</p>
<p>fchown( )</p>
<p>fcntl( )</p>
<p>fdatasync( )</p>
<p>fork( )</p>
<p>fpathconf( )</p>
<p>fstat( )</p>
<p>fsync( )</p>
<p>ftruncate( )</p>
<p>getegid( )</p>
<p>geteuid( )</p>
<p>getgid( )</p>
<p>getgroups( )</p>
<p>getpeername( )</p>
<p>getpgrp( )</p>
<p>getpid( )</p>
<p>getppid( )</p>
<p>getsockname( )</p>
<p>getsockopt( )</p>
<p>getuid( )</p>
<p>kill( )</p>
<p>link( )</p>
<p>listen( )</p>
<p>lseek( )</p>
<p>lstat( )</p>
<p>mkdir( )</p>
<p>mkfifo( )</p>
<p>open( )</p>
<p>pathconf( )</p>
<p>pause( )</p>
<p>pipe( )</p>
<p>poll( )</p>
<p>posix_trace_event( )</p>
<p>pselect( )</p>
<p>raise( )</p>
<p>read( )</p>
<p>readlink( )</p>
<p>recv( )</p>
<p>recvfrom( )</p>
<p>recvmsg( )</p>
<p>rename( )</p>
<p>rmdir( )</p>
<p>select( )</p>
<p>sem_post( )</p>
<p>send( )</p>
<p>sendmsg( )</p>
<p>sendto( )</p>
<p>setgid( )</p>
<p>setpgid( )</p>
<p>setsid( )</p>
<p>setsockopt( )</p>
<p>setuid( )</p>
<p>shutdown( )</p>
<p>sigaction( )</p>
<p>sigaddset( )</p>
<p>sigdelset( )</p>
<p>sigemptyset( )</p>
<p>sigfillset( )</p>
<p>sigismember( )</p>
<p>signal( )</p>
<p>sigpause( )</p>
<p>sigpending( )</p>
<p>sigprocmask( )</p>
<p>sigqueue( )</p>
<p>sigset( )</p>
<p>sigsuspend( )</p>
<p>sleep( )</p>
<p>socket( )</p>
<p>socketpair( )</p>
<p>stat( )</p>
<p>symlink( )</p>
<p>sysconf( )</p>
<p>tcdrain( )</p>
<p>tcflow( )</p>
<p>tcflush( )</p>
<p>tcgetattr( )</p>
<p>tcgetpgrp( )</p>
<p>tcsendbreak( )</p>
<p>tcsetattr( )</p>
<p>tcsetpgrp( )</p>
<p>time( )</p>
<p>timer_getoverrun( )</p>
<p>timer_gettime( )</p>
<p>timer_settime( )</p>
<p>times( )</p>
<p>umask( )</p>
<p>uname( )</p>
<p>unlink( )</p>
<p>utime( )</p>
<p>wait( )</p>
<p>waitpid( )</p>
<p>write( )</p>
<p>Many more functions are safe, but Linux and other
        POSIX-compliant systems guarantee the reentrancy of only these
        functions.</p>
<empty-line/>
<p><strong>Signal Sets</strong></p>
<p>Several of the functions we will look at later in this chapter
      need to manipulate sets of signals, such as the set of signals blocked
      by a process, or the set of signals pending to a process. The
      <emphasis>signal set operations</emphasis> manage these signal
      sets:<strong>#include &lt;signal.h&gt;

int sigemptyset (sigset_t *set);

int sigfillset (sigset_t *set);
int sigaddset (sigset_t *set, int signo);

int sigdelset (sigset_t *set, int signo);

int sigismember (const sigset_t *set, int signo);</strong></p>
<p>sigemptyset( ) initializes the
      signal set given by set, marking it
      empty (all signals excluded from the set). sigfillset( ) initializes the signal set given
      by set, marking it full (all signals
      included in the set). Both functions return 0. You should call one of these two functions
      on a signal set before further using the set.</p>
<p>sigaddset( ) adds signo to the signal set given by set, while sigdelset(
      ) removes signo from the
      signal set given by set. Both return
      0 on success, or −1 on error, in which case errno is set to the error code EINVAL, signifying that signo is an invalid signal identifier.</p>
<p>sigismember( ) returns 1 if signo
      is in the signal set given by set,
      0 if it is not, and −1 on error. In the latter case, errno is again set to EINVAL, signifying that signo is invalid.</p>
<empty-line/>
<p><strong>More Signal Set Functions</strong></p>
<p>The preceding functions are all standardized by POSIX, and found
        on any modern Unix system. Linux also provides several nonstandard
        functions:<strong>#define _GNU_SOURCE
#define &lt;signal.h&gt;

int sigisemptyset (sigset_t *set);

int sigorset (sigset_t *dest, sigset_t *left, sigset_t *right);

int sigandset (sigset_t *dest, sigset_t *left, sigset_t *right);</strong></p>
<p>sigisemptyset( ) returns
        1 if the signal set given by
        set is empty, and 0 otherwise.</p>
<p>sigorset( ) places the union
        (the binary OR) of the signal sets left and right in dest. sigandset(
        ) places the intersection (the binary AND) of the signal
        sets left and right in dest. Both return 0 on success, and −1 on error, setting errno to EINVAL.</p>
<p>These functions are useful, but programs desiring full POSIX
        compliance should avoid them.</p>
<empty-line/>
<p><strong>Blocking Signals</strong></p>
<p>Earlier, we discussed reentrancy and the issues raised by signal
      handlers running asynchronously, at any time. We discussed functions not
      to call from within a signal handler because they themselves are not
      reentrant.</p>
<p>But what if your program needs to share data between a signal
      handler and elsewhere in the program? What if there are portions of your
      program's execution during which you do not want any interruptions,
      including from signal handlers? We call such parts of a program
      <emphasis>critical regions</emphasis>, and we protect them by
      temporarily suspending the delivery of signals. We say that such signals
      are <emphasis>blocked</emphasis>. Any signals that are raised while
      blocked are not handled until they are unblocked. A process may block
      any number of signals; the set of signals blocked by a process is called
      its <emphasis>signal mask</emphasis>.</p>
<p>POSIX defines, and Linux implements, a function for managing a
      process' signal mask:<strong>#include &lt;signal.h&gt;

int sigprocmask (int how,
                 const sigset_t *set,
                 sigset_t *oldset);</strong></p>
<p>The behavior of sigprocmask( )
      depends on the value of how, which is
      one of the following flags:</p>
<p>SIG_SETMASK</p>
<p>The signal mask for the invoking process is changed to
            set.SIG_BLOCK</p>
<p>The signals in set are
            added to the invoking process' signal mask. In other words, the
            signal mask is changed to the union (binary OR) of the current
            mask and set.SIG_UNBLOCK</p>
<p>The signals in set are
            removed from the invoking process' signal mask. In other words,
            the signal is changed to the intersection (binary AND) of the
            current mask, and the negation (binary NOT) of set. It is illegal to unblock a signal
            that is not blocked.</p>
<p>If oldset is not NULL, the function places the previous signal
      set in oldset.</p>
<p>If set is NULL, the function ignores how, and does not change the signal mask, but
      it does place the signal mask in oldset. In other words, passing a null value
      as set is the way to retrieve the
      current signal mask.</p>
<p>On success, the call returns 0.
      On failure, it returns −1, and sets
      errno to either EINVAL, signifying that how was invalid, or EFAULT, signifying that set or oldset was an invalid pointer.</p>
<p>Blocking SIGKILL or SIGSTOP is not allowed. sigprocmask( ) silently ignores any attempt to
      add either signal to the signal mask.</p>
<empty-line/>
<p><strong>Retrieving Pending Signals</strong></p>
<p>When the kernel raises a blocked signal, it is not delivered. We
        call such signals <emphasis>pending</emphasis>. When a pending signal
        is unblocked, the kernel then passes it off to the process to
        handle.</p>
<p>POSIX defines a function to retrieve the set of pending
        signals:<strong>#include &lt;signal.h&gt;

int sigpending (sigset_t *set);</strong></p>
<p>A successful call to sigpending(
        ) places the set of pending signals in set, and returns 0. On failure, the call returns −1, and sets errno to EFAULT, signifying that set is an invalid pointer.</p>
<empty-line/>
<p><strong>Waiting for a Set of Signals</strong></p>
<p>A third POSIX-defined function allows a process to temporarily
        change its signal mask, and then wait until a signal is raised that
        either terminates, or is handled by the process:<strong>#include &lt;signal.h&gt;

int sigsuspend (const sigset_t *set);</strong></p>
<p>If a signal terminates the process, sigsuspend( ) does not return. If a signal
        is raised and handled, sigsuspend(
        ) returns −1 after the
        signal handler returns, setting errno to EINTR. If set is an invalid pointer, errno is set to EFAULT.</p>
<p>A common sigsuspend( ) usage
        scenario is to retrieve signals that might have arrived and been
        blocked during a critical region of program execution. The process
        first uses sigprocmask( ) to block
        a set of signals, saving the old mask in oldset. After exiting the critical region,
        the process then calls sigsuspend(
        ), providing oldset for
        set.</p>
<empty-line/>
<p><strong>Advanced Signal Management</strong></p>
<p>The signal( ) function that we
      studied at the beginning of this chapter is very basic. Because it is
      part of the standard C library, and therefore has to reflect minimal
      assumptions about the capabilities of the operating system on which it
      runs, it can offer only a lowest common denominator to signal
      management. As an alternative, POSIX standardizes the sigaction( ) system call, which provides much
      greater signal management capabilities. Among other things, you can use
      it to block the reception of specified signals while your handler runs,
      and to retrieve a wide range of data about the system and process state
      at the moment a signal was raised:<strong>#include &lt;signal.h&gt;

int sigaction (int signo,
               const struct sigaction *act,
               struct sigaction *oldact);</strong></p>
<p>A call to sigaction( ) changes
      the behavior of the signal identified by signo, which can be any value except those
      associated with SIGKILL and SIGSTOP. If act is not NULL, the system call changes the current
      behavior of the signal as specified by act. If oldact is not NULL, the call stores the previous (or
      current, if act is NULL) behavior of
      the given signal there.</p>
<p>The sigaction structure allows
      for fine-grained control over signals. The header &lt;sys/signal.h&gt;, included from &lt;signal.h&gt;, defines the structure as
      follows:<strong>struct sigaction {
        void (*sa_handler)(int);   /* signal handler or action */
        void (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t sa_mask;          /* signals to block */
        int sa_flags;              /* flags */
        void (*sa_restorer)(void); /* obsolete and non-POSIX */
}</strong></p>
<p>The sa_handler field dictates
      the action to take upon receiving the signal. As with signal( ), this field may be SIG_DFL, signifying the default action,
      SIG_IGN, instructing the kernel to
      ignore the signal for the process, or a pointer to a signal-handling
      function. The function has the same prototype as a signal handler
      installed by signal( ):void my_handler (int signo);</p>
<p>If SA_SIGINFO is set in
      sa_flags, sa_sigaction, and not sa_handler, dictates the signal-handling
      function. This function's prototype is slightly different:void my_handler (int signo, siginfo_t *si, void *ucontext);</p>
<p>The function receives the signal number as its first parameter, a
      siginfo_t structure as its second
      parameter, and a ucontext_t structure
      (cast to a void pointer) as its third
      parameter. It has no return value. The siginfo_t structure provides an abundance of
      information to the signal handler; we will look at it shortly.</p>
<p>Note that on some machine architectures (and possibly other Unix
      systems), sa_handler and sa_sigaction are in a union, and you should
      not assign values to both fields.</p>
<p>The sa_mask field provides a
      set of signals that the system should block for the duration of the
      execution of the signal handler. This allows programmers to enforce
      proper protection from reentrancy among multiple signal handlers. The
      signal currently being handled is also blocked, unless the SA_NODEFER flag is set in sa_flags. You cannot block SIGKILL or SIGSTOP; the call will silently ignore either
      in sa_mask.</p>
<p>The sa_flags field is a bitmask
      of zero, one, or more flags that change the handling of the signal given
      by signo. We already looked at the
      SA_SIGINFO and SA_NODEFER flags; other values for sa_flags include the following:</p>
<p>SA_NOCLDSTOP</p>
<p>If signo is SIGCHLD, this flag instructs the system
            to not provide notification when a child process stops or
            resumes.SA_NOCLDWAIT</p>
<p>If signo is SIGCHLD, this flag enables
            <emphasis>automatic child reaping</emphasis>: children are not
            converted to zombies on termination, and the parent need not (and
            cannot) call wait( ) on them.
            See Chapter 5 for a lively discussion
            of children, zombies, and wait(
            ).SA_NOMASK</p>
<p>This flag is an obsolete non-POSIX equivalent to SA_NODEFER (discussed earlier in this
            section). Use SA_NODEFER
            instead of this flag, but be prepared to see this value turn up in
            older code.SA_ONESHOT</p>
<p>This flag is an obsolete non-POSIX equivalent to SA_RESETHAND (discussed later in this
            list). Use SA_RESETHAND instead
            of this flag, but be prepared to see this value turn up in older
            code.SA_ONSTACK</p>
<p>This flag instructs the system to invoke the given signal
            handler on an <emphasis>alternative signal stack</emphasis>, as
            provided by sigaltstack( ). If
            you do not provide an alternative stack, the default is used—that
            is, the system behaves as if you did not provide this flag.
            Alternative signal stacks are rare, although they are useful in
            some pthreads applications with smaller thread stacks that might
            be overrun by some signal handler usage. We do not further discuss
            sigaltstack( ) in this
            book.SA_RESTART</p>
<p>This flag enables BSD-style restarting of system calls that
            are interrupted by signals.SA_RESETHAND</p>
<p>This flag enables "one-shot" mode. The behavior of the given
            signal is reset to the default once the signal handler
            returns.</p>
<p>The sa_restorer field is
      obsolete, and no longer used in Linux. It is not part of POSIX, anyhow.
      Pretend that it is not there, and do not touch it.</p>
<p>sigaction( ) returns 0 on success. On failure, the call returns
      −1, and sets errno to one of the following error
      codes:</p>
<p>EFAULT</p>
<p>act or oldact is an invalid pointer.EINVAL</p>
<p>signo is an invalid
            signal, SIGKILL, or SIGSTOP.</p>
<empty-line/>
<p><strong>The siginfo_t Structure</strong></p>
<p>The siginfo_t structure is
        also defined in &lt;sys/signal.h&gt;, as follows:<strong>typedef struct siginfo_t {
        int si_signo;      /* signal number */
        int si_errno;      /* errno value */
        int si_code;       /* signal code */
        pid_t si_pid;      /* sending process's PID */
        uid_t si_uid;      /* sending process's real UID */
        int si_status;     /* exit value or signal */
        clock_t si_utime;  /* user time consumed */
        clock_t si_stime;  /* system time consumed */
        sigval_t si_value; /* signal payload value */
        int si_int;        /* POSIX.1b signal */
        void *si_ptr;      /* POSIX.1b signal */
        void *si_addr;     /* memory location that caused fault */
        int si_band;       /* band event */
        int si_fd;         /* file descriptor */
};</strong></p>
<p>This structure is rife with information passed to the signal
        handler (if you're using sa_sigaction in lieu of sa_sighandler). With modern computing, many
        consider the Unix signal model an awful method for performing IPC.
        Perhaps the problem is that these folks are stuck using signal( ) when they should be using sigaction( ) with SA_SIGINFO. The siginfo_t structure opens the door for
        wringing a lot more functionality out of signals.</p>
<p>There's a lot of interesting data in this structure, including
        information about the process that sent the signal, and about the
        cause of the signal. Here is a detailed description of each of the
        fields:</p>
<p>si_signo</p>
<p>The signal number of the signal in question. In your
              signal handler, the first argument provides this information as
              well (and avoids a pointer dereference).si_errno</p>
<p>If nonzero, the error code associated with this signal.
              This field is valid for all signals.si_code</p>
<p>An explanation of why and from where the process received
              the signal (for example, from kill(
              )). We will go over the possible values in the
              following section. This field is valid for all signals.si_pid</p>
<p>For SIGCHLD, the PID of
              the process that terminated.si_uid</p>
<p>For SIGCHLD, the owning
              UID of the process that terminated.si_status</p>
<p>For SIGCHLD, the exit
              status of the process that terminated.si_utime</p>
<p>For SIGCHLD, the user
              time consumed by the process that terminated.si_stime</p>
<p>For SIGCHLD, the system
              time consumed by the process that terminated.si_value</p>
<p>A union of si_int and
              si_ptr.si_int</p>
<p>For signals sent via sigqueue(
              ) (see "Sending a Signal with a Payload" later in this
              chapter), the provided payload typed as an integer.si_ptr</p>
<p>For signals sent via sigqueue(
              ) (see "Sending a Signal with a Payload" later in this
              chapter), the provided payload typed as a void pointer.si_addr</p>
<p>For SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGTRAP, this void pointer contains the address of
              the offending fault. For example, in the case of SIGSEGV, this field contains the
              address of the memory access violation (and is thus often
              NULL!).si_band</p>
<p>For SIGPOLL,
              out-of-band and priority information for the file descriptor
              listed in si_fd.si_fd</p>
<p>For SIGPOLL, the file
              descriptor for the file whose operation completed.</p>
<p>si_value, si_int, and si_ptr are particularly complex topics
        because a process can use them to pass arbitrary data to another
        process. Thus, you can use them to send either a simple integer or a
        pointer to a data structure (note that a pointer is not much help if
        the processes do not share an address space). These fields are
        discussed in the upcoming section "Sending a Signal with a Payload."</p>
<p>POSIX guarantees that only the first three fields are valid for
        all signals. The other fields should be accessed only when handling
        the applicable signal. You should access the si_fd field, for example, only if the signal
        is SIGPOLL.</p>
<empty-line/>
<p><strong>The Wonderful World of si_code</strong></p>
<p>The si_code field indicates
        the cause of the signal. For user-sent signals, the field indicates
        how the signal was sent. For kernel-sent signals, the field indicates
        why the signal was sent.</p>
<p>The following si_code values
        are valid for any signal. They indicate how/why the signal was
        sent:</p>
<p>SI_ASYNCIO</p>
<p>The signal was sent due to the completion of asynchronous
              I/O (see Chapter 5).SI_KERNEL</p>
<p>The signal was raised by the kernel.SI_MESGQ</p>
<p>The signal was sent due to a state change of a POSIX
              message queue (not covered in this book).SI_QUEUE</p>
<p>The signal was sent by sigqueue(
              ) (see the next section).SI_TIMER</p>
<p>The signal was sent due to the expiration of a POSIX timer
              (see Chapter 10).SI_TKILL</p>
<p>The signal was sent by tkill(
              ) or tgkill( ).
              These system calls are used by threading libraries, and are not
              covered in this book.SI_SIGIO</p>
<p>The signal was sent due to the queuing of SIGIO.SI_USER</p>
<p>The signal was sent by kill(
              ) or raise(
              ).</p>
<p>The following si_code values
        are valid for SIGBUS only. They
        indicate the type of hardware error that occurred:</p>
<p>BUS_ADRALN</p>
<p>The process incurred an alignment error (see Chapter 8 for a discussion of
              alignment).BUS_ADRERR</p>
<p>The process accessed an invalid physical address.BUS_OBJERR</p>
<p>The process caused some other form of hardware
              error.</p>
<p>For SIGCHLD, the following
        values identify what the child did to generate the signal sent to its
        parent:</p>
<p>CLD_CONTINUED</p>
<p>The child was stopped but has resumed.CLD_DUMPED</p>
<p>The child terminated abnormally.CLD_EXITED</p>
<p>The child terminated normally via exit( ).CLD_KILLED</p>
<p>The child was killed.CLD_STOPPED</p>
<p>The child stopped.CLD_TRAPPED</p>
<p>The child hit a trap.</p>
<p>The following values are valid for SIGFPE only. They explain the type of
        arithmetic error that occurred:</p>
<p>FPE_FLTDIV</p>
<p>The process performed a floating-point operation that
              resulted in division by zero.FPE_FLTOVF</p>
<p>The process performed a floating-point operation that
              resulted in an overflow.FPE_FLTINV</p>
<p>The process performed an invalid floating-point
              operation.FPE_FLTRES</p>
<p>The process performed a floating-point operation that
              yielded an inexact or invalid result.FPE_FLTSUB</p>
<p>The process performed a floating-point operation that
              resulted in an out-of-range subscript.FPE_FLTUND</p>
<p>The process performed a floating-point operation that
              resulted in an underflow.FPE_INTDIV</p>
<p>The process performed an integer operation that resulted
              in division by zero.FPE_INTOVF</p>
<p>The process performed an integer operation that resulted
              in an overflow.</p>
<p>The following si_code values
        are valid for SIGILL only. They
        explain the nature of the illegal instruction execution:</p>
<p>ILL_ILLADR</p>
<p>The process attempted to enter an illegal addressing
              mode.ILL_ILLOPC</p>
<p>The process attempted to execute an illegal opcode.ILL_ILLOPN</p>
<p>The process attempted to execute on an illegal
              operand.ILL_PRVOPC</p>
<p>The process attempted to execute a privileged
              opcode.ILL_PRVREG</p>
<p>The process attempted to execute on a privileged
              register.ILL_ILLTRP</p>
<p>The process attempted to enter an illegal trap.</p>
<p>For all of these values, si_addr points to the address of the
        offense.</p>
<p>For SIGPOLL, the following
        values identify the I/O event that generated the signal:</p>
<p>POLL_ERR</p>
<p>An I/O error occurred.POLL_HUP</p>
<p>The device hung up or the socket disconnected.POLL_IN</p>
<p>The file has data available to read.POLL_MSG</p>
<p>A message is available.POLL_OUT</p>
<p>The file is capable of being written to.POLL_PRI</p>
<p>The file has high-priority data available to read.</p>
<p>The following codes are valid for SIGSEGV, describing the two types of invalid
        memory accesses:</p>
<p>SEGV_ACCERR</p>
<p>The process accessed a valid region of memory in an
              invalid way—that is, the process violated memory-access
              permissions.SEGV_MAPERR</p>
<p>The process accessed an invalid region of memory.</p>
<p>For either of these values, si_addr contains the offending
        address.</p>
<p>For SIGTRAP, these two
        si_code values identify the type of
        trap hit:</p>
<p>TRAP_BRKPT</p>
<p>The process hit a break point.TRAP_TRACE</p>
<p>The process hit a trace trap.</p>
<p>Note that si_code is a value
        field and not a bit field.</p>
<empty-line/>
<p><strong>Sending a Signal with a Payload</strong></p>
<p>As we saw in the previous section, signal handlers registered with
      the SA_SIGINFO flag are passed a
      siginfo_t parameter. This structure
      contains a field named si_value,
      which is an optional payload passed from the signal generator to the
      signal receiver.</p>
<p>The sigqueue( ) function,
      defined by POSIX, allows a process to send a signal with this
      payload:<strong>#include &lt;signal.h&gt;

int sigqueue (pid_t pid,
              int signo,
              const union sigval value);</strong></p>
<p>sigqueue( ) works similarly to
      kill( ). On success, the signal
      identified by signo is queued to the
      process or process group identified by pid, and the function returns 0. The signal's payload is given by value, which is a union of an integer and a void pointer:<strong>union sigval {
        int sival_int;
        void *sival_ptr;
};</strong></p>
<p>On failure, the call returns −1, and sets errno to one of the following:</p>
<p>EINVAL</p>
<p>The signal specified by signo is invalid.EPERM</p>
<p>The invoking process lacks sufficient permissions to send a
            signal to any of the requested processes. The permissions required
            to send a signal are the same as with kill( ) (see the section "Sending a Signal" earlier in this chapter).ESRCH</p>
<p>The process or process group denoted by pid does not exist or, in the case of a
            process, is a zombie.</p>
<p>As with kill( ), you may pass
      the null signal (0) for signo to test permissions.</p>
<empty-line/>
<p><strong>Example</strong></p>
<p>This example sends the process with pid 1722 the SIGUSR2 signal with a payload of an integer
        that has the value 404:sigval value;
int ret;

value.sival_int = 404;

ret = sigqueue (1722, SIGUSR2, value);
if (ret)
        perror ("sigqueue");</p>
<p>If process 1722 handles SIGUSR2 with an SA_SIGINFO handler, it will find signo set to SIGUSR2, si-&gt;si_int set to 404, and si-&gt;si_code set to SI_QUEUE.</p>
<empty-line/>
<p><strong>Conclusion</strong></p>
<p>Signals have a bad reputation among many Unix programmers. They
      are an old, antiquated mechanism for kernel-to-user communication and
      are, at best, a primitive form of IPC. In a world of multithreading
      programs and event loops, signals are often out of place.</p>
<p>Nevertheless, for better or worse, we need them. Signals are the
      only way to receive many notifications (such as the notification of an
      illegal opcode execution) from the kernel. Additionally, signals are how
      Unix (and thus Linux) terminates processes, and manages the parent/child
      relationship. Thus, we are stuck with them.</p>
<p>One of the primary reasons for signals' derogation is that it is
      hard to write a proper signal handler that is safe from reentrancy
      concerns. If you keep your handlers simple, however, and use only the
      functions listed in Table 9-2 (if you use any!),
      they should be safe.</p>
<p>Another chink in signals' armor is that many programmers still use
      signal( ) and kill( ), rather than sigaction( ) and sigqueue( ), for signal management. As the
      last two sections have shown, signals are significantly more powerful
      and expressive when SA_SIGINFO-style
      signal handlers are used. Although I myself am no fan of signals—I would
      love to see signals replaced by a file-descriptor-based pollable
      mechanism, which is actually something that's under consideration for
      future Linux kernel versions—working around their flaws and using
      Linux's advanced signal interfaces eases much of the pain (if not the
      whining).</p>
<empty-line/><empty-line/>
<p><sup>[40] </sup><sup>*</sup> Only the Alpha architecture
            defines this signal. On all other machine architectures, this
            signal does not exist.</p>
<p><sup>[41] </sup><sup>*</sup> Thus, pause( ) is only the second-simplest
            system call. The joint winners are getpid( ) and gettid( ), which are each only one
            line.</p>
</section>
<section>
<empty-line/>
<p><strong>Chapter 10. Time</strong></p>
<p>Time serves various purposes in a modern operating system, and many
    programs need to keep track of it. The kernel measures the passage of time
    in three different ways:</p>
<p><emphasis>Wall time (or real time)</emphasis></p>
<p>This is the actual time and date in the real world—that is,
          the time as one would read it on a clock on the wall. Processes use
          the wall time when interfacing with the user or timestamping an
          event.<emphasis>Process time</emphasis></p>
<p>This is the time that a process has consumed, either directly
          in user-space code, or indirectly via the kernel working on the
          process' behalf. Processes care about this form of time mostly for
          profiling and statistics—measuring how long a given operation took,
          for example. Wall time is misleading for measuring process behavior
          because, given the multitasking nature of Linux, the process time
          can be much less than the wall time for a given operation. A process
          can also spend significant cycles waiting for I/O (particularly
          keyboard input).<emphasis>Monotonic time</emphasis></p>
<p>This time source is strictly linearly increasing. Most
          operating systems, Linux included, use the system's uptime (time
          since boot). The wall time can change—for example, because the user
          may set it, and because the system continually adjusts the time for
          skew—and additional imprecision can be introduced through, say, leap
          seconds. The system uptime, the other hand, is a deterministic and
          unchangeable representation of time. The important aspect of a
          monotonic time source is not the current value, but the guarantee
          that the time source is strictly linearly increasing, and thus
          useful for calculating the difference in time between two
          samplings.</p>
<p>Monotonic time, therefore, is suited for calculating relative time,
    whereas wall time is ideal for measuring absolute time.</p>
<p>These three measurements of time may be represented in one of two
    formats:</p>
<p><emphasis>Relative time</emphasis></p>
<p>This is a value relative to some benchmark, such as the
          current instant: for example, <emphasis>5 seconds from
          now</emphasis>, or <emphasis>10 minutes ago</emphasis>.<emphasis>Absolute time</emphasis></p>
<p>This represents time without any such benchmark: say,
          <emphasis>noon on 25 March 1968</emphasis>.</p>
<p>Both relative and absolute forms of time have uses. A process might
    need to cancel a request in 500 milliseconds, refresh the screen 60 times
    per second, or note that 7 seconds have elapsed since an operation began.
    All of these call for relative time calculations. Conversely, a calendar
    application might save the date for the user's toga party as 8 February, a
    filesystem will write out the full date and time when a file is created
    (rather than "five seconds ago"), and the user's clock displays the
    Gregorian date, not the number of seconds since the system booted.</p>
<p>Unix systems represent absolute time as the number of elapsed
    seconds since the <emphasis>epoch</emphasis>, which is defined as 00:00:00
    UTC on the morning of 1 January 1970. UTC (Universal Time, Coordinated) is
    roughly GMT (Greenwich Mean Time) or Zulu time. Curiously, this means that
    in Unix, even absolute time is, at a low level, relative. Unix introduces
    a special data type for storing "seconds since the epoch," which we will
    look at in the next section.</p>
<p>Operating systems track the progression of time via the
    <emphasis>software clock</emphasis>, a clock maintained by the kernel in
    software. The kernel instantiates a periodic timer, known as the
    <emphasis>system timer</emphasis>, that pops at a specific frequency. When
    a timer interval ends, the kernel increments the elapsed time by one unit,
    known as a <emphasis>tick</emphasis> or a <emphasis>jiffy</emphasis>. The
    counter of elapsed ticks is known as the <emphasis>jiffies
    counter</emphasis>. Previously, a 32-bit value, jiffies is a 64-bit
    counter as of the 2.6 Linux kernel.<sup>[42]</sup></p>
<p>On Linux, the frequency of the system timer is called HZ, because a preprocessor define of the same
    name represents it. The value of HZ is
    architecture-specific, and not part of the Linux ABI—that is, programs
    cannot depend on or expect any given value. Historically, the x86
    architecture used a value of 100,
    meaning the system timer ran 100 times per second (that is, the system
    timer had a frequency of 100 hertz). This gave each jiffy a value of 0.01
    seconds—1/HZ seconds. With the release
    of the 2.6 Linux kernel, the kernel developers bumped the value of
    HZ to 1000, giving each jiffy a value of 0.001
    seconds. However, in version 2.6.13 and later, HZ is 250,
    providing each jiffy a value of 0.004 seconds.<sup>[43]</sup> There is a tradeoff inherent in the value of HZ: higher values provide higher resolution, but
    incur greater timer overhead.</p>
<p>Although processes should not rely on any fixed value of HZ, POSIX defines a mechanism for determining
    the system timer frequency at runtime:long hz;

hz = sysconf (_SC_CLK_TCK);
if (hz == −1)
        perror ("sysconf"); /* should never occur */</p>
<p>This interface is useful when a program wants to determine the
    resolution of the system's timer, but it is not needed for converting
    system time values to seconds because most POSIX interfaces export
    measurements of time that are already converted, or that are scaled to a
    fixed frequency, independent of HZ.
    Unlike HZ, this fixed frequency is part
    of the system ABI; on x86, the value is 100. POSIX functions that return time in terms
    of clock ticks use CLOCKS_PER_SEC to
    represent the fixed frequency.</p>
<p>Occasionally, events conspire to turn off a computer. Sometimes,
    computers are even unplugged; yet, upon boot, they have the correct time.
    This is because most computers have a battery-powered <emphasis>hardware
    clock</emphasis> that stores the time and date while the computer is off.
    When the kernel boots, it initializes its concept of the current time from
    the hardware clock. Likewise, when the user shuts down the system, the
    kernel writes the current time back to the hardware clock. The system's
    administrator may synchronize time at other points via the
    <emphasis>hwclock</emphasis> command.</p>
<p>Managing the passage of time on a Unix system involves several
    tasks, only some of which any given process is concerned with: they
    include setting and retrieving the current wall time, calculating elapsed
    time, sleeping for a given amount of time, performing high-precision
    measurements of time, and controlling timers. This chapter covers this
    full range of time-related chores. We'll begin by looking at the data
    structures with which Linux represents time.</p>
<empty-line/>
<p><strong>Time's Data Structures</strong></p>
<p>As Unix systems evolved, implementing their own interfaces for
      managing time, multiple data structures came to represent the seemingly
      simple concept of time. These data structures range from the simple
      integer to various multifield structures. We'll cover them here before
      we dive into the actual interfaces.</p>
<empty-line/>
<p><strong>The Original Representation</strong></p>
<p>The simplest data structure is time_t, defined in the header &lt;time.h&gt;. The intention was for
        time_t to be an opaque type.
        However, on most Unix systems—Linux included—the type is a simple
        typedef to the C long
        type:typedef long time_t;</p>
<p>time_t represents the number
        of elapsed seconds since the epoch. "That won't last long before
        overflowing!" is a typical response. In fact, it will last longer than
        you might expect, but it indeed will overflow while plenty of Unix
        systems are still in use. With a 32-bit long type, time_t can represent up to 2,147,483,647
        seconds past the epoch. This suggests that we will have the Y2K mess
        all over again—in <emphasis>2038</emphasis>! With luck, however, come
        22:14:07 on Monday, 18 January 2038, most systems and software will be
        64-bit.</p>
<empty-line/>
<p><strong>And Now, Microsecond Precision</strong></p>
<p>Another issue with time_t is
        that a lot can happen in a single second. The timeval structure extends time_t to add microsecond precision. The
        header &lt;sys/time.h&gt; defines
        this structure as follows:<strong>#include &lt;sys/time.h&gt;

struct timeval {
        time_t       tv_sec;     /* seconds */
        suseconds_t  tv_usec;    /* microseconds */
};</strong></p>
<p>tv_sec measures seconds, and
        tv_usec measures microseconds. The
        confusing suseconds_t is normally a
        typedef to an integer type.</p>
<empty-line/>
<p><strong>Even Better: Nanosecond Precision</strong></p>
<p>Not content with microsecond resolution, the timespec structure ups the ante to
        nanoseconds. The header &lt;time.h&gt; defines this structure as
        follows:<strong>#include &lt;time.h&gt;

struct timespec {
        time_t  tv_sec;       /* seconds */
        long    tv_nsec;      /* nanoseconds */
};</strong></p>
<p>Given the choice, interfaces prefer nanosecond to microsecond
        resolution.<sup>[44]</sup> Consequently, since the introduction of the timespec structure, most time-related
        interfaces have switched to it, and thus have gained greater
        precision. However, as we will see, one important function still uses
        timeval.</p>
<p>In practice, neither structure usually offers the stated
        precision because the system timer is not providing nanosecond or even
        microsecond resolution. Nonetheless, it's preferable to have the
        resolution available in the interface so it can accommodate whatever
        resolution the system does offer.</p>
<empty-line/>
<p><strong>Breaking Down Time</strong></p>
<p>Some of the functions that we will cover convert between Unix
        time and strings, or programmatically build a string representing a
        given date. To facilitate this process, the C standard provides the
        tm structure for representing
        "broken-down" time in a more human-readable format. This structure is
        also defined in &lt;time.h&gt;:<strong>#include &lt;time.h&gt;

struct tm {
        int tm_sec;           /* seconds */
        int tm_min;           /* minutes */
        int tm_hour;          /* hours */
        int tm_mday;          /* the day of the month */
        int tm_mon;           /* the month */
        int tm_year;          /* the year */
        int tm_wday;          /* the day of the week */
        int tm_yday;          /* the day in the year */
        int tm_isdst;         /* daylight savings time? */
#ifdef _BSD_SOURCE
        long tm_gmtoff;       /* time zone's offset from GMT */
        const char *tm_zone;  /* time zone abbreviation */
#endif /* _BSD_SOURCE */
};</strong></p>
<p>The tm structure makes it
        easier to tell whether a time_t
        value of, say, 314159 is a Sunday
        or a Saturday (it is the former). In terms of space, it is obviously a
        poor choice for representing the date and time, but it is handy for
        converting to and from user-oriented values.</p>
<p>The fields are as follows:</p>
<p>tm_sec</p>
<p>The number of seconds after the minute. This value
              normally ranges from 0 to
              59, but it can be as high as
              61 to indicate up to two leap
              seconds.tm_min</p>
<p>The number of minutes after the hour. This value ranges
              from 0 to 59.tm_hour</p>
<p>The number of hours after midnight. This value ranges from
              0 to 23.tm_mday</p>
<p>The day of the month. This value ranges from 0 to 31. POSIX does not specify the value
              0; however, Linux uses it to
              indicate the last day of the preceding month.tm_mon</p>
<p>The number of months since January. This value ranges from
              0 to 11.tm_year</p>
<p>The number of years since 1900.tm_wday</p>
<p>The number of days since Sunday. This value ranges from
              0 to 6.tm_yday</p>
<p>The number of days since 1 January. This value ranges from
              0 to 365.tm_isdst</p>
<p>A special value indicating whether daylight savings time
              (DST) is in effect at the time described by the other fields. If
              the value is positive, DST is in effect. If it is 0, DST is not in effect. If the value
              is negative, the state of DST is unknown.tm_gmtoff</p>
<p>The offset in seconds of the current time zone from
              Greenwich Mean Time. This field is present only if _BSD_SOURCE is defined before
              including &lt;time.h&gt;.tm_zone</p>
<p>The abbreviation for the current time zone—for example,
              EST. This field is present
              only if _BSD_SOURCE is
              defined before including &lt;time.h&gt;.</p>
<empty-line/>
<p><strong>A Type for Process Time</strong></p>
<p>The type clock_t represents
        clock ticks. It is an integer type, often a long. Depending on the interface, the ticks
        that clock_t signify the system's
        actual timer frequency (HZ) or
        CLOCKS_PER_SEC.</p>
<empty-line/>
<p><strong>POSIX Clocks</strong></p>
<p>Several of the system calls discussed in this chapter utilize
      <emphasis>POSIX clocks</emphasis>, a standard for implementing and
      representing time sources. The type clockid_t represents a specific POSIX clock,
      four of which Linux supports:</p>
<p>CLOCK_MONOTONIC</p>
<p>A monotonically increasing clock that is not settable by any
            process. It represents the elapsed time since some unspecified
            starting point, such as system boot.CLOCK_PROCESS_CPUTIME_ID</p>
<p>A high-resolution, per-process clock available from the
            processor. For example, on the i386 architecture, this clock uses
            the timestamp counter (TSC) register.CLOCK_REALTIME</p>
<p>The system-wide real time (wall time) clock. Setting this
            clock requires special privileges.CLOCK_THREAD_CPUTIME_ID</p>
<p>Similar to the per-process clock, but unique to each thread
            in a process.</p>
<p>POSIX defines all four of these time sources, but it requires only
      CLOCK_REALTIME. Therefore, while
      Linux reliably provides all four clocks, portable code should rely only
      on CLOCK_REALTIME.</p>
<empty-line/>
<p><strong>Time Source Resolution</strong></p>
<p>POSIX defines the function clock_getres( ) for obtaining the resolution
        of a given time source:<strong>#include &lt;time.h&gt;

int clock_getres (clockid_t clock_id,
                  struct timespec *res);</strong></p>
<p>A successful call to clock_getres(
        ) stores the resolution of the clock specified by clock_id in res, if it is not NULL, and returns 0. On failure, the function returns −1, and sets errno to one of the following two error
        codes:</p>
<p>EFAULT</p>
<p>res is an invalid
              pointer.EINVAL</p>
<p>clock_id is not a valid
              time source on this system.</p>
<p>The following example outputs the resolution of the four time
        sources discussed in the previous section:clockid_t clocks[] = {
        CLOCK_REALTIME,
        CLOCK_MONOTONIC,
        CLOCK_PROCESS_CPUTIME_ID,
        CLOCK_THREAD_CPUTIME_ID,
        (clockid_t) −1 };
int i;


for (i = 0; clocks[i] != (clockid_t) −1; i++) {
        struct timespec res;
        int ret;


        ret = clock_getres (clocks[i], &amp;res);
        if (ret)
                perror ("clock_getres");
        else
                printf ("clock=%d sec=%ld nsec=%ld\n",
                        clocks[i], res.tv_sec, res.tv_nsec);
}</p>
<p>On a modern x86 system, the output resembles the
        following:clock=0 sec=0 nsec=4000250
clock=1 sec=0 nsec=4000250
clock=2 sec=0 nsec=1
clock=3 sec=0 nsec=1</p>
<p>Note that 4,000,250 nanoseconds is 4 milliseconds, which is
        0.004 seconds. In turn, 0.004 seconds is the resolution of the x86
        system clock given an HZ value of
        250, as we discussed in the first
        section of this chapter. Thus, we see that both CLOCK_REALTIME and CLOCK_MONOTONIC are tied to jiffies, and the
        resolution provided by the system timer. Conversely, both CLOCK_PROCESS_CPUTIME_ID and CLOCK_PROCESS_CPUTIME_ID utilize a
        higher-resolution time source—on this x86 machine, the TSC, which we
        see provides nanosecond resolution.</p>
<p>On Linux (and most other Unix systems), all of the functions
        that use POSIX clocks require linking the resulting object file with
        <emphasis>librt</emphasis>. For example, if compiling the previous
        snippet into a complete executable, you might use the following
        command:$ gcc -Wall -W -O2 -lrt -g -o snippet snippet.c</p>
<empty-line/>
<p><strong>Getting the Current Time of Day</strong></p>
<p>Applications have several reasons for desiring the current time
      and date: to display it to the user, to calculate relative or elapsed
      time, to timestamp an event, and so on. The simplest and historically
      most common way of obtaining the current time is the time( ) function:<strong>#include &lt;time.h&gt;

time_t time (time_t *t);</strong></p>
<p>A call to time( ) returns the
      current time represented as the number of seconds elapsed since the
      epoch. If the parameter t is not
      NULL, the function also writes the
      current time into the provided pointer.</p>
<p>On error, the function returns −1 (typecast to a time_t), and sets errno appropriately. The only possible error
      is EFAULT, noting that t is an invalid pointer.</p>
<p>For example:time_t t;

printf ("current time: %ld\n", (long) time (&amp;t));
printf ("the same value: %ld\n", (long) t);</p>
<p><strong>A Naïve Approach to Time</strong></p>
<p>time_t's representation of
        "seconds elapsed since the epoch" is not the actual number of seconds
        that have passed since that fateful moment in time. The Unix
        calculation assumes leap years are all years divisible by four, and
        ignores leap seconds altogether. The point of the time_t representation is not that it is
        accurate, but that it is consistent—and it is.</p>
<empty-line/>
<p><strong>A Better Interface</strong></p>
<p>The function gettimeofday( )
        extends time( ) by offering
        microsecond resolution:<strong>#include &lt;sys/time.h&gt;

int gettimeofday (struct timeval *tv,
                  struct timezone *tz);</strong></p>
<p>A successful call to gettimeofday(
        ) places the current time in the timeval structure pointed at by tv, and returns 0. The timezone structure and the tz parameter are obsolete; neither should be
        used on Linux. Always pass NULL for
        tz.</p>
<p>On failure, the call returns −1, and sets errno to EFAULT; this is the only possible error,
        signifying that tv or tz is an invalid pointer.</p>
<p>For example:struct timeval tv;
int ret;

ret = gettimeofday (&amp;tv, NULL);
if (ret)
        perror ("gettimeofday");
else
        printf ("seconds=%ld useconds=%ld\n",
                (long) tv.sec, (long) tv.tv_usec);</p>
<p>The timezone structure is
        obsolete because the kernel does not manage the time zone, and
        <emphasis>glibc</emphasis> refuses to use the timezone structure's tz_dsttime field. We will look at
        manipulating the time zone in a subsequent section.</p>
<empty-line/>
<p><strong>An Advanced Interface</strong></p>
<p>POSIX provides the clock_gettime(
        ) interface for obtaining the time of a specific time
        source. More useful, however, is that the function allows for
        nanosecond precision:<strong>#include &lt;time.h&gt;

int clock_gettime (clockid_t clock_id,
                   struct timespec *ts);</strong></p>
<p>On success, the call returns 0, and stores the current time of the time
        source specified by clock_id in
        ts. On failure, the call returns
        −1, and sets errno to one of the following:</p>
<p>EFAULT</p>
<p>ts is an invalid
              pointer.EINVAL</p>
<p>clock_id is an invalid
              time source on this system.</p>
<p>The following example obtains the current time of all four of
        the standard time sources:clockid_t clocks[] = {
        CLOCK_REALTIME,
        CLOCK_MONOTONIC,
        CLOCK_PROCESS_CPUTIME_ID,
        CLOCK_THREAD_CPUTIME_ID,
        (clockid_t) −1 };
int i;

for (i = 0; clocks[i] != (clockid_t) −1; i++) {
        struct timespec ts;
        int ret;

        ret = clock_gettime (clocks[i], &amp;ts);
        if (ret)
                perror ("clock_gettime");
        else
                printf ("clock=%d sec=%ld nsec=%ld\n",
                        clocks[i], ts.tv_sec, ts.tv_nsec);
}</p>
<empty-line/>
<p><strong>Getting the Process Time</strong></p>
<p>The times( ) system call
        retrieves the process time of the running process and its children, in
        clock ticks:<strong>#include &lt;sys/times.h&gt;

struct tms {
        clock_t tms_utime;   /* user time consumed */
        clock_t tms_stime;   /* system time consumed */
        clock_t tms_cutime;  /* user time consumed by children */
        clock_t tms_cstime;  /* system time consumed by children */
};

clock_t times (struct tms *buf);</strong></p>
<p>On success, the call fills the provided tms structure pointed at by buf with the process time consumed by the
        invoking process and its children. The reported times are broken into
        user and system time. <emphasis>User time</emphasis> is the time spent
        executing code in user space. <emphasis>System time</emphasis> is the
        time spent executing code in kernel space—for example, during a system
        call, or a page fault. The reported times for each child are included
        only after the child terminates, and the parent invokes waitpid( ) (or a related function) on the
        process. The call returns the number of clock ticks, monotonically
        increasing, since an arbitrary point in the past. This reference point
        was once system boot—thus, the times(
        ) function returned the system uptime, in ticks—but the
        reference point is now about 429 million seconds before system boot.
        The kernel developers implemented this change to catch kernel code
        that could not handle the system uptime wrapping around and hitting
        zero. The absolute value of this function's return is thus worthless;
        relative changes between two invocations, however, continue to have
        value.</p>
<p>On failure, the call returns −1, and sets errno as appropriate. On Linux, the only
        possible error code is EFAULT,
        signifying that buf is an invalid
        pointer.</p>
<empty-line/>
<p><strong>Setting the Current Time of Day</strong></p>
<p>While previous sections have described how to retrieve times,
      applications occasionally also need to set the current time and date to
      a provided value. This is almost always handled by a utility designed
      solely for this purpose, such as <emphasis>date</emphasis>.</p>
<p>The time-setting counterpart to time(
      ) is stime( ):<strong>#define _SVID_SOURCE
#include &lt;time.h&gt;

int stime (time_t *t);</strong></p>
<p>A successful call to stime( )
      sets the system time to the value pointed at by t and returns 0. The call requires that the invoking user
      have the CAP_SYS_TIME capability.
      Generally, only the root user has this capability.</p>
<p>On failure, the call returns −1, and sets errno to EFAULT, signifying that t was an invalid pointer, or EPERM, signifying that the invoking user did
      not possess the CAP_SYS_TIME
      capability.</p>
<p>Usage is very simple:time_t t = 1;
int ret;

/* set time to one second after the epoch */
ret = stime (&amp;t);
if (ret)
        perror ("stime");</p>
<p>We will look at functions that make it easier to convert
      human-readable forms of time to a time_t in a subsequent section.</p>
<empty-line/>
<p><strong>Setting Time with Precision</strong></p>
<p>The counterpart to gettimeofday(
        ) is settimeofday(
        ):<strong>#include &lt;sys/time.h&gt;

int settimeofday (const struct timeval *tv,
                  const struct timezone *tz);</strong></p>
<p>A successful call to settimeofday(
        ) sets the system time as given by tv and returns 0. As with gettimeofday( ), passing NULL for tz is the best practice. On failure, the
        call returns −1, and sets errno to one of the following:</p>
<p>EFAULT</p>
<p>tv or tz points at an invalid region of
              memory.EINVAL</p>
<p>A field in one of the provided structures is
              invalid.EPERM</p>
<p>The calling process lacks the CAP_SYS_TIME capability.</p>
<p>The following example sets the current time to a Saturday in the
        middle of December 1979:struct timeval tv = { .tv_sec  = 31415926,
                      .tv_usec = 27182818 };
int ret;

ret = settimeofday (&amp;tv, NULL);
if (ret)
        perror ("settimeofday");</p>
<empty-line/>
<p><strong>An Advanced Interface for Setting the Time</strong></p>
<p>Just as clock_gettime( )
        improves on gettimeofday( ),
        clock_settime( ) obsolesces
        settimeofday( ):<strong>#include &lt;time.h&gt;

int clock_settime (clockid_t clock_id,
                   const struct timespec *ts);</strong></p>
<p>On success, the call returns 0, and the time source specified by clock_id is set to the time specified by
        ts. On failure, the call returns
        −1, and sets errno to one of the following:</p>
<p>EFAULT</p>
<p>ts is an invalid
              pointer.EINVAL</p>
<p>clock_id is an invalid
              time source on this system.EPERM</p>
<p>The process lacks the needed permissions to set the
              specified time source, or the specified time source may not be
              set.</p>
<p>On most systems, the only settable time source is CLOCK_REALTIME. Thus, the only advantage of
        this function over settimeofday( )
        is that it offers nanosecond precision (along with not having to deal
        with the worthless timezone
        structure).</p>
<empty-line/>
<p><strong>Playing with Time</strong></p>
<p>Unix systems and the C language provide a family of functions for
      converting between broken-down time (an ASCII string representation of
      time) and time_t. asctime( ) converts a tm structure—broken-down time—to an ASCII
      string:<strong>#include &lt;time.h&gt;

char * asctime (const struct tm *tm);
char * asctime_r (const struct tm *tm, char *buf);</strong></p>
<p>It returns a pointer to a statically allocated string. A
      subsequent call to any time function may overwrite this string; asctime( ) is not thread-safe.</p>
<p>Thus, multithreaded programs (and developers who loathe poorly
      designed interfaces) should use asctime_r(
      ). Instead of returning a pointer to a statically allocated
      string, this function uses the string provided via buf, which must be at least 26 characters in
      length.</p>
<p>Both functions return NULL in
      the case of error.</p>
<p>mktime( ) also converts a
      tm structure, but it converts it to a
      time_t:<strong>#include &lt;time.h&gt;

time_t mktime (struct tm *tm);</strong></p>
<p>mktime( ) also sets the time
      zone via tzset( ), as specified by
      tm. On error, it returns −1 (typecast to a time_t).</p>
<p>ctime( ) converts a time_t to its ASCII representation:<strong>#include &lt;time.h&gt;

char * ctime (const time_t *timep);
char * ctime_r (const time_t *timep, char *buf);</strong></p>
<p>On failure, it returns NULL.
      For example:time_t t = time (NULL);

printf ("the time a mere line ago: %s", ctime (&amp;t));</p>
<p>Note the lack of newline. Perhaps inconveniently, ctime( ) appends a newline to its returned
      string.</p>
<p>Like asctime( ), ctime( ) returns a pointer to a static string.
      As this is not thread-safe, threaded programs should instead use
      ctime_r( ), which operates on the
      buffer provided by buf. The buffer
      must be at least 26 characters in length.</p>
<p>gmtime( ) converts the given
      time_t to a tm structure, expressed in terms of the UTC
      time zone:<strong>#include &lt;time.h&gt;

struct tm * gmtime (const time_t *timep);
struct tm * gmtime_r (const time_t *timep, struct tm *result);</strong></p>
<p>On failure, it returns NULL.</p>
<p>This function statically allocates the returned structure, and,
      again, is thus thread-unsafe. Threaded programs should use gmtime_r( ), which operates on the structure
      pointed at by result.</p>
<p>localtime( ) and localtime_r( ) perform functions akin to
      gmtime( ) and gmtime_r( ), respectively, but they express
      the given time_t in terms of the
      user's time zone:<strong>#include &lt;time.h&gt;

struct tm * localtime (const time_t *timep);
struct tm * localtime_r (const time_t *timep, struct tm *result);</strong></p>
<p>As with mktime( ), a call to
      localtime( ) also calls tzset( ), and initializes the time zone.
      Whether localtime_r( ) performs this
      step is unspecified.</p>
<p>difftime( ) returns the number
      of seconds that have elapsed between two time_t values, cast to a double:<strong>#include &lt;time.h&gt;

double difftime (time_t time1, time_t time0);</strong></p>
<p>On all POSIX systems, time_t is
      an arithmetic type, and difftime( )
      is equivalent to the following, ignoring detection of overflow in the
      subtraction:(double) (time1 - time0)</p>
<p>On Linux, because time_t is an
      integer type, there is no need for the cast to double. To remain portable, however, use
      difftime( ).</p>
<empty-line/>
<p><strong>Tuning the System Clock</strong></p>
<p>Large and abrupt jumps in the wall clock time can wreak havoc on
      applications that depend on absolute time for their operation. Consider
      as an example <emphasis>make</emphasis>, which builds software projects
      as detailed by a <emphasis>Makefile</emphasis>. Each invocation of the
      program does not rebuild entire source trees; if it did, in large
      software projects, a single changed file could result in hours of
      rebuilding. Instead, <emphasis>make</emphasis> looks at the file
      modification timestamps of the source file (say,
      <emphasis>wolf.c</emphasis>) versus the object file
      (<emphasis>wolf.o</emphasis>). If the source file—or any of its
      prerequisites, such as <emphasis>wolf.h</emphasis>—is newer than the
      object file, <emphasis>make</emphasis> rebuilds the source file into an
      updated object file. If the source file is not newer than the object,
      however, no action is taken.</p>
<p>With this in mind, consider what might happen if the user realized
      his clock was off by a couple of hours, and ran
      <emphasis>date</emphasis> to update the system clock. If the user then
      updated and resaved <emphasis>wolf.c</emphasis>, we could have trouble.
      If the user has moved the current time backward,
      <emphasis>wolf.c</emphasis> will look older than
      <emphasis>wolf.o</emphasis>—even though it isn't!—and no rebuild will
      occur.</p>
<p>To prevent such a debacle, Unix provides the adjtime( ) function, which gradually adjusts
      the current time in the direction of a given delta. The intention is for
      background activities such as Network Time Protcol (NTP) daemons, which
      constantly adjust the time in correction of clock skew, to use adjtime( ) to minimize their effects on the
      system:<strong>#define _BSD_SOURCE
#include &lt;sys/time.h&gt;

int adjtime (const struct timeval *delta,
             struct timeval *olddelta);</strong></p>
<p>A successful call to adjtime( )
      instructs the kernel to slowly begin adjusting the time as stipulated by
      delta, and then returns 0. If the time specified by delta is positive, the kernel speeds up the
      system clock by delta until the
      correction is fully applied. If the time specified by delta is negative, the kernel slows down the
      system clock until the correction is applied. The kernel applies all
      adjustments such that the clock is always monotonically increasing and
      never undergoes an abrupt time change. Even with a negative delta, the adjustment will not move the clock
      backward; instead, the clock slows down until the system time converges
      with the corrected time.</p>
<p>If delta is not NULL, the kernel stops processing any
      previously registered corrections. However, the part of the correction
      already made, if any, is maintained. If olddelta is not NULL, any previously registered and yet
      unapplied correction is written into the provided timeval structure. Passing a NULL delta and a valid olddelta allows retrieval of any ongoing
      correction.</p>
<p>The corrections applied by adjtime(
      ) should be small—the ideal use case is NTP, as mentioned
      earlier, which applies small corrections (a handful of seconds). Linux
      maintains minimum and maximum correction thresholds of a few thousand
      seconds in either direction.</p>
<p>On error, adjtime( ) returns
      −1, and sets errno to one of these values:</p>
<p>EFAULT</p>
<p>delta or olddelta is an invalid pointer.EINVAL</p>
<p>The adjustment delineated by delta is too large or too small.EPERM</p>
<p>The invoking user does not possess the CAP_SYS_TIME capability.</p>
<p>RFC 1305 defines a significantly more powerful and correspondingly
      more complex clock-adjustment algorithm than the gradual correction
      approach undertaken by adjtime( ).
      Linux implements this algorithm with the adjtimex( ) system call:<strong>#include &lt;sys/timex.h&gt;

int adjtimex (struct timex *adj);</strong></p>
<p>A call to adjtimex( ) reads
      kernel time-related parameters into the timex structure pointed at by adj. Optionally, depending on the modes field of this structure, the system call
      may additionally set certain parameters.</p>
<p>The header &lt;sys/timex.h&gt;
      defines the timex structure as
      follows:<strong>struct timex {
        int modes;           /* mode selector */
        long offset;         /* time offset (usec) */
        long freq;           /* frequency offset (scaled ppm) */
        long maxerror;       /* maximum error (usec) */
        long esterror;       /* estimated error (usec) */
        int status;          /* clock status */
        long constant;       /* PLL time constant */
        long precision;      /* clock precision (usec) */
        long tolerance;      /* clock frequency tolerance (ppm) */
        struct timeval time; /* current time */
        long tick;           /* usecs between clock ticks */
};</strong></p>
<p>The modes field is a bitwise OR
      of zero or more of the following flags:</p>
<p>ADJ_OFFSET</p>
<p>Set the time offset via offset.ADJ_FREQUENCY</p>
<p>Set the frequency offset via freq.ADJ_MAXERROR</p>
<p>Set the maximum error via maxerror.ADJ_ESTERROR</p>
<p>Set the estimated error via esterror.ADJ_STATUS</p>
<p>Set the clock status via status.ADJ_TIMECONST</p>
<p>Set the phase-locked loop (PLL) time constant via constant.ADJ_TICK</p>
<p>Set the tick value via tick.ADJ_OFFSET_SINGLESHOT</p>
<p>Set the time offset via offset once, with a simple algorithm,
            like adjtime( ).</p>
<p>If modes is 0, no values are set. Only a user with the
      CAP_SYS_TIME capability may provide a
      nonzero modes value; any user may
      provide 0 for modes, retrieving all of the parameters, but
      setting none of them.</p>
<p>On success, adjtimex( ) returns
      the current clock state, which is one of the following:</p>
<p>TIME_OK</p>
<p>The clock is synchronized.TIME_INS</p>
<p>A leap second will be inserted.TIME_DEL</p>
<p>A leap second will be deleted.TIME_OOP</p>
<p>A leap second is in progress.TIME_WAIT</p>
<p>A leap second just occurred.TIME_BAD</p>
<p>The clock is not synchronized.</p>
<p>On failure, adjtimex( ) returns
      −1, and sets errno to one of the following error
      codes:</p>
<p>EFAULT</p>
<p>adj is an invalid
            pointer.EINVAL</p>
<p>One or more of modes,
            offset, or tick is invalid.EPERM</p>
<p>modes is nonzero, but the
            invoking user does not possess the CAP_SYS_TIME capability.</p>
<p>The adjtimex( ) system call is
      Linux-specific. Applications concerned with portability should prefer
      adjtime( ).</p>
<p>RFC 1305 defines a complex algorithm, so a complete discussion of
      adjtimex( ) is outside the scope of
      this book. For more information, see the RFC.</p>
<empty-line/>
<p><strong>Sleeping and Waiting</strong></p>
<p>Various functions allow a process to sleep (suspend execution) for
      a given amount of time. The first such function, sleep( ), puts the invoking process to sleep
      for the number of seconds specified by seconds:<strong>#include &lt;unistd.h&gt;

unsigned int sleep (unsigned int seconds);</strong></p>
<p>The call returns the number of seconds <emphasis>not</emphasis>
      slept. Thus, a successful call returns 0, but the function may return other values
      between 0 and seconds inclusive (if, say, a signal
      interrupts the nap). The function does not set errno. Most users of sleep( ) do not care about how long the
      process actually slept, and, consequently, do not check the return
      value:sleep (7);        /* sleep seven seconds */</p>
<p>If sleeping the entire specified time is truly a concern, you can
      continue calling sleep( ) with its
      return value, until it returns 0:unsigned int s = 5;

/* sleep five seconds: no ifs, ands, or buts about it */
while ((s = sleep (s)))
        ;</p>
<empty-line/>
<p><strong>Sleeping with Microsecond Precision</strong></p>
<p>Sleeping with whole-second granularity is pretty lame. A second
        is an eternity on a modern system, so programs often want to sleep
        with subsecond resolution. Enter usleep(
        ):<strong>/* BSD version */
#include &lt;unistd.h&gt;

void usleep (unsigned long usec);

/* SUSv2 version */
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;

int usleep (useconds_t usec);</strong></p>
<p>A successful call to usleep(
        ) puts the invoking process to sleep for usec microseconds. Unfortunately, BSD and
        the Single UNIX Specification disagree on the prototype of the
        function. The BSD variant receives an unsigned long, and has no return value. The
        SUS variant, however, defines usleep(
        ) to accept a useconds_t
        type, and return an int. Linux
        follows SUS if _XOPEN_SOURCE is
        defined as 500 or higher. If
        _XOPEN_SOURCE is undefined, or set
        to less than 500, Linux follows
        BSD.</p>
<p>The SUS version returns 0 on
        success, and −1 on error. Valid
        errno values are EINTR, if the nap was interrupted by a
        signal, or EINVAL, if usecs was too large (on Linux, the full
        range of the type is valid, and thus this error will never
        occur).</p>
<p>According to the specification, the useconds_t type is an unsigned integer
        capable of holding values as high as 1,000,000.</p>
<p>Due to the differences between the conflicting prototypes, and
        the fact that some Unix systems may support one or the other, but not
        both, it is wise never to explicitly include the useconds_t type in your code. For maximum
        portability, assume that the parameter is an unsigned int, and do not rely on usleep( )'s return value:void usleep (unsigned int usec);</p>
<p>Usage is then:unsigned int usecs = 200;

usleep (usecs);</p>
<p>This works with either variant of the function, and checking for
        errors is still possible:errno = 0;
usleep (1000);
if (errno)
        perror ("usleep");</p>
<p>Most programs, however, do not check for or care about usleep( ) errors.</p>
<empty-line/>
<p><strong>Sleeping with Nanosecond Resolution</strong></p>
<p>Linux deprecates the usleep(
        ) function, replacing it with nanosleep( ), which provides nanosecond
        resolution, and a smarter interface:<strong>#define _POSIX_C_SOURCE 199309
#include &lt;time.h&gt;

int nanosleep (const struct timespec *req,
               struct timespec *rem);</strong></p>
<p>A successful call to nanosleep(
        ) puts the invoking process to sleep for the time specified
        by req, and then returns 0. On error, the call returns −1, and sets errno appropriately. If a signal interrupts
        the sleep, the call can return before the specified time has elapsed.
        In that case, nanosleep( ) returns
        −1, and sets errno to EINTR. If rem is not NULL, the function places the remaining time
        to sleep (the amount of req not
        slept) in rem. The program may then
        reissue the call, passing rem for
        req (as shown later in this
        section).</p>
<p>Here are the other possible errno values:</p>
<p>EFAULT</p>
<p>req or rem is an invalid pointer.EINVAL</p>
<p>One of the fields in req is invalid.</p>
<p>In the basic case, usage is simple:struct timespec req = { .tv_sec = 0,
                        .tv_nsec = 200 };

/* sleep for 200 ns */
ret = nanosleep (&amp;req, NULL);
if (ret)
        perror ("nanosleep");</p>
<p>And here is an example using the second parameter to continue
        the sleep if interrupted:struct timespec req = { .tv_sec = 0,
                        .tv_nsec = 1369 };
struct timespec rem;
int ret;

/* sleep for 1369 ns */
retry:
ret = nanosleep (&amp;req, &amp;rem);
if (ret) {
        if (errno == EINTR) {
                /* retry, with the provided time remaining */
                req.tv_sec = rem.tv_sec;
                req.tv_nsec = rem.tv_nsec;
                goto retry;
        }
        perror ("nanosleep");
}</p>
<p>Finally, here's an alternative approach (perhaps more efficient,
        but less readable) toward the same goal:struct timespec req = { .tv_sec = 1,
                        .tv_nsec = 0 };
struct timespec rem, *a = &amp;req, *b = &amp;rem;

/* sleep for 1s */
while (nanosleep (a, b) &amp;&amp; errno == EINTR) {
        struct timespec *tmp = a;
        a = b;
        b = tmp;
}</p>
<p>nanosleep( ) has several
        advantages over sleep( ) and
        usleep( ):</p>
<p>Nanosecond, as opposed to second or microsecond,
            resolution.</p>
<p>Standardized by POSIX.1b.</p>
<p>Not implemented via signals (the pitfalls of which are
            discussed later).</p>
<p>Despite deprecation, many programs prefer to use usleep( ) rather than nanosleep( )—thankfully, at least, fewer and
        fewer applications are now using sleep(
        ). Because nanosleep( )
        is a POSIX standard, and does not use signals, new programs should
        prefer it (or the interface discussed in the next section) to sleep( ) and usleep( ).</p>
<empty-line/>
<p><strong>An Advanced Approach to Sleep</strong></p>
<p>As with all of the classes of time functions we have thus far
        studied, the POSIX clocks family provides the most advanced sleep
        interface:<strong>#include &lt;time.h&gt;

int clock_nanosleep (clockid_t clock_id,
                     int flags,
                     const struct timespec *req,
                     struct timespec *rem);</strong></p>
<p>clock_nanosleep( ) behaves
        similarly to nanosleep( ). In fact,
        this call:ret = nanosleep (&amp;req, &amp;rem);</p>
<p>is the same as this call:ret = clock_nanosleep (CLOCK_REALTIME, 0, &amp;req, &amp;rem);</p>
<p>The difference lies in the clock_id and flags parameters. The former specifies the
        time source to measure against. Most time sources are valid, although
        you cannot specify the CPU clock of the invoking process (e.g.,
        CLOCK_PROCESS_CPUTIME_ID); doing so
        would make no sense because the call suspends execution of the
        process, and thus the process time stops increasing.</p>
<p>What time source you specify depends on your program's goals for
        sleeping. If you are sleeping until some absolute time value, CLOCK_REALTIME may make the most sense. If
        you are sleeping for a relative amount of time, CLOCK_MONOTONIC definitely is the ideal time
        source.</p>
<p>The flags parameter is either
        TIMER_ABSTIME or 0. If it is TIMER_ABSTIME, the value specified by
        req is treated as absolute, and not
        relative. This solves a potential race condition. To explain the value
        of this parameter, assume that a process, at time T<sub>0</sub>, wants to sleep
        until time T<sub>1</sub>. At T<sub>0</sub>, the process calls
        clock_gettime( ) to obtain the
        current time (T<sub>0</sub>). It then
        subtracts T<sub>0</sub>
        from T<sub>1</sub>,
        obtaining Y, which it passes to
        clock_nanosleep( ). Some amount of
        time, however, will have passed between the moment at which the time
        was obtained, and the moment at which the process goes to sleep.
        Worse, what if the process was scheduled off the processor, incurred a
        page fault, or something similar? There is always a potential race
        condition in between obtaining the current time, calculating the time
        differential, and actually sleeping.</p>
<p>The TIMER_ABSTIME flag
        nullifies the race by allowing a process to directly specify T<sub>1</sub>. The kernel
        suspends the process until the specified time source reaches
        T<sub>1</sub>. If the specified time source's current time
        already exceeds T<sub>1</sub>, the call returns
        immediately.</p>
<p>Let's look at both relative and absolute sleeping. The following
        example sleeps for 1.5 seconds:struct timespec ts = { .tv_sec = 1, .tv_nsec = 500000000 };
int ret;

ret = clock_nanosleep (CLOCK_MONOTONIC, 0, &amp;ts, NULL);
if (ret)
        perror ("clock_nanosleep");</p>
<p>Conversely, the following example sleeps until an absolute value
        of time—which is exactly one second from what the clock_gettime( ) call returns for the
        CLOCK_MONOTONIC time source—is
        reached:struct timespec ts;
int ret;

/* we want to sleep until one second from NOW */
ret = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
if (ret) {
        perror ("clock_gettime");
        return;
}

ts.tv_sec += 1;
printf ("We want to sleep until sec=%ld nsec=%ld\n",
        ts.tv_sec, ts.tv_nsec);
ret = clock_nanosleep (CLOCK_MONOTONIC, TIMER_ABSTIME,
                       &amp;ts, NULL);
if (ret)
        perror ("clock_nanosleep");</p>
<p>Most programs need only a relative sleep because their sleep
        needs are not very strict. Some real-time processes, however, have
        very exact timing requirements, and need the absolute sleep to avoid
        the danger of a potentially devastating race condition.</p>
<empty-line/>
<p><strong>A Portable Way to Sleep</strong></p>
<p>Recall from Chapter 2 our friend
        select( ):<strong>#include &lt;sys/select.h&gt;

int select (int n,
            fd_set *readfds,
            fd_set *writefds,
            fd_set *exceptfds,
            struct timeval *timeout);</strong></p>
<p>As mentioned in that chapter, select(
        ) provides a portable way to sleep with sub-second
        resolution. For a long time, portable Unix programs were stuck with
        sleep( ) for their naptime needs:
        usleep( ) was not widely available,
        and nanosleep( ) was as of yet
        unwritten. Developers discovered that passing select( ) 0 for n, NULL
        for all three of the fd_set
        pointers, and the desired sleep duration for timeout resulted in a portable and efficient
        way to put processes to sleep:struct timeval tv = { .tv_sec = 0,
                      .tv_usec = 757 };

/* sleep for 757 us */
select (0, NULL, NULL, NULL, &amp;tv);</p>
<p>If portability to older Unix systems is a concern, using
        select( ) may be your best
        bet.</p>
<empty-line/>
<p><strong>Overruns</strong></p>
<p>All of the interfaces discussed in this section guarantee that
        they will sleep <emphasis>at least as long as requested</emphasis> (or
        return an error indicating otherwise). They will never return success
        without the requested delay elapsing. It is possible, however, for an
        interval <emphasis>longer</emphasis> than the requested delay to
        pass.</p>
<p>This phenomenon may be due to simple scheduling behavior—the
        requested time may have elapsed, and the kernel may have woken up the
        process on time, but the scheduler may have selected a different task
        to run.</p>
<p>There exists a more insidious cause, however: <emphasis>timer
        overruns</emphasis>. This occurs when the granularity of the timer is
        coarser than the requested time interval. For example, assume the
        system timer ticks in 10 ms intervals, and a process requests a 1 ms
        sleep. The system is able to measure time and respond to time-related
        events (such as waking up a process from sleep) only at 10 ms
        intervals. If, when the process issues the sleep request, the timer is
        1 ms away from a tick, everything will be fine—in 1 ms, the requested
        time (1 ms) will elapse, and the kernel will wake up the process. If,
        however, the timer hits right as the process requests the sleep, there
        won't be another timer tick for 10 ms. Subsequently, the process will
        sleep an extra 9 ms! That is, there will be nine 1 ms overruns. On
        average, a timer with a period of <emphasis>X</emphasis> has an
        overrun rate of <emphasis>X/2</emphasis>.</p>
<p>The use of high-precision time sources, such as those provided
        by POSIX clocks, and higher values for HZ, minimize timer overrun.</p>
<empty-line/>
<p><strong>Alternatives to Sleeping</strong></p>
<p>If possible, you should avoid sleeping. Often, you cannot, and
        that's fine—particularly if your code is sleeping for less than a
        second. Code laced with sleeps, however, in order to "busy-wait" for
        events, is usually of poor design. Code that blocks on a file
        descriptor, allowing the kernel to handle the sleep and wake up the
        process, is better. Instead of the process spinning in a loop until
        the event hits, the kernel can block the process from execution, and
        wake it up only when needed.</p>
<empty-line/>
<p><strong>Timers</strong></p>
<p>Timers provide a mechanism for notifying a process when a given
      amount of time elapses. The amount of time before a timer
      <emphasis>expires</emphasis> is called the <emphasis>delay</emphasis>,
      or the <emphasis>expiration</emphasis>. How the kernel notifies the
      process that the timer has expired depends on the timer. The Linux
      kernel offers several types. We will study them all.</p>
<p>Timers are useful for several reasons. Examples include refreshing
      the screen 60 times per second, or canceling a pending transaction if it
      is still ongoing after 500 milliseconds.</p>
<empty-line/>
<p><strong>Simple Alarms</strong></p>
<p>alarm( ) is the simplest
        timer interface:<strong>#include &lt;unistd.h&gt;

unsigned int alarm (unsigned int seconds);</strong></p>
<p>A call to this function schedules the delivery of a SIGALRM signal to the invoking process after
        seconds of real time have elapsed.
        If a previously scheduled signal was pending, the call cancels the
        alarm, replaces it with the newly requested alarm, and returns the
        number of seconds remaining in the previous alarm. If seconds is 0, the previous alarm, if any, is canceled,
        but no new alarm is scheduled.</p>
<p>Successful use of this function thus also requires registering a
        signal handler for the SIGALRM
        signal. (Signals and signal handlers were covered in the previous
        chapter.) Here is a code snippet that registers a SIGALRM handler, alarm_handler( ), and sets an alarm for five
        seconds:void alarm_handler (int signum)
{
        printf ("Five seconds passed!\n");
}

void func (void)
{
        signal (SIGALRM, alarm_handler);
        alarm (5);

        pause (  );
}</p>
<empty-line/>
<p><strong>Interval Timers</strong></p>
<p><emphasis>Interval timer</emphasis> system calls, which first
        appeared in 4.2BSD, have since been standardized in POSIX, and provide
        more control than alarm(
        ):<strong>#include &lt;sys/time.h&gt;

int getitimer (int which,
               struct itimerval *value);

int setitimer (int which,
               const struct itimerval *value,
               struct itimerval *ovalue);</strong></p>
<p>Interval timers operate like alarm(
        ), but optionally can automatically rearm themselves, and
        operate in one of three distinct modes:</p>
<p>ITIMER_REAL</p>
<p>Measures real time. When the specified amount of real time
              has elapsed, the kernel sends the process a SIGALRM signal.ITIMER_VIRTUAL</p>
<p>Decrements only while the process' user-space code is
              executing. When the specified amount of process time has
              elapsed, the kernel sends the process a SIGVTALRM.ITIMER_PROF</p>
<p>Decrements both while the process is executing, and while
              the kernel is executing on behalf of the process (for example,
              completing a system call). When the specified amount of time has
              elapsed, the kernel sends the process a SIGPROF signal. This mode is usually
              coupled with ITIMER_VIRTUAL,
              so that the program can measure user and kernel time spent by
              the process.</p>
<p>ITIMER_REAL measures the same
        time as alarm( ); the other two
        modes are useful for profiling.</p>
<p>The itimerval structure
        allows the user to specify the amount of time until the timer expires,
        as well as the expiration, if any, with which to rearm the timer upon
        expiration:<strong>struct itimerval {
        struct timeval it_interval;  /* next value */
        struct timeval it_value;     /* current value */
};</strong></p>
<p>Recall from earlier that the timeval structure provides microsecond
        resolution:<strong>struct timeval {
        long tv_sec;   /* seconds */
        long tv_usec;  /* microseconds */
};</strong></p>
<p>setitimer( ) arms a timer of
        type which with the expiration
        specified by it_value. Once the
        time specified by it_value elapses,
        the kernel rearms the timer with the time provided by it_interval. Thus, it_value is the time remaining on the
        current timer. Once it_value
        reaches zero, it is set to it_interval. If the timer expires, and
        it_interval is 0, the timer is not rearmed. Similarly, if
        an active timer's it_value is set
        to 0, the timer is stopped, and not
        rearmed.</p>
<p>If ovalue is not NULL, the previous values for the interval
        timer of type which is
        returned.</p>
<p>getitimer( ) returns the
        current values for the interval timer of type which.</p>
<p>Both functions return 0 on
        success, and −1 on error, in which
        case errno is set to one of the
        following:</p>
<p>EFAULT</p>
<p>value or ovalue is an invalid pointer.EINVAL</p>
<p>which is not a valid
              interval timer type.</p>
<p>The following code snippet creates a SIGALRM signal handler (again, see Chapter 9), and then arms an interval timer with an initial
        expiration of five seconds, followed by a subsequent interval of one
        second:void alarm_handler (int signo)
{
        printf ("Timer hit!\n");
}

void foo (void) {
        struct itimerval delay;
        int ret;

        signal (SIGALRM, alarm_handler);

        delay.it_value.tv_sec = 5;
        delay.it_value.tv_usec = 0;
        delay.it_interval.tv_sec = 1;
        delay.it_interval.tv_usec = 0;
        ret = setitimer (ITIMER_REAL, &amp;delay, NULL);
        if (ret) {
                perror ("setitimer");
                return;
        }

        pause (  );
}</p>
<p>Some Unix systems implement sleep(
        ) and usleep( ) via
        SIGALRM—and, obviously, alarm( ) and setitimer( ) use SIGALRM. Therefore, programmers must be
        careful not to overlap calls to these functions; the results are
        undefined. For the purpose of brief waits, programmers should use
        nanosleep( ), which POSIX dictates
        will not use signals. For timers, programmers should use setitimer( ) <emphasis>or</emphasis>
        alarm( ).</p>
<empty-line/>
<p><strong>Advanced Timers</strong></p>
<p>The most powerful timer interface, not surprisingly, hails from
        the POSIX clocks family.</p>
<p>With POSIX clocks-based timers, the acts of instantiating,
        initializing, and ultimately deleting a timer are separated into three
        different functions: timer_create(
        ) creates the timer, timer_settime(
        ) initializes the timer, and timer_delete( ) destroys it.</p>
<p><strong>Tip</strong></p>
<p>The POSIX clocks family of timer interfaces is undoubtedly the
          most advanced, but also the newest (ergo the least portable), and
          most complicated to use. If simplicity or portability is a prime
          motivator, setitimer( ) is most
          likely a better choice.</p>
<empty-line/>
<p><strong>Creating a timer</strong></p>
<p>To create a timer, use timer_create(
          ):<strong>#include &lt;signal.h&gt;
#include &lt;time.h&gt;

int timer_create (clockid_t clockid,
                  struct sigevent *evp,
                  timer_t *timerid);</strong></p>
<p>A successful call to timer_create(
          ) creates a new timer associated with the POSIX clock
          clockid, stores a unique timer
          identification in timerid, and
          returns 0. This call merely sets
          up the conditions for running the timer; nothing actually happens
          until the timer is armed, as shown in the following section.</p>
<p>The following example creates a new timer keyed off the
          CLOCK_PROCESS_CPUTIME_ID POSIX
          clock, and stores the timer's ID in timer:timer_t timer;
int ret;

ret = timer_create (CLOCK_PROCESS_CPUTIME_ID,
                    NULL,
                    &amp;timer);
if (ret)
        perror ("timer_create");</p>
<p>On failure, the call returns −1, timerid is undefined, and the call sets
          errno to one of the
          following:</p>
<p>EAGAIN</p>
<p>The system lacks sufficient resources to complete the
                request.EINVAL</p>
<p>The POSIX clock specified by clockid is invalid.ENOTSUP</p>
<p>The POSIX clock specified by clockid is valid, but the system
                does not support using the clock for timers. POSIX guarantees
                that all implementations support the CLOCK_REALTIME clock for timers.
                Whether other clocks are supported is up to the
                implementation.</p>
<p>The evp parameter, if
          non-NULL, defines the
          asynchronous notification that occurs when the timer expires. The
          header &lt;signal.h&gt; defines
          the structure. Its contents are supposed to be opaque to the
          programmer, but it has at least the following fields:<strong>#include &lt;signal.h&gt;

struct sigevent {
        union sigval sigev_value;
        int sigev_signo;
        int sigev_notify;
        void (*sigev_notify_function)(union sigval);
        pthread_attr_t *sigev_notify_attributes;
};

union sigval {
        int sival_int;
        void *sival_ptr;
};</strong></p>
<p>POSIX clocks-based timers allow much greater control over how
          the kernel notifies the process when a timer expires, allowing the
          process to specify exactly which signal the kernel will emit, or
          even allowing the kernel to spawn a thread, and execute a function
          in response to timer expiration. A process specifies the behavior on
          timer expiration via sigev_notify, which must be one of the
          following three values:</p>
<p>SIGEV_NONE</p>
<p>A "null" notification. On timer expiration, nothing
                happens.SIGEV_SIGNAL</p>
<p>On timer expiration, the kernel sends the process the
                signal specified by sigev_signo. In the signal handler,
                si_value is set to sigev_value.SIGEV_THREAD</p>
<p>On timer expiration, the kernel spawns a new thread
                (within this process), and has it execute sigev_notify_function, passing
                sigev_value as its sole
                argument. The thread terminates when it returns from this
                function. If sigev_notify_attributes is not
                NULL, the provided pthread_attr_t structure defines the
                behavior of the new thread.</p>
<p>If evp is NULL, as it was in our earlier example,
          the timer's expiration notification is set up as if sigev_notify were SIGEV_SIGNAL, sigev_signo were SIGALRM, and sigev_value were the timer's ID. Thus, by
          default, these timers notify in a manner similar to POSIX interval
          timers. Via customization, however, they can do much, much
          more!</p>
<p>The following example creates a timer keyed off CLOCK_REALTIME. When the timer expires,
          the kernel will issue the SIGUSR1
          signal, and set si_value to the
          address storing the timer's ID:struct sigevent evp;
timer_t timer;
int ret;

evp.sigev_value.sival_ptr = &amp;timer;
evp.sigev_notify = SIGEV_SIGNAL;
evp.sigev_signo = SIGUSR1;
ret = timer_create (CLOCK_REALTIME,
                    &amp;evp,
                    &amp;timer);
if (ret)
        perror ("timer_create");</p>
<empty-line/>
<p><strong>Arming a timer</strong></p>
<p>A timer created by timer_create(
          ) is unarmed. To associate it with an expiration and start
          the clock ticking, use timer_settime(
          ):<strong>#include &lt;time.h&gt;

int timer_settime (timer_t timerid,
                   int flags,
                   const struct itimerspec *value,
                   struct itimerspec *ovalue);</strong></p>
<p>A successful call to timer_settime(
          ) arms the timer specified by timerid with the expiration value, which is an itimerspec structure:<strong>struct itimerspec {
        struct timespec it_interval;  /* next value */
        struct timespec it_value;     /* current value */
};</strong></p>
<p>As with setitimer( ),
          it_value specifies the current
          timer expiration. When the timer expires, it_value is refreshed with the value from
          it_interval. If it_interval is 0, the timer is not an interval timer, and
          will disarm once it_value
          expires.</p>
<p>Recall from earlier that the timespec structure provides nanosecond
          resolution:<strong>struct timespec {
        time_t  tv_sec;       /* seconds */
        long    tv_nsec;      /* nanoseconds */
};</strong></p>
<p>If flags is TIMER_ABSTIME, the time specified by
          value is interpreted as absolute
          (as opposed to the default interpretation, where the value is
          relative to the current time). This modified behavior prevents a
          race condition during the steps of obtaining the current time,
          calculating the relative difference between that time, and a desired
          future time, and arming the timer. See the discussion in the earlier
          section, "An Advanced Approach to Sleep" for
          details.</p>
<p>If ovalue is non-NULL, the previous timer expiration is
          saved in the provided itimerspec.
          If the timer was previously disarmed, the structure's members are
          all set to 0.</p>
<p>Using the timer value
          initialized earlier by timer_create(
          ), the following example creates a periodic timer that
          expires every second:struct itimerspec ts;
int ret;

ts.it_interval.tv_sec = 1;
ts.it_interval.tv_nsec = 0;
ts.it_value.tv_sec = 1;
ts.it_value.tv_nsec = 0;

ret = timer_settime (timer, 0, &amp;ts, NULL);
if (ret)
        perror ("timer_settime");</p>
<empty-line/>
<p><strong>Obtaining the expiration of a timer</strong></p>
<p>You can get the expiration time of a timer without resetting
          it, at any time, via timer_gettime(
          ):<strong>#include &lt;time.h&gt;

int timer_gettime (timer_t timerid,
                   struct itimerspec *value);</strong></p>
<p>A successful call to timer_gettime(
          ) stores the expiration time of the timer specified by
          timerid in the structure pointed
          at by value, and returns 0. On failure, the call returns −1, and sets errno to one of the following:</p>
<p>EFAULT</p>
<p>value is an invalid
                pointer.EINVAL</p>
<p>timerid is an invalid
                timer.</p>
<p>For example:struct itimerspec ts;
int ret;

ret = timer_gettime (timer, &amp;ts);
if (ret)
        perror ("timer_gettime");
else {
        printf ("current sec=%ld nsec=%ld\n",
                ts.it_value.tv_sec, ts.it_value.tv_nsec);
        printf ("next sec=%ld nsec=%ld\n",
                ts.it_interval.tv_sec, ts.it_interval.tv_nsec);
}</p>
<empty-line/>
<p><strong>Obtaining the overrun of a timer</strong></p>
<p>POSIX defines an interface for determining how many, if any,
          overruns occurred on a given timer:<strong>#include &lt;time.h&gt;

int timer_getoverrun (timer_t timerid);</strong></p>
<p>On success, timer_getoverrun(
          ) returns the number of additional timer expirations that
          have occurred between the initial expiration of the timer and
          notification to the process—for example, via a signal—that the timer
          expired. For instance, in our earlier example, where a 1 ms timer
          ran for 10 ms, the call would return 9.</p>
<p>If the number of overruns is equal to or greater than DELAYTIMER_MAX, the call returns DELAYTIMER_MAX.</p>
<p>On failure, the function returns −1, and sets errno to EINVAL, the lone error condition,
          signifying that the timer specified by timerid is invalid.</p>
<p>For example:int ret;

ret = timer_getoverrun (timer);
if (ret == −1)
        perror ("timer_getoverrun");
else if (ret == 0)
        printf ("no overrun\n");
else
        printf ("%d overrun(s)\n", ret);</p>
<empty-line/>
<p><strong>Deleting a timer</strong></p>
<p>Deleting a timer is easy:<strong>#include &lt;time.h&gt;

int timer_delete (timer_t timerid);</strong></p>
<p>A successful call to timer_delete(
          ) destroys the timer associated with timerid, and returns 0. On failure, the call returns −1, and errno is set to EINVAL, the lone error condition,
          signifying that timerid is not a
          valid timer.</p>
<empty-line/><empty-line/>
<p><sup>[42] </sup><sup>*</sup> Future versions of the Linux kernel
        may go "tickless," or implement "dynamic ticks," in which case the
        kernel will not keep track of an explicit jiffies value. Instead, all
        time-based kernel operations will execute from dynamically
        instantiated timers rather than from the system timer.</p>
<p><sup>[43] </sup>† HZ is also now a
        compile-time kernel option, with the values 100, 250,
        and 1000 supported on the x86
        architecture. Regardless, user space cannot depend on any particular
        value for HZ.</p>
<p><sup>[44] </sup><sup>*</sup> In addition, the timespec structure dropped the silly
            suseconds_t business, in favor
            of a simple and unpretentious long.</p>
</section>
<section>
<empty-line/>
<p><strong>Appendix A. GCC Extensions to the C Language</strong></p>
<p>The GNU Compiler Collection (GCC) provides many extensions to the C
    language, some of which have proven to be of particular value to system
    programmers. The majority of the additions to the C language that we'll
    cover in this appendix offer ways for programmers to provide additional
    information to the compiler about the behavior and intended use of their
    code. The compiler, in turn, utilizes this information to generate more
    efficient machine code. Other extensions fill in gaps in the C programming
    language, particularly at lower levels.</p>
<p>GCC provides several extensions now available in the latest C
    standard, ISO C99. Some of these extensions function similarly to their
    C99 cousins, but ISO C99 implemented other extensions rather differently.
    New code should use the ISO C99 variants of these features. We won't cover
    such extensions here; we'll discuss only GCC-unique additions.</p>
<empty-line/>
<p><strong>GNU C</strong></p>
<p>The flavor of C supported by GCC is often called GNU C. In the
      1990s, GNU C filled in several gaps in the C language, providing
      features such as complex variables, zero-length arrays, inline
      functions, and named initializers. But after nearly a decade, C was
      finally upgraded, and with the standardization of ISO C99, GNU C
      extensions became less relevant. Nonetheless, GNU C continues to provide
      useful features, and many Linux programmers still use a subset of GNU
      C—often just an extension or two—in their C90- or C99-compliant
      code.</p>
<p>One prominent example of a GCC-specific code base is the Linux
      kernel, which is written strictly in GNU C. Recently, however, Intel has
      invested engineering effort in allowing the Intel C Compiler (ICC) to
      understand the GNU C extensions used by the kernel. Consequently, many
      of these extensions are now growing less GCC-specific.</p>
<empty-line/>
<p><strong>Inline Functions</strong></p>
<p>The compiler copies the entire code of an "inline" function into
      the site where the function is called. Instead of storing the function
      externally and jumping to it whenever it is called, it runs the contents
      of the function directly. Such behavior saves the overhead of the
      function call, and allows for potential optimizations at the call site
      because the compiler can optimize the caller and callee together. This
      latter point is particularly valid if the parameters to the function are
      constant at the call site. Naturally, however, copying a function into
      each and every chunk of code that invokes it can have a detrimental
      effect on code size. Therefore, functions should be inlined only if they
      are small and simple, or are not called in many different
      places.</p>
<p>For many years, GCC has supported the inline keyword, instructing the compiler to
      inline the given function. C99 formalized this keyword:static inline int foo (void) { /* ... */ }</p>
<p>Technically, however, the keyword is merely a hint—a suggestion to
      the compiler to consider inlining the given function. GCC further
      provides an extension for instructing the compiler to
      <emphasis>always</emphasis> inline the designated function:static inline _  _attribute_  _ ((always_inline)) int foo (void) { /* ... */ }</p>
<p>The most obvious candidate for an inline function is a
      preprocessor macro. An inline function in GCC will perform as well as a
      macro, and, additionally, receives type checking. For example, instead
      of this macro:#define max(a,b) ({ a &gt; b ? a : b; })</p>
<p>one might use the corresponding inline function:static inline max (int a, int b)
{
        if (a &gt; b)
                return a;
        return b;
}</p>
<p>Programmers tend to overuse inline functions. Function call
      overhead on most modern architectures—the x86 in particular—is very,
      very low. Only the most worthy of functions should receive
      consideration!</p>
<empty-line/>
<p><strong>Suppressing Inlining</strong></p>
<p>In its most aggressive optimization mode, GCC automatically
      selects functions that appear suitable for inlining and inlines them.
      This is normally a good idea, but sometimes the programmer knows that a
      function will perform incorrectly if inlined. One possible example of
      this is when using _
      _builtin_return_address (discussed later in this appendix). To
      suppress inlining, use the noinline
      keyword:_  _attribute_  _ ((noinline)) int foo (void) { /* ... */ }</p>
<empty-line/>
<p><strong>Pure Functions</strong></p>
<p>A "pure" function is one that has no effects, and whose return
      value reflects only the function's parameters or nonvolatile global
      variables. Any parameter or global variable access must be read-only.
      Loop optimization and subexpression elimination can be applied to such
      functions. Functions are marked as pure via the pure keyword:__attribute_  _ ((pure)) int foo (int val) { /* ... */ }</p>
<p>A common example is strlen( ).
      Given identical inputs, this function's return value is invariant across
      multiple invocations, and thus it can be pulled out of a loop, and
      called just once. For example, consider the following code:/* character by character, print each letter in 'p' in uppercase */
for (i = 0; i &lt; strlen (p); i++)
        printf ("%c", toupper (p[i]));</p>
<p>If the compiler did not know that strlen(
      ) was pure, it might invoke the function with each iteration
      of the loop!</p>
<p>Smart programmers—as well as the compiler, if strlen( ) were marked pure—would write or
      generate code like this:size_t len;

len = strlen (p);
for (i = 0; i &lt; len; i++)
        printf ("%c", toupper (p[i]));</p>
<p>Parenthetically, even smarter programmers (such as this book's
      readers) would write:while (*p)
        printf ("%c", toupper (*p++));</p>
<p>It is illegal, and indeed makes no sense, for a pure function to
      return void, as the return value is
      the sole point of such functions.</p>
<empty-line/>
<p><strong>Constant Functions</strong></p>
<p>A "constant" function is a stricter variant of a pure function.
      Such functions cannot access global variables, and cannot take pointers
      as parameters. Thus, the constant function's return value reflects
      nothing but the passed-by-value parameters. Additional optimizations, on
      top of those possible with pure functions, are possible for such
      functions. Math functions, such as abs(
      ), are examples of constant functions (presuming they don't
      save state or otherwise pull tricks in the name of optimization). A
      programmer marks a function constant via the const keyword:_  _attribute_  _ ((const)) int foo (int val) { /* ... */ }</p>
<p>As with pure functions, it makes no sense for a constant function
      to return void.</p>
<empty-line/>
<p><strong>Functions That Do Not Return</strong></p>
<p>If a function does not return—perhaps because it invariantly calls
      exit( )—the programmer can mark the
      function with the noreturn keyword,
      enlightening the compiler to that fact:_  _attribute_  _ ((noreturn)) void foo (int val) { /* ... */ }</p>
<p>In turn, the compiler can make additional optimizations, with the
      understanding that under no circumstances will the invoked function ever
      return. It does not make sense for such a function to return anything
      but void.</p>
<empty-line/>
<p><strong>Functions That Allocate Memory</strong></p>
<p>If a function returns a pointer that can never alias<sup>[45]</sup> existing memory—almost assuredly because the function just
      allocated fresh memory, and is returning a pointer to it—the programmer
      can mark the function as such with the malloc keyword, and the compiler can in turn
      perform suitable optimizations:_  _attribute_  _ ((malloc)) void * get_page (void)
{
        int page_size;

        page_size = getpagesize (  );
        if (page_size &lt;= 0)
                return NULL;

        return malloc (page_size);
}</p>
<empty-line/>
<p><strong>Forcing Callers to Check the Return Value</strong></p>
<p>Not an optimization, but a programming aid, the warn_unused_result attribute instructs the
      compiler to generate a warning whenever the return value of a function
      is not stored or used in a conditional statement:_  _attribute_  _ ((warn_unused_result)) int foo (void) { /* ... */ }</p>
<p>This allows the programmer to ensure that all callers check and
      handle the return value from a function where the value is of particular
      importance. Functions with important but oft-ignored return values, such
      as read( ), make excellent candidates
      for this attribute. Such functions cannot return void.</p>
<empty-line/>
<p><strong>Marking Functions As Deprecated</strong></p>
<p>The deprecated attribute
      instructs the compiler to generate a warning at the call site whenever
      the function is invoked:_  _attribute_  _ ((deprecated)) void foo (void) { /* ... */ }</p>
<p>This helps wean programmers off deprecated and obsolete
      interfaces.</p>
<empty-line/>
<p><strong>Marking Functions As Used</strong></p>
<p>Occasionally, no code visible to a compiler invokes a particular
      function. Marking a function with the used attribute instructs the compiler that the
      program uses that function, despite appearances that the function is
      never referenced:static _  _attribute_  _ ((used)) void foo (void) { /* ... */ }</p>
<p>The compiler therefore outputs the resulting assembly language,
      and does not display a warning about an unused function. This attribute
      is useful if a static function is invoked only from handwritten assembly
      code. Normally, if the compiler is not aware of any invocation, it will
      generate a warning, and potentially optimize away the function.</p>
<empty-line/>
<p><strong>Marking Functions or Parameters As Unused</strong></p>
<p>The unused attribute tells the
      compiler that the given function or function parameter is unused, and
      instructs it not to issue any corresponding warnings:int foo (long _  _ attribute_  _ ((unused)) value) { /* ... */ }</p>
<p>This is useful if you're compiling with -W or -Wunused, and you want to catch unused
      function parameters, but you occasionally have functions that must match
      a predetermined signature (as is common in event-driven GUI programming
      or signal handlers).</p>
<empty-line/>
<p><strong>Packing a Structure</strong></p>
<p>The packed attribute tells the
      compiler that a type or variable should be packed into memory using the
      minimum amount of space possible, potentially disregarding alignment
      requirements. If specified on a struct or union, all variables therein are so packed. If
      specified on just one variable, only that specific object is
      packed.</p>
<p>The following packs all variables within the structure into the
      minimum amount of space:struct _  _attribute_  _ ((packed)) foo { ... };</p>
<p>As an example, a structure containing a char followed by an int would most likely find the integer aligned
      to a memory address not immediately following the char, but, say, three bytes later. The
      compiler aligns the variables by inserting bytes of unused padding
      between them. A packed structure lacks this padding, potentially
      consuming less memory, but failing to meet architectural alignment
      requirements.</p>
<empty-line/>
<p><strong>Increasing the Alignment of a Variable</strong></p>
<p>As well as allowing packing of variables, GCC also allows
      programmers to specify an alternative minimum alignment for a given
      variable. GCC will then align the specified variable to <emphasis>at
      least</emphasis> this value, as opposed to the minimum required
      alignment dictated by the architecture and ABI. For example, this
      statement declares an integer named beard_length with a minimum alignment of 32
      bytes (as opposed to the typical alignment of 4 bytes on machines with
      32-bit integers):int beard_length _  _attribute_  _ ((aligned (32))) = 0;</p>
<p>Forcing the alignment of a type is generally useful only when
      dealing with hardware that may impose greater alignment requirements
      than the architecture itself, or when you are hand-mixing C and assembly
      code, and you want to use instructions that require specially aligned
      values. One example where this alignment functionality is utilized is
      for storing oft-used variables on processor cache lines to optimize
      cache behavior. The Linux kernel makes use of this technique.</p>
<p>As an alternative to specifying a certain minimum alignment, you
      can ask that GCC align a given type to the largest minimum alignment
      that is ever used for any data type. For example, this instructs GCC to
      align parrot_height to the largest
      alignment it ever uses, which is probably the alignment of a double:short parrot_height _  _attribute_  _ ((aligned)) = 5;</p>
<p>This decision generally involves a space/time tradeoff: variables
      aligned in this manner consume more space, but copying to or from them
      (along with other complex manipulations) may be faster because the
      compiler can issue machine instructions that deal with the largest
      amount of memory.</p>
<p>Various aspects of the architecture or the system's tool chain may
      impose maximum limits on a variable's alignment. For example, on some
      Linux architectures, the linker is unable to recognize alignments beyond
      a rather small default. In that case, an alignment provided using this
      keyword is rounded down to the smallest allowed alignment. For example,
      if you request an alignment of 32, but the system's linker is unable to
      align to more than 8 bytes, the variable will be aligned along an 8 byte
      boundary.</p>
<empty-line/>
<p><strong>Placing Global Variables in a Register</strong></p>
<p>GCC allows programmers to place global variables in a specific
      machine register, where the variables will then reside for the duration
      of the program's execution. GCC calls such variables <emphasis>global
      register variables</emphasis>.</p>
<p>The syntax requires that the programmer specify the machine
      register. The following example uses ebx:register int *foo asm ("ebx");</p>
<p>The programmer must select a variable that is not
      function-clobbered: that is, the selected variable must be usable by
      local functions, saved and restored on function call invocation, and not
      specified for any special purpose by the architecture or operating
      system's ABI. The compiler will generate a warning if the selected
      register is inappropriate. If the register is appropriate—ebx, used in this example, is fine for the x86
      architecture—the compiler will in turn stop using the register
      itself.</p>
<p>Such an optimization can provide huge performance boosts if the
      variable is frequently used. A good example is with a virtual machine.
      Placing the variable that holds, say, the virtual stack frame pointer in
      a register might lead to substantial gains. On the other hand, if the
      architecture is starved of registers to begin with (as the x86
      architecture is), this optimization makes little sense.</p>
<p>Global register variables cannot be used in signal handlers, or by
      more than one thread of execution. They also cannot have initial values
      because there is no mechanism for executable files to supply default
      contents for registers. Global register variable declarations should
      precede any function definitions.</p>
<empty-line/>
<p><strong>Branch Annotation</strong></p>
<p>GCC allows programmers to annotate the expected value of an
      expression—for example, to tell the compiler whether a conditional
      statement is likely to be true or false. GCC, in turn, can then perform
      block reordering, and other optimizations to improve the performance of
      conditional branches.</p>
<p>The GCC syntax for branch notation is horrendously ugly. To make
      branch annotation easier on the eyes, we use preprocessor
      macros:#define likely(x)    _  _builtin_expect (!!(x), 1)
#define unlikely(x)  _  _builtin_expect (!!(x), 0)</p>
<p>Programmers can mark an expression as likely or unlikely true by
      wrapping it in likely( ) or unlikely( ), respectively.</p>
<p>The following example marks a branch as unlikely true (that is,
      likely to be false):int ret;

ret = close (fd);
if (unlikely (ret))
        perror ("close");</p>
<p>Conversely, the following example marks a branch as likely
      true:const char *home;

home = getenv ("HOME");
if (likely (home))
        printf ("Your home directory is %s\n", home);
else
        fprintf (stderr, "Environment variable HOME not set!\n");</p>
<p>As with inline functions, programmers have a tendency to overuse
      branch annotation. Once you start anointing expressions, you might be
      tempted to mark <emphasis>all</emphasis> expressions. Be careful,
      though—you should mark branches as likely or unlikely only if you know
      <emphasis>a priori</emphasis> and with little doubt that the expressions
      will be true or false <emphasis>nearly all of the time</emphasis> (say,
      with 99 percent certainty). Seldom-occurring errors are good candidates
      for unlikely( ). Bear in mind,
      however, that a false prediction is worse than no prediction at
      all.</p>
<empty-line/>
<p><strong>Getting the Type of an Expression</strong></p>
<p>GCC provides the typeof( )
      keyword to obtain the type of a given expression. Semantically, the
      keyword operates the same as sizeof(
      ). For example, this expression returns the type of whatever
      x points at:typeof (*x)</p>
<p>We can use this to declare an array, y, of those types:typeof (*x) y[42];</p>
<p>A popular use for typeof( ) is
      to write "safe" macros, which can operate on any arithmetic value, and
      evaluate its parameters only once:#define max(a,b) ({          \
        typeof (a) _a = (a); \
        typeof (b) _b = (b); \
       _a &gt; _b ? _a : _b; \
})</p>
<empty-line/>
<p><strong>Getting the Alignment of a Type</strong></p>
<p>GCC provides the keyword _ _alignof_
      _ to obtain the alignment of a given object. The value is
      architecture- and ABI-specific. If the current architecture does not
      have a required alignment, the keyword returns the ABI's recommended
      alignment. Otherwise, the keyword returns the minimum required
      alignment.</p>
<p>The syntax is identical to sizeof(
      ):_  _alignof_  _(int)</p>
<p>Depending on the architecture, this probably returns 4, as 32-bit integers are generally aligned
      along 4 byte boundaries.</p>
<p>The keyword works on lvalues, too. In that case, the returned
      alignment is the minimum alignment of the backing type, not the actual
      alignment of the specific lvalue. If the minimum alignment was changed
      via the aligned attribute (described
      earlier, in "Increasing the Alignment of a Variable"), that change is
      reflected by _ _alignof_ _.</p>
<p>For example, consider this structure:struct ship {
        int year_built;
        char canons;
        int mast_height;
};</p>
<p>along with this code snippet:struct ship my_ship;

printf ("%d\n", _  _alignof_  _(my_ship.canons));</p>
<p>The _ _alignof_ _ in this
      snippet will return 1, even though
      structure padding probably results in canons consuming four bytes.</p>
<empty-line/>
<p><strong>The Offset of a Member Within a Structure</strong></p>
<p>GCC provides a built-in keyword for obtaining the offset of a
      member of a structure within that structure. The offsetof( ) macro, defined in &lt;stddef.h&gt;, is part of the ISO C
      standard. Most definitions are horrid, involving obscene pointer
      arithmetic and code unfit for minors. The GCC extension is simpler and
      potentially faster:#define offsetof(type, member)  _  _builtin_offsetof (type, member)</p>
<p>A call returns the offset of member within type—that is, the number of bytes, starting
      from zero, from the beginning of the structure to that member. For
      example, consider the following structure:struct rowboat {
        char *boat_name;
        unsigned int nr_oars;
        short length;
};</p>
<p>The actual offsets depend on the size of the variables, and the
      architecture's alignment requirements and padding behavior, but on a
      32-bit machine, we might expect calling offsetof( ) on struct
      rowboat and boat_name,
      nr_oars, and length to return 0, 4, and
      8, respectively.</p>
<p>On a Linux system, the offsetof(
      ) macro should be defined using the GCC keyword, and need not
      be redefined.</p>
<empty-line/>
<p><strong>Obtaining the Return Address of a Function</strong></p>
<p>GCC provides a keyword for obtaining the return address of the
      current function, or one of the callers of the current
      function:void * _  _builtin_return_address (unsigned int level)</p>
<p>The parameter level specifies
      the function in the call chain whose address should be returned. A value
      of 0 asks for the return address of
      the current function, a value of 1
      asks for the return address of the caller of the current function, a
      value of 2 asks for
      <emphasis>that</emphasis> function's caller's return address, and so
      on.</p>
<p>If the current function is an inline function, the address
      returned is that of the calling function. If this is unacceptable, use
      the noinline keyword (described
      earlier, in "Suppressing Inlining") to force the
      compiler not to inline the function.</p>
<p>There are several uses for the _
      _builtin_return_address keyword. One is for debugging or
      informational purposes. Another is to unwind a call chain, in order to
      implement introspection, a crash dump utility, a debugger, and so
      on.</p>
<p>Note that some architectures can return only the address of the
      invoking function. On such architectures, a nonzero parameter value can
      result in a random return value. Thus, any parameter other than 0 is nonportable, and should be used only for
      debugging purposes.</p>
<empty-line/>
<p><strong>Case Ranges</strong></p>
<p>GCC allows case statement
      labels to specify a range of values for a single block. The general
      syntax is as follows:case low ... high:</p>
<p>For example:switch (val) {
case 1 ... 10:
        /* ... */
        break;
case 11 ... 20:
        /* ... */
        break;
default:
        /* ... */
}</p>
<p>This functionality is quite useful for ASCII case ranges,
      too:case 'A' ... 'Z':</p>
<p>Note that there should be a space before and after the ellipsis.
      Otherwise, the compiler can become confused, particularly with integer
      ranges. Always do the following:case 4 ... 8:</p>
<p>and never this:case 4...8:</p>
<empty-line/>
<p><strong>Void and Function Pointer Arithmetic</strong></p>
<p>In GCC, addition and subtraction operations are allowed on
      pointers of type void, and pointers
      to functions. Normally, ISO C does not allow arithmetic on such pointers
      because the size of a "void" is a silly concept, and is dependent on
      what the pointer is actually pointing to. To facilitate such arithmetic,
      GCC treats the size of the referential object as one byte. Thus, the
      following snippet advances a by
      one:a++;        /* a is a void pointer */</p>
<p>The option -Wpointer-arith
      causes GCC to generate a warning when these extensions are used.</p>
<empty-line/>
<p><strong>More Portable and More Beautiful in One Fell Swoop</strong></p>
<p>Let's face it, the _ _attribute_
      _ syntax is not pretty. Some of the extensions we've looked at
      in this chapter essentially require preprocessor macros to make their
      use palatable, but all of them can benefit from a sprucing up in
      appearance.</p>
<p>With a little preprocessor magic, this is not hard. Further, in
      the same action, we can make the GCC extensions portable, by defining
      them away in the case of a non-GCC compiler (whatever that is).</p>
<p>To do so, stick the following code snippet in a header, and
      include that header in your source files:#if __GNUC_  _ &gt;= 3
# undef  inline
# define inline         inline __attribute_  _ ((always_inline))
# define __noinline     __attribute_  _ ((noinline))
# define __pure         __attribute_  _ ((pure))
# define __const        __attribute_  _ ((const))
# define __noreturn     __attribute_  _ ((noreturn))
# define __malloc       __attribute_  _ ((malloc))
# define __must_check   __attribute_  _ ((warn_unused_result))
# define __deprecated   __attribute_  _ ((deprecated))
# define __used         __attribute_  _ ((used))
# define __unused       __attribute_  _ ((unused))
# define __packed       __attribute_  _ ((packed))
# define __align(x)     __attribute_  _ ((aligned (x)))
# define __align_max    __attribute_  _ ((aligned))
# define likely(x)      _  _builtin_expect (!!(x), 1)
# define unlikely(x)    _  _builtin_expect (!!(x), 0)
#else
# define _  _noinline     /* no noinline */
# define _  _pure         /* no pure */
# define _  _const        /* no const */
# define _  _noreturn     /* no noreturn */
# define _  _malloc       /* no malloc */
# define _  _must_check   /* no warn_unused_result */
# define _  _deprecated   /* no deprecated */
# define _  _used         /* no used */
# define _  _unused       /* no unused */
# define _  _packed       /* no packed */
# define _  _align(x)     /* no aligned */
# define _  _align_max    /* no align_max */
# define likely(x)      (x)
# define unlikely(x)    (x)
#endif</p>
<p>For example, the following marks a function as pure, using our
      shortcut:_  _pure int foo (void) { /* ... */</p>
<p>If GCC is in use, the function is marked with the pure attribute. If GCC is not the compiler,
      the preprocessor replaces the _ _pure
      token with a no-op. Note that you can place multiple attributes on a
      given definition, and thus you can use more than one of these defines on
      a single definition with no problems.</p>
<p>Easier, prettier, and portable!</p>
<empty-line/><empty-line/>
<p><sup>[45] </sup><sup>*</sup> A memory
          <emphasis>alias</emphasis> occurs when two or more pointer variables
          point at the same memory address. This can happen in trivial cases
          where a pointer is assigned the value of another pointer, and also
          in more complex, less obvious cases. If a function is returning the
          address of newly allocated memory, no other pointers to that same
          address should exist.</p>
</section>
<section>
<empty-line/>
<p><strong>Bibliography</strong></p>
<p>This bibliography presents recommended reading related to system
    programming, broken down into four subcategories. None of these works are
    required reading. Instead, they represent my take on the top books on the
    given subject matter. If you find yourself pining for more information on
    the topics discussed here, these are my favorites.</p>
<p>Some of these books address material with which this book assumes
    the reader is already conversant, such as the C programming language.
    Other texts included make great supplements to this book, such as the
    works covering <emphasis>gdb</emphasis>, Subversion
    (<emphasis>svn)</emphasis>, or operating system design. Still others
    handle topics that are beyond the scope of this book, such as
    multithreading of sockets. Whatever the case, I recommend them all. Of
    course, these lists are certainly not exhaustive—feel free to explore
    other resources.</p>
<p><strong>Books on the C Programming Language</strong></p>
<p>These books document the C programming language, the
      <emphasis>lingua franca</emphasis> of system programming. If you do not
      code C as well as you speak your native tongue, one or more of the
      following works (coupled with a lot of practice!) ought to help you in
      that direction. If nothing else, the first title—universally known as
      <emphasis>K&amp;R</emphasis>—is a treat to read. Its brevity reveals the
      simplicity of C.</p>
<p>The C Programming Language, 2nd ed. Brian WKernighan and Dennis MRitchie. Prentice Hall, 1988. This book, written by the author of
      the C programming language and his then-coworker, is the bible of C
      programming.</p>
<p>C in a Nutshell. PeterPrinz and TonyCrawford. O'Reilly Media, 2005. A great book covering both the C
      language and the standard C library.</p>
<p>C Pocket Reference. PeterPrinz and UllaKirch-Prinz. Translated by Tony Crawford. O'Reilly Media, 2002. A concise reference to the C
      language, handily updated for ANSI C99.</p>
<p>Expert C Programming. Peter van derLinden. Prentice Hall, 1994. A wonderful discussion of
      lesser-known aspects of the C programming language, elucidated with an
      amazing wit and sense of humor. This book is rife with nonsequitur
      jokes, and I love it.</p>
<p>C Programming FAQs: Frequently Asked
      Questions, 2nd ed. SteveSummit. Addison-Wesley, 1995. This beast of a book contains more
      than 400 frequently asked questions (with answers) on the C programming
      language. Many of the FAQs beg obvious answers in the eyes C masters,
      but some of the weightier questions and answers should impress even the
      most erudite of C programmers. You are a true C ninja if you can answer
      all of these bad boys! The only downside is that the book has not been
      updated for ANSI C99, and there have definitely been some changes (I
      handmade the corrections in my copy). Note there is an online version
      that has likely been more recently updated.</p>
<p><strong>Books on Linux Programming</strong></p>
<p>The following texts cover Linux programming, including discussions
      of topics not covered in this book (sockets, IPC, and
      <emphasis>pthreads</emphasis>), and Linux programming tools (CVS, GNU
      Make, and Subversion).</p>
<p>Unix Network Programming, Volume 1:
      The Sockets Networking API, 3rd ed. W. RichardStevens et al. Addison-Wesley, 2003. The definitive tome on the socket
      API; unfortunately not specific to Linux, but fortunately recently
      updated for IPv6.</p>
<p>UNIX Network Programming, Volume 2:
      Interprocess Communications, 2nd ed. W. RichardStevens. Prentice Hall, 1998. An excellent discussion of
      interprocess communication (IPC).</p>
<p>PThreads Programming: A POSIX Standard for Better
      Multiprocessing. BradfordNichols et al. O'Reilly Media, 1996. A review of the POSIX threading API,
      pthreads.</p>
<p>Managing Projects with GNU Make, 3rd ed.
      RobertMecklenburg. O'Reilly Media, 2004. An excellent treatment on GNU Make,
      the classic tool for building software projects on Linux.</p>
<p>Essential CVS, 2nd ed. JenniferVersperman. O'Reilly Media, 2006. An excellent treatment on CVS, the
      classic tool for revision control and source code management on Unix
      systems.</p>
<p>Version Control with Subversion. BenCollins-Sussman et al. O'Reilly Media, 2004. A phenomenal take on Subversion, the
      proper tool for revision control and source code management on Unix
      systems, by three of Subversion's own authors.</p>
<p>GDB Pocket Reference. ArnoldRobbins. O'Reilly Media, 2005. A handy pocket guide to
      <emphasis>gdb</emphasis>, Linux's
      debugger.</p>
<p>Linux in a Nutshell, 5th ed. EllenSiever et al. O'Reilly Media, 2005. A whirlwind reference to all things
      Linux, including many of the tools comprising Linux's development
      environment.</p>
<p>Books on the Linux Kernel The two titles
      listed here cover the Linux kernel. Reasons for investigating this topic
      are threefold. First, the kernel provides the system call interface to
      user space, and is thus the core of system programming. Second, the
      behaviors and idiosyncrasies of a kernel shed light on its interactions
      with the applications it runs. Finally, the Linux kernel is a wonderful
      chunk of code, and these books are fun. Linux Kernel
      Development, 2nd ed. RobertLove. Novell Press, 2005. This work is ideally suited to system
      programmers who want to know about the design and implementation of the
      Linux kernel (and naturally, I would be remiss not to mention my own
      treatise on the subject!). Not an API reference, this book offers a
      great discussion of the algorithms used and decisions made by the Linux
      kernel.</p>
<p>Linux Device Drivers, 3rd ed. JonathanCorbet et al. O'Reilly Media, 2005. This is a great guide to writing
      device drivers for the Linux kernel, with excellent API references.
      Although aimed at device drivers, the discussions will benefit
      programmers of any persuasion, including system programmers merely
      seeking more insight into the machinations of the Linux kernel. A great
      complement to my own Linux kernel book.</p>
<p>Books on Operating System Design These two
      works, not specific to Linux, address operating system design in the
      abstract. As I've stressed in this book, a strong understanding of the
      system you code on only improves your output. Operating
      Systems, 3rd ed. HarveyDeitel et al. Prentice Hall, 2003. A <emphasis>tour de
      force</emphasis> on the theory of operating system design
      coupled with top-notch case studies putting that theory to practice. Of
      all the textbooks on operating system design, this is my favorite: it's
      modern, readable, and complete.</p>
<p>UNIX Systems for Modern Architectures: Symmetric
      Multiprocessing and Caching for Kernel Programming. CurtSchimmel. Addison-Wesley, 1994. Despite being only modestly related
      to system programming, this book offers such an excellent approach to
      the perils of concurrency and modern caching that I recommend it even to
      dentists.</p>
</section>
<section>
<p><strong>About the Author</strong></p>
<p>Robert Love has been a Linux user and hacker since the early days. Heis active in, and passionate about, both the Linux kernel and GNOMEdesktop communities. His recent contributions to the Linux kernelinclude work on the kernel event layer and inotify. GNOME-relatedcontributions include Beagle, GNOME Volume Manager, NetworkManager,and Project Utopia. Currently Robert works in the Open Source ProgramOffice at Google.</p>
<empty-line/><empty-line/>
<p>As an author, Robert is responsible for Linux Kernel Development(SAMS), now in its second edition, and Linux System Programming(O'Reilly). He is also a coauthor of the fifth edition of O'Reilly'sLinux in a Nutshell. He's a Contributing Editor for Linux Journal, haswritten numerous articles, and has been invited to speak around theworld on Linux.</p>
<empty-line/><empty-line/>
<p>Robert graduated from the University of Florida with a B.A. inMathematics and a B.S. in Computer Science. Hailing from SouthFlorida, he currently  calls Boston home.</p>
</section>
<section>
<p><strong>Colophon</strong></p>
<p>The image on the cover of <emphasis>Linux System
    Programming</emphasis> is a man in a flying machine. Well before the
    Wright brothers achieved their first controlled heavier-than-air flight in
    1903, people around the world attempted to fly by simple and elaborate
    machines. In the second or third century, Zhuge Liang of China reportedly
    flew in a Kongming lantern, the first hot air balloon. Around the fifth or
    sixth centuries, many Chinese people purportedly attached themselves to
    large kites to fly through the air.</p>
<p>It is also said that the Chinese created spinning toys that were
    early versions of helicopters, the designs of which may have inspired
    Leonardo da Vinci in his initial attempts at a solution to human flight.
    da Vinci also studied birds and designed parachutes, and in 1845, he
    designed an ornithopter, a wing-flapping machine meant to carry humans
    through the air. Though he never built it, the ornithopter's birdlike
    structure influenced the design of flying machines throughout the
    centuries.</p>
<p>The flying machine depicted on the cover is more elaborate than
    James Means' model soaring machine of 1893, which had no propellers. Means
    later printed an instruction manual for his soaring machine, which in part
    states that "the summit of Mt. Willard, near the Crawford House, N.H.,
    will be found an excellent place" to experiment with the machines.</p>
<p>But such experimentation was often dangerous. In the late nineteenth
    century, Otto Lilienthal built monoplanes, biplanes, and gliders. He was
    the first to show that control of human flight was within reach, and he
    gained the nickname "father of aerial testing," as he conducted more than
    2,000 glider flights, sometimes traveling more than a thousand feet. He
    died in 1896 after breaking his spine during a crash landing.</p>
<p>Flying machines are also known as mechanical birds and airships, and
    are occasionally called by more colorful names such as the Artificial
    Albatross. Enthusiasm for flying machines remains high, as aeronautical
    buffs still build early flying machines today.</p>
<p>The cover image and chapter opening graphics are from the Dover
    Pictorial Archive. The cover font is Adobe ITC Garamond. The text font is
    Linotype Birka; the heading font is Adobe Myriad Condensed; and the code
    font is LucasFont's TheSans Mono Condensed.</p>
</section>
<section>
<p>Linux System Programming</p>
<p>Robert Love</p>
<p>EditorAndy Oram</p>
<p>Copyright © 2009 O'Reilly Media, Inc.</p>
<p>O’Reilly Media</p>
<empty-line/>
<p>1005 Gravenstein Highway North</p>
<p>Sebastopol, CA 95472</p>
<p>2012-08-19T20:07:53-07:00</p>
</section>
</body>
<binary id="img_2" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAA+gAAALLCAAAAABPh/cUAAAC7mlDQ1BJQ0MgUHJvZmlsZQAA
eJxjYGCe4Oji5MokwMBQUFRS5B7kGBkRGaXAfp6BjYGZAQwSk4sLHAMCfEDsvPy8VAZUwMjA
8O0aiGRguKwLMouBNMCaDLQYSB8AYqOU1OJkIP0FiNPLSwqA4owxQLZIUjaYXQBiZ4cEOQPZ
LQwMTDwlqRUgvQzO+QWVRZnpGSUKhpaWlgqOKflJqQrBlcUlqbnFCp55yflFBflFiSWpKUC1
UDtAgNclv0TBPTEzT8HIQJVEdxMEoHCEsBDhgxBDgOTSojIIC6xIgEGBwYDBgSGAIZGhnmEB
w1GGN4zijC6MpYwrGO8xiTEFMU1gusAszBzJvJD5DYslSwfLLVY91lbWe2yWbNPYvrGHs+/m
UOLo4vjCmch5gcuRawu3JvcCHimeqbxCvJP4hPmm8cvwLxbQEdgh6Cp4RShV6Idwr4iKyF7R
cNEvYpPEjcSvSFRIykkek8qXlpY+IVMmqy57S65P3kX+j8JWxUIlPaW3ymtVClRNVH+qHVTv
0gjVVNL8oHVAe5JOqq6VnqDeK/0jBgsMa41ijG1N5E2ZTV+aXTDfabHEcoJVnXWuTZxtoJ2r
vbWDsaOOk5qzkouCq7ybgruyh7qnrpeJt42Pu2+wX4J/fkB94MSgpcG7Qi6GvgxnipCLtIqK
iK6ImRm7J+5BAluiblJYckPKmtSb6RwZFpmZWXOzL+ay59nnVxRsKnxXrF2SVbqq7E2FfmVJ
1a4axlqvuqn1Dxv1mmqaz7bKtRW2H+2U7irqPt2r2tfYf3eizaTZk/9OjZ92eIbGzP5Z3+ck
zD0933zB0kUii1uXfFuWufzeypBVp9e4rN233nLDtk0mm7dsNdm2fYfVzv27Xfec3Re2/8HB
nEM/j7QfEz++4qT1qXNnks/+Oj/povalo1cSr/67Puemza27d+rvKd8/8TDvsdiT/c8yX4i8
PPg6/638uwsfmj6Zfn71dcH38J8Cv079af3n+P8/AA0ADzTeHLSIAABoW0lEQVR4nO3dd3wc
xdkH8N8zs9fUuyX3IvfeG8bYuIMxvfcWWkjgDZCEDiGNXkJLAiT0jgmYYrAxuIF7wb33btlW
ubI7z/vHSbJscMG2fGWfb/Ix0ul0N9rb387s7OwMMYQQyU7FugBCiNpnxboAezEAqvkdHfi5
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</binary>
<binary id="img_4" content-type="image/png">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
gtgAQIABAMGpSAoRF+oxAAAAAElFTkSuQmCC</binary>
<binary id="img_1" content-type="image/jpeg">/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAIBAQEBAQIBAQECAgICAgQDAgICAgUEBAMEBgUG
BgYFBgYGBwkIBgcJBwYGCAsICQoKCgoKBggLDAsKDAkKCgr/2wBDAQICAgICAgUDAwUKBwYH
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgr/wAAR
CAAuAPgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAA
AgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkK
FhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWG
h4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl
5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREA
AgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYk
NOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOE
hYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk
5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9w/2j/wBpD4M/sl/BzWfj18ffG9roHhnQ
rfzLy9uCSzseEhiQfNLK7YVI1BZicAV/Pt/wUL/4OeP2yP2jvEV/4Q/ZG1Cf4S+BQzRW9xZC
N9ev05HmS3RBFrnhglvtZOQZZBzVL/g5k/4KJ+Jf2nv2zL/9lTwjr7r4C+El89g1pBIRHf64
F23lxIM4YwsWtkBHy+XKQf3pr77/AOCA3/BDb4afs6fCfw9+2N+1J4Gtdb+J/iO0h1Pw9pWr
2okh8KWrjfCVicY+2spV3kYboshE2lXZwtJRV2fkf4N/4Jef8Fjv25xD8Sh+zv8AEzxZ9uBk
tte8d6p9kNyrAHzEm1aePzFYAfOCQcDk03xv/wAEt/8AgsT+w9HP8RZ/2c/iV4VWyAkutd8D
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
Ee4ZgHC2zANg84JHvQKG5/THRRRQQFFFFAH/2Q==</binary>
<binary id="img_3" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAA+gAAAGLCAAAAABxN+flAAAC7mlDQ1BJQ0MgUHJvZmlsZQAA
eJxjYGCe4Oji5MokwMBQUFRS5B7kGBkRGaXAfp6BjYGZAQwSk4sLHAMCfEDsvPy8VAZUwMjA
8O0aiGRguKwLMouBNMCaDLQYSB8AYqOU1OJkIP0FiNPLSwqA4owxQLZIUjaYXQBiZ4cEOQPZ
LQwMTDwlqRUgvQzO+QWVRZnpGSUKhpaWlgqOKflJqQrBlcUlqbnFCp55yflFBflFiSWpKUC1
UDtAgNclv0TBPTEzT8HIQJVEdxMEoHCEsBDhgxBDgOTSojIIC6xIgEGBwYDBgSGAIZGhnmEB
w1GGN4zijC6MpYwrGO8xiTEFMU1gusAszBzJvJD5DYslSwfLLVY91lbWe2yWbNPYvrGHs+/m
UOLo4vjCmch5gcuRawu3JvcCHimeqbxCvJP4hPmm8cvwLxbQEdgh6Cp4RShV6Idwr4iKyF7R
cNEvYpPEjcSvSFRIykkek8qXlpY+IVMmqy57S65P3kX+j8JWxUIlPaW3ymtVClRNVH+qHVTv
0gjVVNL8oHVAe5JOqq6VnqDeK/0jBgsMa41ijG1N5E2ZTV+aXTDfabHEcoJVnXWuTZxtoJ2r
vbWDsaOOk5qzkouCq7ybgruyh7qnrpeJt42Pu2+wX4J/fkB94MSgpcG7Qi6GvgxnipCLtIqK
iK6ImRm7J+5BAluiblJYckPKmtSb6RwZFpmZWXOzL+ay59nnVxRsKnxXrF2SVbqq7E2FfmVJ
1a4axlqvuqn1Dxv1mmqaz7bKtRW2H+2U7irqPt2r2tfYf3eizaTZk/9OjZ92eIbGzP5Z3+ck
zD0933zB0kUii1uXfFuWufzeypBVp9e4rN233nLDtk0mm7dsNdm2fYfVzv27Xfec3Re2/8HB
nEM/j7QfEz++4qT1qXNnks/+Oj/povalo1cSr/67Puemza27d+rvKd8/8TDvsdiT/c8yX4i8
PPg6/638uwsfmj6Zfn71dcH38J8Cv079af3n+P8/AA0ADzTeHLSIAACIkElEQVR4nO2ddYBc
1fXHv+fe+2Rm1jfuJIQkaHB3TXEvdSg1KhRK8RYo/VVogULwIsXd3V2CBEICSUhC3JP13ZH3
7j2/P97MSrK+M7O7yfvAbsb2vTcz7/vOueecey4xNj24+T/U7ouo3deEhGwi0KYidAYDYEB0
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</binary>
<binary id="img_0" content-type="image/jpeg">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CTxyZWFsPjcyPC9yZWFsPgoJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNsaWVudDwva2V5PgoJCQkJPHN0cmluZz5jb20uYXBwbGUucHJpbnRpbmdtYW5hZ2VyPC9zdHJpbmc+CgkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQubW9kRGF0ZTwva2V5PgoJCQkJPGRhdGU+MjAwNy0wMi0wN1QxODozODozOVo8L2RhdGU+CgkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuc3RhdGVGbGFnPC9rZXk+CgkJCQk8aW50ZWdlcj4wPC9pbnRlZ2VyPgoJCQk8L2RpY3Q+CgkJPC9hcnJheT4KCTwvZGljdD4KCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1PcmllbnRhdGlvbjwva2V5PgoJPGRpY3Q+CgkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJPGFycmF5PgoJCQk8ZGljdD4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1PcmllbnRhdGlvbjwva2V5PgoJCQkJPGludGVnZXI+MTwvaW50ZWdlcj4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5jbGllbnQ8L2tleT4KCQkJCTxzdHJpbmc+Y29tLmFwcGxlLnByaW50aW5nbWFuYWdlcjwvc3RyaW5nPgoJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0Lm1vZERhdGU8L2tleT4KCQkJCTxkYXRlPjIwMDctMDItMDdUMTg6Mzg6MzlaPC9kYXRlPgoJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LnN0YXRlRmxhZzwva2V5PgoJCQkJPGludGVnZXI+MDwvaW50ZWdlcj4KCQkJPC9kaWN0PgoJCTwvYXJyYXk+Cgk8L2RpY3Q+Cgk8a2V5PmNvbS5hcHBsZS5wcmludC5QYWdlRm9ybWF0LlBNU2NhbGluZzwva2V5PgoJPGRpY3Q+CgkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJPGFycmF5PgoJCQk8ZGljdD4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1TY2FsaW5nPC9rZXk+CgkJCQk8cmVhbD4xPC9yZWFsPgoJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNsaWVudDwva2V5PgoJCQkJPHN0cmluZz5jb20uYXBwbGUucHJpbnRpbmdtYW5hZ2VyPC9zdHJpbmc+CgkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQubW9kRGF0ZTwva2V5PgoJCQkJPGRhdGU+MjAwNy0wMi0wN1QxODozODozOVo8L2RhdGU+CgkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuc3RhdGVGbGFnPC9rZXk+CgkJCQk8aW50ZWdlcj4wPC9pbnRlZ2VyPgoJCQk8L2RpY3Q+CgkJPC9hcnJheT4KCTwvZGljdD4KCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1WZXJ0aWNhbFJlczwva2V5PgoJPGRpY3Q+CgkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJPGFycmF5PgoJCQk8ZGljdD4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1WZXJ0aWNhbFJlczwva2V5PgoJCQkJPHJlYWw+NzI8L3JlYWw+CgkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuY2xpZW50PC9rZXk+CgkJCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5tb2REYXRlPC9rZXk+CgkJCQk8ZGF0ZT4yMDA3LTAyLTA3VDE4OjM4OjM5WjwvZGF0ZT4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5zdGF0ZUZsYWc8L2tleT4KCQkJCTxpbnRlZ2VyPjA8L2ludGVnZXI+CgkJCTwvZGljdD4KCQk8L2FycmF5PgoJPC9kaWN0PgoJPGtleT5jb20uYXBwbGUucHJpbnQuUGFnZUZvcm1hdC5QTVZlcnRpY2FsU2NhbGluZzwva2V5PgoJPGRpY3Q+CgkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJPGFycmF5PgoJCQk8ZGljdD4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1WZXJ0aWNhbFNjYWxpbmc8L2tleT4KCQkJCTxyZWFsPjE8L3JlYWw+CgkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuY2xpZW50PC9rZXk+CgkJCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5tb2REYXRlPC9rZXk+CgkJCQk8ZGF0ZT4yMDA3LTAyLTA3VDE4OjM4OjM5WjwvZGF0ZT4KCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5zdGF0ZUZsYWc8L2tleT4KCQkJCTxpbnRlZ2VyPjA8L2ludGVnZXI+CgkJCTwvZGljdD4KCQk8L2FycmF5PgoJPC9kaWN0PgoJPGtleT5jb20uYXBwbGUucHJpbnQuc3ViVGlja2V0LnBhcGVyX2luZm9fdGlja2V0PC9rZXk+Cgk8ZGljdD4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYWdlRm9ybWF0LlBNQWRqdXN0ZWRQYWdlUmVjdDwva2V5PgoJCTxkaWN0PgoJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuY3JlYXRvcjwva2V5PgoJCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0Lml0ZW1BcnJheTwva2V5PgoJCQk8YXJyYXk+CgkJCQk8ZGljdD4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYWdlRm9ybWF0LlBNQWRqdXN0ZWRQYWdlUmVjdDwva2V5PgoJCQkJCTxhcnJheT4KCQkJCQkJPHJlYWw+MC4wPC9yZWFsPgoJCQkJCQk8cmVhbD4wLjA8L3JlYWw+CgkJCQkJCTxyZWFsPjczNDwvcmVhbD4KCQkJCQkJPHJlYWw+NTc2PC9yZWFsPgoJCQkJCTwvYXJyYXk+CgkJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNsaWVudDwva2V5PgoJCQkJCTxzdHJpbmc+Y29tLmFwcGxlLnByaW50aW5nbWFuYWdlcjwvc3RyaW5nPgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5tb2REYXRlPC9rZXk+CgkJCQkJPGRhdGU+MjAwNy0wMi0wN1QxODozODozOVo8L2RhdGU+CgkJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LnN0YXRlRmxhZzwva2V5PgoJCQkJCTxpbnRlZ2VyPjA8L2ludGVnZXI+CgkJCQk8L2RpY3Q+CgkJCTwvYXJyYXk+CgkJPC9kaWN0PgoJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhZ2VGb3JtYXQuUE1BZGp1c3RlZFBhcGVyUmVjdDwva2V5PgoJCTxkaWN0PgoJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuY3JlYXRvcjwva2V5PgoJCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0Lml0ZW1BcnJheTwva2V5PgoJCQk8YXJyYXk+CgkJCQk8ZGljdD4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYWdlRm9ybWF0LlBNQWRqdXN0ZWRQYXBlclJlY3Q8L2tleT4KCQkJCQk8YXJyYXk+CgkJCQkJCTxyZWFsPi0xODwvcmVhbD4KCQkJCQkJPHJlYWw+LTE4PC9yZWFsPgoJCQkJCQk8cmVhbD43NzQ8L3JlYWw+CgkJCQkJCTxyZWFsPjU5NDwvcmVhbD4KCQkJCQk8L2FycmF5PgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5jbGllbnQ8L2tleT4KCQkJCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQubW9kRGF0ZTwva2V5PgoJCQkJCTxkYXRlPjIwMDctMDItMDdUMTg6Mzg6MzlaPC9kYXRlPgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5zdGF0ZUZsYWc8L2tleT4KCQkJCQk8aW50ZWdlcj4wPC9pbnRlZ2VyPgoJCQkJPC9kaWN0PgoJCQk8L2FycmF5PgoJCTwvZGljdD4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYXBlckluZm8uUE1QYXBlck5hbWU8L2tleT4KCQk8ZGljdD4KCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQkJPHN0cmluZz5jb20uYXBwbGUucHJpbnQucG0uUG9zdFNjcmlwdDwvc3RyaW5nPgoJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJCTxhcnJheT4KCQkJCTxkaWN0PgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhcGVySW5mby5QTVBhcGVyTmFtZTwva2V5PgoJCQkJCTxzdHJpbmc+bmEtbGV0dGVyPC9zdHJpbmc+CgkJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNsaWVudDwva2V5PgoJCQkJCTxzdHJpbmc+Y29tLmFwcGxlLnByaW50LnBtLlBvc3RTY3JpcHQ8L3N0cmluZz4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQubW9kRGF0ZTwva2V5PgoJCQkJCTxkYXRlPjIwMDMtMDctMDFUMTc6NDk6MzZaPC9kYXRlPgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5zdGF0ZUZsYWc8L2tleT4KCQkJCQk8aW50ZWdlcj4xPC9pbnRlZ2VyPgoJCQkJPC9kaWN0PgoJCQk8L2FycmF5PgoJCTwvZGljdD4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYXBlckluZm8uUE1VbmFkanVzdGVkUGFnZVJlY3Q8L2tleT4KCQk8ZGljdD4KCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQkJPHN0cmluZz5jb20uYXBwbGUucHJpbnQucG0uUG9zdFNjcmlwdDwvc3RyaW5nPgoJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJCTxhcnJheT4KCQkJCTxkaWN0PgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhcGVySW5mby5QTVVuYWRqdXN0ZWRQYWdlUmVjdDwva2V5PgoJCQkJCTxhcnJheT4KCQkJCQkJPHJlYWw+MC4wPC9yZWFsPgoJCQkJCQk8cmVhbD4wLjA8L3JlYWw+CgkJCQkJCTxyZWFsPjczNDwvcmVhbD4KCQkJCQkJPHJlYWw+NTc2PC9yZWFsPgoJCQkJCTwvYXJyYXk+CgkJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNsaWVudDwva2V5PgoJCQkJCTxzdHJpbmc+Y29tLmFwcGxlLnByaW50aW5nbWFuYWdlcjwvc3RyaW5nPgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5tb2REYXRlPC9rZXk+CgkJCQkJPGRhdGU+MjAwNy0wMi0wN1QxODozODozOVo8L2RhdGU+CgkJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LnN0YXRlRmxhZzwva2V5PgoJCQkJCTxpbnRlZ2VyPjA8L2ludGVnZXI+CgkJCQk8L2RpY3Q+CgkJCTwvYXJyYXk+CgkJPC9kaWN0PgoJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhcGVySW5mby5QTVVuYWRqdXN0ZWRQYXBlclJlY3Q8L2tleT4KCQk8ZGljdD4KCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LmNyZWF0b3I8L2tleT4KCQkJPHN0cmluZz5jb20uYXBwbGUucHJpbnQucG0uUG9zdFNjcmlwdDwvc3RyaW5nPgoJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuaXRlbUFycmF5PC9rZXk+CgkJCTxhcnJheT4KCQkJCTxkaWN0PgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LlBhcGVySW5mby5QTVVuYWRqdXN0ZWRQYXBlclJlY3Q8L2tleT4KCQkJCQk8YXJyYXk+CgkJCQkJCTxyZWFsPi0xODwvcmVhbD4KCQkJCQkJPHJlYWw+LTE4PC9yZWFsPgoJCQkJCQk8cmVhbD43NzQ8L3JlYWw+CgkJCQkJCTxyZWFsPjU5NDwvcmVhbD4KCQkJCQk8L2FycmF5PgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5jbGllbnQ8L2tleT4KCQkJCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludGluZ21hbmFnZXI8L3N0cmluZz4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQubW9kRGF0ZTwva2V5PgoJCQkJCTxkYXRlPjIwMDctMDItMDdUMTg6Mzg6MzlaPC9kYXRlPgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5zdGF0ZUZsYWc8L2tleT4KCQkJCQk8aW50ZWdlcj4wPC9pbnRlZ2VyPgoJCQkJPC9kaWN0PgoJCQk8L2FycmF5PgoJCTwvZGljdD4KCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYXBlckluZm8ucHBkLlBNUGFwZXJOYW1lPC9rZXk+CgkJPGRpY3Q+CgkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5jcmVhdG9yPC9rZXk+CgkJCTxzdHJpbmc+Y29tLmFwcGxlLnByaW50LnBtLlBvc3RTY3JpcHQ8L3N0cmluZz4KCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0Lml0ZW1BcnJheTwva2V5PgoJCQk8YXJyYXk+CgkJCQk8ZGljdD4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC5QYXBlckluZm8ucHBkLlBNUGFwZXJOYW1lPC9rZXk+CgkJCQkJPHN0cmluZz5VUyBMZXR0ZXI8L3N0cmluZz4KCQkJCQk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQuY2xpZW50PC9rZXk+CgkJCQkJPHN0cmluZz5jb20uYXBwbGUucHJpbnQucG0uUG9zdFNjcmlwdDwvc3RyaW5nPgoJCQkJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5tb2REYXRlPC9rZXk+CgkJCQkJPGRhdGU+MjAwMy0wNy0wMVQxNzo0OTozNlo8L2RhdGU+CgkJCQkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LnN0YXRlRmxhZzwva2V5PgoJCQkJCTxpbnRlZ2VyPjE8L2ludGVnZXI+CgkJCQk8L2RpY3Q+CgkJCTwvYXJyYXk+CgkJPC9kaWN0PgoJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5BUElWZXJzaW9uPC9rZXk+CgkJPHN0cmluZz4wMC4yMDwvc3RyaW5nPgoJCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5wcml2YXRlTG9jazwva2V5PgoJCTxmYWxzZS8+CgkJPGtleT5jb20uYXBwbGUucHJpbnQudGlja2V0LnR5cGU8L2tleT4KCQk8c3RyaW5nPmNvbS5hcHBsZS5wcmludC5QYXBlckluZm9UaWNrZXQ8L3N0cmluZz4KCTwvZGljdD4KCTxrZXk+Y29tLmFwcGxlLnByaW50LnRpY2tldC5BUElWZXJzaW9uPC9rZXk+Cgk8c3RyaW5nPjAwLjIwPC9zdHJpbmc+Cgk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQucHJpdmF0ZUxvY2s8L2tleT4KCTxmYWxzZS8+Cgk8a2V5PmNvbS5hcHBsZS5wcmludC50aWNrZXQudHlwZTwva2V5PgoJPHN0cmluZz5jb20uYXBwbGUucHJpbnQuUGFnZUZvcm1hdFRpY2tldDwvc3RyaW5nPgo8L2RpY3Q+CjwvcGxpc3Q+CjhCSU0D6QAAAAAAeAADAAAASABIAAAAAALeAkD/7v/uAwYCUgNnBSgD/AACAAAASABIAAAAAALYAigAAQAAAGQAAAABAAMDAwAAAAF//wABAAEAAAAAAAAAAAAAAABoCAAZAZAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0D7QAAAAAAEAEsAAAAAQABASwAAAABAAE4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0EDQAAAAAABAAAAB44QklNBBkAAAAAAAQAAAAeOEJJTQPzAAAAAAAJAAAAAAAAAAABADhCSU0ECgAAAAAAAQAAOEJJTScQAAAAAAAKAAEAAAAAAAAAAThCSU0D9QAAAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+AAAAAAAcAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAA4QklNBAAAAAAAAAIAADhCSU0EAgAAAAAAAgAAOEJJTQQIAAAAAAAQAAAAAQAAAkAAAAJAAAAAADhCSU0EHgAAAAAABAAAAAA4QklNBBoAAAAAA1MAAAAGAAAAAAAAAAAAAAKQAAAB9AAAAA8AOQA3ADgAMAA1ADkANgAwADAAOQA1ADgAOABfAHMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAfQAAAKQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAKQAAAAAFJnaHRsb25nAAAB9AAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xp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MDIvMjItcmRmLXN5bnRheC1ucyMnIHhtbG5zOmlYPSdodHRwOi8vbnMuYWRvYmUuY29tL2lYLzEuMC8nPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSd1dWlkOmY0N2Y3NTQzLWI4MjktMTFkYi1iNjE5LWJkNTlmYjE4MzNkNicKICB4bWxuczpleGlmPSdodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyc+CiAgPGV4aWY6Q29sb3JTcGFjZT4xPC9leGlmOkNvbG9yU3BhY2U+CiAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjUwMDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjY1NjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0ndXVpZDpmNDdmNzU0My1iODI5LTExZGItYjYxOS1iZDU5ZmIxODMzZDYnCiAgeG1sbnM6cGRmPSdodHRwOi8vbnMuYWRvYmUuY29tL3BkZi8xLjMvJz4KICA8cGRmOlByb2R1Y2VyPkFkb2JlIFBERiBMaWJyYXJ5IDcuMDwvcGRmOlByb2R1Y2VyPgogIDxwZGY6VHJhcHBlZD5GYWxzZTwvcGRmOlRyYXBwZWQ+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0ndXVpZDpmNDdmNzU0My1iODI5LTExZGItYjYxOS1iZDU5ZmIxODMzZDYnCiAgeG1sbnM6cGhvdG9zaG9wPSdodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvJz4KICA8cGhvdG9zaG9wOkhpc3Rvcnk+PC9waG90b3Nob3A6SGlzdG9yeT4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSd1dWlkOmY0N2Y3NTQzLWI4MjktMTFkYi1iNjE5LWJkNTlmYjE4MzNkNicKICB4bWxuczp0aWZmPSdodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyc+CiAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAvMTwvdGlmZjpYUmVzb2x1dGlvbj4KICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAvMTwvdGlmZjpZUmVzb2x1dGlvbj4KICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogPC9yZGY6RGVzY3JpcHRpb24+CgogPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9J3V1aWQ6ZjQ3Zjc1NDMtYjgyOS0xMWRiLWI2MTktYmQ1OWZiMTgzM2Q2JwogIHhtbG5zOnhhcD0naHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLycKICB4bWxuczp4YXBHSW1nPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvZy9pbWcvJz4KICA8eGFwOkNyZWF0ZURhdGU+MjAwNy0wMi0wN1QxMDo0MDozNS0wODowMDwveGFwOkNyZWF0ZURhdGU+CiAgPHhhcDpNZXRhZGF0YURhdGU+MjAwNy0wMi0wN1QxMDo0MDozNS0wODowMDwveGFwOk1ldGFkYXRhRGF0ZT4KICA8eGFwOk1vZGlmeURhdGU+MjAwNy0wMi0wN1QxMDo0MDozNS0wODowMDwveGFwOk1vZGlmeURhdGU+CiAgPHhhcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ1MgTWFjaW50b3NoPC94YXA6Q3JlYXRvclRvb2w+CiA8L3JkZjpEZXNjcmlwdGlvbj4KCiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0ndXVpZDpmNDdmNzU0My1iODI5LTExZGItYjYxOS1iZDU5ZmIxODMzZDYnCiAgeG1sbnM6c3RNZnM9J2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9NYW5pZmVzdEl0ZW0jJwogIHhtbG5zOnN0UmVmPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjJwogIHhtbG5zOnhhcE1NPSdodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vJz4KICA8eGFwTU06SW5zdGFuY2VJRD51dWlkOjFhNDFkNzgyLWI1NTgtMTFkYi04YjAzLTAwMGQ5M2MwOTU3MDwveGFwTU06SW5zdGFuY2VJRD4KICA8eGFwTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICA8c3RSZWY6aW5zdGFuY2VJRD51dWlkOjY0N2QzMWFkLWI2ZGEtMTFkYi04Yzg3LTAwMzA2NTliMDdhYzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgPHN0UmVmOmRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6aW5kZDphOGI1N2IyMy1iMTIzLTExZGItYjdjOC1lOGY1NjBmZjE3YWU8L3N0UmVmOmRvY3VtZW50SUQ+CiAgIDxzdFJlZjpyZW5kaXRpb25DbGFzcz5wcm9vZjpwZGY8L3N0UmVmOnJlbmRpdGlvbkNsYXNzPgogIDwveGFwTU06RGVyaXZlZEZyb20+CiAgPHhhcE1NOk1hbmlmZXN0PgogICA8cmRmOkJhZz4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxzdE1mczpsaW5rRm9ybT5SZWZlcmVuY2VTdHJlYW08L3N0TWZzOmxpbmtGb3JtPgogICAgIDx4YXBNTTpwbGFjZWRYUmVzb2x1dGlvbj4xMjAwLjAwPC94YXBNTTpwbGFjZWRYUmVzb2x1dGlvbj4KICAgICA8eGFwTU06cGxhY2VkWVJlc29sdXRpb24+MTIwMC4wMDwveGFwTU06cGxhY2VkWVJlc29sdXRpb24+CiAgICAgPHhhcE1NOnBsYWNlZFJlc29sdXRpb25Vbml0PkluY2hlczwveGFwTU06cGxhY2VkUmVzb2x1dGlvblVuaXQ+CiAgICAgPHN0TWZzOnJlZmVyZW5jZSByZGY6cGFyc2VUeXBlPSdSZXNvdXJjZSc+CiAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnV1aWQ6QjE4QzJCNUVBRjNGMTFEQkFGMzlCOTk4Q0VGNkNEMTA8L3N0UmVmOmluc3RhbmNlSUQ+CiAgICAgIDxzdFJlZjpkb2N1bWVudElEPnV1aWQ6MjczRkE4RENBRjNGMTFEQkFGMzlCOTk4Q0VGNkNEMTA8L3N0UmVmOmRvY3VtZW50SUQ+CiAgICAgPC9zdE1mczpyZWZlcmVuY2U+CiAgICA8L3JkZjpsaT4KICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPgogICAgIDxzdE1mczpsaW5rRm9ybT5SZWZlcmVuY2VTdHJlYW08L3N0TWZzOmxpbmtGb3JtPgogICAgIDx4YXBNTTpwbGFjZWRYUmVzb2x1dGlvbj4xMjAwLjAwPC94YXBNTTpwbGFjZWRYUmVzb2x1dGlvbj4KICAgICA8eGFwTU06cGxhY2VkWVJlc29sdXRpb24+MTIwMC4wMDwveGFwTU06cGxhY2VkWVJlc29sdXRpb24+CiAgICAgPHhhcE1NOnBsYWNlZFJlc29sdXRpb25Vbml0PkluY2hlczwveGFwTU06cGxhY2VkUmVzb2x1dGlvblVuaXQ+CiAgICAgPHN0TWZzOnJlZmVyZW5jZSByZGY6cGFyc2VUeXBlPSdSZXNvdXJjZSc+CiAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnV1aWQ6MjczRkE4RDlBRjNGMTFEQkFGMzlCOTk4Q0VGNkNEMTA8L3N0UmVmOmluc3RhbmNlSUQ+CiAgICAgIDxzdFJlZjpkb2N1bWVudElEPnV1aWQ6OTFCM0ZGQzdBRUVFMTFEQkFGMzlCOTk4Q0VGNkNEMTA8L3N0UmVmOmRvY3VtZW50SUQ+CiAgICAgPC9zdE1mczpyZWZlcmVuY2U+CiAgICA8L3JkZjpsaT4KICAgPC9yZGY6QmFnPgogIDwveGFwTU06TWFuaWZlc3Q+CiAgPHhhcE1NOkRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmY0N2Y3NTQyLWI4MjktMTFkYi1iNjE5LWJkNTlmYjE4MzNkNjwveGFwTU06RG9jdW1lbnRJRD4KIDwvcmRmOkRlc2NyaXB0aW9uPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSd1dWlkOmY0N2Y3NTQzLWI4MjktMTFkYi1iNjE5LWJkNTlmYjE4MzNkNicKICB4bWxuczpkYz0naHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8nPgogIDxkYzpmb3JtYXQ+aW1hZ2UvanBlZzwvZGM6Zm9ybWF0PgogPC9yZGY6RGVzY3JpcHRpb24+Cgo8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0ndyc/Pv/iDFhJQ0NfUFJPRklMRQABAQAADEhMaW5vAhAAAG1udHJSR0IgWFlaIAfOAAIACQAGADEAAGFjc3BNU0ZUAAAAAElFQyBzUkdCAAAAAAAAAAAAAAAAAAD21gABAAAAANMtSFAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEWNwcnQAAAFQAAAAM2Rlc2MAAAGEAAAAbHd0cHQAAAHwAAAAFGJrcHQAAAIEAAAAFHJYWVoAAAIYAAAAFGdYWVoAAAIsAAAAFGJYWVoAAAJAAAAAFGRtbmQAAAJUAAAAcGRtZGQAAALEAAAAiHZ1ZWQAAANMAAAAhnZpZXcAAAPUAAAAJGx1bWkAAAP4AAAAFG1lYXMAAAQMAAAAJHRlY2gAAAQwAAAADHJUUkMAAAQ8AAAIDGdUUkMAAAQ8AAAIDGJUUkMAAAQ8AAAIDHRleHQAAAAAQ29weXJpZ2h0IChjKSAxOTk4IEhld2xldHQtUGFja2FyZCBDb21wYW55AABkZXNjAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWVogAAAAAAAA81EAAQAAAAEWzFhZWiAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAG+iAAA49QAAA5BYWVogAAAAAAAAYpkAALeFAAAY2lhZWiAAAAAAAAAkoAAAD4QAALbPZGVzYwAAAAAAAAAWSUVDIGh0dHA6Ly93d3cuaWVjLmNoAAAAAAAAAAAAAAAWSUVDIGh0dHA6Ly93d3cuaWVjLmNoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGRlc2MAAAAAAAAALklFQyA2MTk2Ni0yLjEgRGVmYXVsdCBSR0IgY29sb3VyIHNwYWNlIC0gc1JHQgAAAAAAAAAAAAAALklFQyA2MTk2Ni0yLjEgRGVmYXVsdCBSR0IgY29sb3VyIHNwYWNlIC0gc1JHQgAAAAAAAAAAAAAAAAAAAAAAAAAAAABkZXNjAAAAAAAAACxSZWZlcmVuY2UgVmlld2luZyBDb25kaXRpb24gaW4gSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGluIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdmlldwAAAAAAE6T+ABRfLgAQzxQAA+3MAAQTCwADXJ4AAAABWFlaIAAAAAAATAlWAFAAAABXH+dtZWFzAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAACjwAAAAJzaWcgAAAAAENSVCBjdXJ2AAAAAAAABAAAAAAFAAoADwAUABkAHgAjACgALQAyADcAOwBAAEUASgBPAFQAWQBeAGMAaABtAHIAdwB8AIEAhgCLAJAAlQCaAJ8ApACpAK4AsgC3ALwAwQDGAMsA0ADVANsA4ADlAOsA8AD2APsBAQEHAQ0BEwEZAR8BJQErATIBOAE+AUUBTAFSAVkBYAFnAW4BdQF8AYMBiwGSAZoBoQGpAbEBuQHBAckB0QHZAeEB6QHyAfoCAwIMAhQCHQImAi8COAJBAksCVAJdAmcCcQJ6AoQCjgKYAqICrAK2AsECywLVAuAC6wL1AwADCwMWAyEDLQM4A0MDTwNaA2YDcgN+A4oDlgOiA64DugPHA9MD4APsA/kEBgQTBCAELQQ7BEgEVQRjBHEEfgSMBJoEqAS2BMQE0wThBPAE/gUNBRwFKwU6BUkFWAVnBXcFhgWWBaYFtQXFBdUF5QX2BgYGFgYnBjcGSAZZBmoGewaMBp0GrwbABtEG4wb1BwcHGQcrBz0HTwdhB3QHhgeZB6wHvwfSB+UH+AgLCB8IMghGCFoIbgiCCJYIqgi+CNII5wj7CRAJJQk6CU8JZAl5CY8JpAm6Cc8J5Qn7ChEKJwo9ClQKagqBCpgKrgrFCtwK8wsLCyILOQtRC2kLgAuYC7ALyAvhC/kMEgwqDEMMXAx1DI4MpwzADNkM8w0NDSYNQA1aDXQNjg2pDcMN3g34DhMOLg5JDmQOfw6bDrYO0g7uDwkPJQ9BD14Peg+WD7MPzw/sEAkQJhBDEGEQfhCbELkQ1xD1ERMRMRFPEW0RjBGqEckR6BIHEiYSRRJkEoQSoxLDEuMTAxMjE0MTYxODE6QTxRPlFAYUJxRJFGoUixStFM4U8BUSFTQVVhV4FZsVvRXgFgMWJhZJFmwWjxayFtYW+hcdF0EXZReJF64X0hf3GBsYQBhlGIoYrxjVGPoZIBlFGWsZkRm3Gd0aBBoqGlEadxqeGsUa7BsUGzsbYxuKG7Ib2hwCHCocUhx7HKMczBz1HR4dRx1wHZkdwx3sHhYeQB5qHpQevh7pHxMfPh9pH5Qfvx/qIBUgQSBsIJggxCDwIRwhSCF1IaEhziH7IiciVSKCIq8i3SMKIzgjZiOUI8Ij8CQfJE0kfCSrJNolCSU4JWgllyXHJfcmJyZXJocmtyboJxgnSSd6J6sn3CgNKD8ocSiiKNQpBik4KWspnSnQKgIqNSpoKpsqzysCKzYraSudK9EsBSw5LG4soizXLQwtQS12Last4S4WLkwugi63Lu4vJC9aL5Evxy/+MDUwbDCkMNsxEjFKMYIxujHyMioyYzKbMtQzDTNGM38zuDPxNCs0ZTSeNNg1EzVNNYc1wjX9Njc2cjauNuk3JDdgN5w31zgUOFA4jDjIOQU5Qjl/Obw5+To2OnQ6sjrvOy07azuqO+g8JzxlPKQ84z0iPWE9oT3gPiA+YD6gPuA/IT9hP6I/4kAjQGRApkDnQSlBakGsQe5CMEJyQrVC90M6Q31DwEQDREdEikTORRJFVUWaRd5GIkZnRqtG8Ec1R3tHwEgFSEtIkUjXSR1JY0mpSfBKN0p9SsRLDEtTS5pL4kwqTHJMuk0CTUpNk03cTiVObk63TwBPSU+TT91QJ1BxULtRBlFQUZtR5lIxUnxSx1MTU19TqlP2VEJUj1TbVShVdVXCVg9WXFapVvdXRFeSV+BYL1h9WMtZGllpWbhaB1pWWqZa9VtFW5Vb5Vw1XIZc1l0nXXhdyV4aXmxevV8PX2Ffs2AFYFdgqmD8YU9homH1YklinGLwY0Njl2PrZEBklGTpZT1lkmXnZj1mkmboZz1nk2fpaD9olmjsaUNpmmnxakhqn2r3a09rp2v/bFdsr20IbWBtuW4SbmtuxG8eb3hv0XArcIZw4HE6cZVx8HJLcqZzAXNdc7h0FHRwdMx1KHWFdeF2Pnabdvh3VnezeBF4bnjMeSp5iXnnekZ6pXsEe2N7wnwhfIF84X1BfaF+AX5ifsJ/I3+Ef+WAR4CogQqBa4HNgjCCkoL0g1eDuoQdhICE44VHhauGDoZyhteHO4efiASIaYjOiTOJmYn+imSKyoswi5aL/IxjjMqNMY2Yjf+OZo7OjzaPnpAGkG6Q1pE/kaiSEZJ6kuOTTZO2lCCUipT0lV+VyZY0lp+XCpd1l+CYTJi4mSSZkJn8mmia1ZtCm6+cHJyJnPedZJ3SnkCerp8dn4uf+qBpoNihR6G2oiailqMGo3aj5qRWpMelOKWpphqmi6b9p26n4KhSqMSpN6mpqhyqj6sCq3Wr6axcrNCtRK24ri2uoa8Wr4uwALB1sOqxYLHWskuywrM4s660JbSctRO1irYBtnm28Ldot+C4WbjRuUq5wro7urW7LrunvCG8m70VvY++Cr6Evv+/er/1wHDA7MFnwePCX8Lbw1jD1MRRxM7FS8XIxkbGw8dBx7/IPci8yTrJuco4yrfLNsu2zDXMtc01zbXONs62zzfPuNA50LrRPNG+0j/SwdNE08bUSdTL1U7V0dZV1tjXXNfg2GTY6Nls2fHadtr724DcBdyK3RDdlt4c3qLfKd+v4DbgveFE4cziU+Lb42Pj6+Rz5PzlhOYN5pbnH+ep6DLovOlG6dDqW+rl63Dr++yG7RHtnO4o7rTvQO/M8Fjw5fFy8f/yjPMZ86f0NPTC9VD13vZt9vv3ivgZ+Kj5OPnH+lf65/t3/Af8mP0p/br+S/7c/23////uAA5BZG9iZQBkAAAAAAH/2wCEAAYEBAQFBAYFBQYJBgUGCQsIBgYICwwKCgsKCgwQDAwMDAwMEAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBwcHDQwNGBAQGBQODg4UFA4ODg4UEQwMDAwMEREMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIApAB9AMBEQACEQEDEQH/3QAEAD//xAGiAAAABwEBAQEBAAAAAAAAAAAEBQMCBgEABwgJCgsBAAICAwEBAQEBAAAAAAAAAAEAAgMEBQYHCAkKCxAAAgEDAwIEAgYHAwQCBgJzAQIDEQQABSESMUFRBhNhInGBFDKRoQcVsUIjwVLR4TMWYvAkcoLxJUM0U5KismNzwjVEJ5OjszYXVGR0w9LiCCaDCQoYGYSURUaktFbTVSga8uPzxNTk9GV1hZWltcXV5fVmdoaWprbG1ub2N0dXZ3eHl6e3x9fn9zhIWGh4iJiouMjY6PgpOUlZaXmJmam5ydnp+So6SlpqeoqaqrrK2ur6EQACAgECAwUFBAUGBAgDA20BAAIRAwQhEjFBBVETYSIGcYGRMqGx8BTB0eEjQhVSYnLxMyQ0Q4IWklMlomOywgdz0jXiRIMXVJMICQoYGSY2RRonZHRVN/Kjs8MoKdPj84SUpLTE1OT0ZXWFlaW1xdXl9UZWZnaGlqa2xtbm9kdXZ3eHl6e3x9fn9zhIWGh4iJiouMjY6Pg5SVlpeYmZqbnJ2en5KjpKWmp6ipqqusra6vr/2gAMAwEAAhEDEQA/APROgaBoUuhadLLp1q8j2sLO7QxlmYxqSSSu5OKo/wDw55e/6tdp/wAiIv8AmnFXf4c8vf8AVrtP+REX/NOKu/w55e/6tdp/yIi/5pxV4H/zkuzaPqmhppBOnJNBOZVtP3Ach0ALCPjyp75rtdOUSKNO/wCxsMJxlxCMtx9QeL/4h1//AKuV1/yPk/5qzB8af86Xzdz+Uw/zIf6WLv8AEOv/APVyuv8AkfJ/zVj40/50vmv5TD/Mh/pYu/xDr/8A1crr/kfJ/wA1Y+NP+dL5r+Uw/wAyH+li7/EOv/8AVyuv+R8n/NWPjT/nS+a/lMP8yH+li7/EOv8A/Vyuv+R8n/NWPjT/AJ0vmv5TD/Mh/pYu/wAQ6/8A9XK6/wCR8n/NWPjT/nS+a/lMP8yH+li7/EOv/wDVyuv+R8n/ADVj40/50vmv5TD/ADIf6WLv8Q6//wBXK6/5Hyf81Y+NP+dL5r+Uw/zIf6WLv8Q6/wD9XK6/5Hyf81Y+NP8AnS+a/lMP8yH+li7/ABDr/wD1crr/AJHyf81Y+NP+dL5r+Uw/zIf6WLv8Q6//ANXK6/5Hyf8ANWPjT/nS+a/lMP8AMh/pYu/xDr//AFcrr/kfJ/zVj40/50vmv5TD/Mh/pYu/xDr/AP1crr/kfJ/zVj40/wCdL5r+Uw/zIf6WLv8AEOv/APVyuv8AkfJ/zVj40/50vmv5TD/Mh/pYu/xDr/8A1crr/kfJ/wA1Y+NP+dL5r+Uw/wAyH+li7/EOv/8AVyuv+R8n/NWPjT/nS+a/lMP8yH+li7/EOv8A/Vyuv+R8n/NWPjT/AJ0vmv5TD/Mh/pYu/wAQ6/8A9XK6/wCR8n/NWPjT/nS+a/lMP8yH+li7/EOv/wDVyuv+R8n/ADVj40/50vmv5TD/ADIf6WLv8Q6//wBXK6/5Hyf81Y+NP+dL5r+Uw/zIf6WLv8Q6/wD9XK6/5Hyf81Y+NP8AnS+a/lMP8yH+li7/ABDr/wD1crr/AJHyf81Y+NP+dL5r+Uw/zIf6WLv8Q6//ANXK6/5Hyf8ANWPjT/nS+a/lMP8AMh/pYu/xDr//AFcrr/kfJ/zVj40/50vmv5TD/Mh/pYu/xDr/AP1crr/kfJ/zVj40/wCdL5r+Uw/zIf6WLv8AEOv/APVyuv8AkfJ/zVj40/50vmv5TD/Mh/pYu/xDr/8A1crr/kfJ/wA1Y+NP+dL5r+Uw/wAyH+li7/EOv/8AVyuv+R8n/NWPjT/nS+a/lMP8yH+li7/EOv8A/Vyuv+R8n/NWPjT/AJ0vmv5TD/Mh/pYu/wAQ6/8A9XK6/wCR8n/NWPjT/nS+a/lMP8yH+li7/EOv/wDVyuv+R8n/ADVj40/50vmv5TD/ADIf6WLv8Q6//wBXK6/5Hyf81Y+NP+dL5r+Uw/zIf6WLv8Q6/wD9XK6/5Hyf81Y+NP8AnS+a/lMP8yH+li7/ABDr/wD1crr/AJHyf81Y+NP+dL5r+Uw/zIf6WLv8Q6//ANXK6/5Hyf8ANWPjT/nS+a/lMP8AMh/pYu/xDr//AFcrr/kfJ/zVj40/50vmv5TD/Mh/pYu/xDr/AP1crr/kfJ/zVj40/wCdL5r+Uw/zIf6WLv8AEOv/APVyuv8AkfJ/zVj40/50vmv5TD/Mh/pYu/xDr/8A1crr/kfJ/wA1Y+NP+dL5r+Uw/wAyH+li7/EOv/8AVyuv+R8n/NWPjT/nS+a/lMP8yH+li7/EOv8A/Vyuv+R8n/NWPjT/AJ0vmv5TD/Mh/pYu/wAQ6/8A9XK6/wCR8n/NWPjT/nS+a/lMP8yH+li7/EOv/wDVyuv+R8n/ADVj40/50vmv5TD/ADIf6WLv8Q6//wBXK6/5Hyf81Y+NP+dL5r+Uw/zIf6WLv8Q6/wD9XK6/5Hyf81Y+NP8AnS+a/lMP8yH+li7/ABDr/wD1crr/AJHyf81Y+NP+dL5r+Uw/zIf6WLv8Q6//ANXK6/5Hyf8ANWPjT/nS+a/lMP8AMh/pYu/xDr//AFcrr/kfJ/zVj40/50vmv5TD/Mh/pYu/xDr/AP1crr/kfJ/zVj40/wCdL5r+Uw/zIf6WLv8AEOv/APVyuv8AkfJ/zVj40/50vmv5TD/Mh/pYu/xDr/8A1crr/kfJ/wA1Y+NP+dL5r+Uw/wAyH+li7/EOv/8AVyuv+R8n/NWPjT/nS+a/lMP8yH+li7/EOv8A/Vyuv+R8n/NWPjT/AJ0vmv5TD/Mh/pYvtrSvL+gvpdm76bas7QRlmMEZJJQEkkrm+jyeKn9R96K/w55e/wCrXaf8iIv+acLB3+HPL3/VrtP+REX/ADTirv8ADnl7/q12n/IiL/mnFUi/Qmjf46+rfULb6t+i/U9D0k4c/rHHlxpx5cduWKv/0PTHlz/lHtL/AOYSD/k0uKpjirsVdiqWax5X8t608cmr6Vaai8IKxNdQxzFQ25ClwaVpkJY4y5i23HnnD6SY/wBVL/8AlW35e/8AUs6X/wBIcH/NGR8CHcGz85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8vf+pZ0v8A6Q4P+aMfAh3Bfzmb+fP/AExd/wAq2/L3/qWdL/6Q4P8AmjHwIdwX85m/nz/0xd/yrb8v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</binary>
</FictionBook>